---
title: "Genomic features of the breakpoints"
author: 
 - "Charlotte West"
 - "Charles Plessy"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEncoding{UTF-8}
  %\VignetteIndexEntry{Genomic features of the breakpoints}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup, cache=FALSE}
knitr::opts_chunk$set(cache = TRUE, cache.lazy = FALSE)
knitr::opts_knit$set(verbose = TRUE)
```

Load packages and data
======================

See `?OikScrambling:::loadAllGenomes`, `?OikScrambling:::loadAllTranscriptsGR`,
and `vignette("LoadGenomicBreaks", package = "OikScrambling")` for how the
different objects are prepared.

```{r load_packages_and_data}
library('OikScrambling')   |> suppressPackageStartupMessages()
library('GenomicFeatures') |> suppressPackageStartupMessages()
library('heatmaps')        |> suppressPackageStartupMessages()
genomes     <- OikScrambling:::loadAllGenomes()
transcripts <- OikScrambling:::loadAllTranscriptsGR() |> suppressWarnings()
annots      <- OikScrambling:::loadAllAnnotations()   |> suppressWarnings()
reps        <- OikScrambling:::loadAllRepeats()
load("BreakPoints.Rdata")
requireNamespace("rGADEM")    |> suppressPackageStartupMessages()
requireNamespace("ggseqlogo") |> suppressPackageStartupMessages()
```

# Nucleic acid content heatmaps

The `GenomicBreaks::bp_heatmap()` function plots nucleic acid content in windows
centered on alignment stops.

## GC

Lets look at `GC` content before and after coalescing: 

```{r echo=T, fig.height=6, fig.width=12, message=FALSE, warning=FALSE}
#hm_GC1 <- sapply(gbs,  bp_heatmap, basep_range = 1000, pat = "GC", direction = "left") |> SimpleList()
hm_GC2 <- sapply(coa[1:15],  bp_heatmap, basep_range = 1000, pat = "GC", direction = "left") |> SimpleList()
#hm_GC3 <- sapply(coa2, bp_heatmap, basep_range = 1000, pat = "GC", direction = "left") |> SimpleList()

maxHeight <- 2000
#sm_GC1 <- sapply(hm_GC1, smoothHeatmap, output.size = c(maxHeight,     500), algorithm = "kernel") |> SimpleList()
sm_GC2 <- sapply(hm_GC2, smoothHeatmap, output.size = c(maxHeight,     500), algorithm = "kernel") |> SimpleList()
#sm_GC3 <- sapply(hm_GC3, smoothHeatmap, output.size = c(maxHeight,     500), algorithm = "kernel") |> SimpleList()

#plotHeatmapList(sm_GC1[1:5])

plotHeatmapList(sm_GC2[1:5])
#plotHeatmapList(sm_GC2[6:10])
#plotHeatmapList(sm_GC2[11:15])

#plotHeatmapList(sm_GC3[1:5])
```

The alignment stops are ordered in such a way that start (or left breaks) are
centred on the top half of the plot, and end alignment stops are centred on the
bottom. This is why we see different directionality in the plots. At the
alignment stops, the GC content seems to be lower, but higher once within the
aligned region, except for the Oki – Kum pair.

## TATA

Now looking at TATA content:

```{r TATA, fig.height=6, fig.width=12, message=FALSE, warning=FALSE}
#hm_GC1_TATA <- sapply(gbs, bp_heatmap, basep_range = 1000, pat = "TATA", direction = "left") |> SimpleList()
hm_GC2_TATA <- sapply(coa[1:15], bp_heatmap, basep_range = 1000, pat = "TATA", direction = "left") |> SimpleList()

maxHeight <- 2000
#sm_GC1_TATA <- sapply(hm_GC1_TATA, smoothHeatmap, output.size = c(maxHeight,     500), algorithm = "kernel") |> SimpleList()
sm_GC2_TATA <- sapply(hm_GC2_TATA, smoothHeatmap, output.size = c(maxHeight,     500), algorithm = "kernel") |> SimpleList()
#sm_GC3_TATA <- sapply(hm_GC3_TATA, smoothHeatmap, output.size = c(maxHeight,     500), algorithm = "kernel") |> SimpleList()

#plotHeatmapList(sm_GC1_TATA)
plotHeatmapList(sm_GC2_TATA[1:5])
#plotHeatmapList(sm_GC3_TATA)
```

The directionaility here is consistent with the `GC` content analysis.
Furthermore; "TATA box sequence can act as a basal promoter element not only for
RNA polymerase II (RNAP II) transcription, but also for transcription by RNA
polymerase III (RNAP III)" - Wang Y, Jensen RC, Stumph WE. Role of TATA box
sequence and orientation in determining RNA polymerase II/III transcription
specificity. Nucleic Acids Res. 1996;24(15):3100–3106.
doi:10.1093/nar/24.15.3100. However, the areas are not particularly enriched
for TATA boxes, so it does not necessarily show that breakpoints are occurring
directly after promoter regions. 


```{r AAGCsGCwwmkCGrCTTyn, fig.height=6, fig.width=12, message=FALSE, warning=FALSE}
#hm_GC1_mot <- sapply(gbs, bp_heatmap, basep_range = 1000, pat = "AGCNGC", direction = "left") |> SimpleList()
hm_GC2_mot <- sapply(coa[1:15], bp_heatmap, basep_range = 1000, pat = "AGCNGC", direction = "left") |> SimpleList()

maxHeight <- 2000
#sm_GC1_mot <- sapply(hm_GC1_mot, smoothHeatmap, output.size = c(maxHeight,     500), algorithm = "kernel") |> SimpleList()
sm_GC2_mot <- sapply(hm_GC2_mot, smoothHeatmap, output.size = c(maxHeight,     500), algorithm = "kernel") |> SimpleList()
#sm_GC3_mot <- sapply(hm_GC3_mot, smoothHeatmap, output.size = c(maxHeight,     500), algorithm = "kernel") |> SimpleList()

#plotHeatmapList(sm_GC1_mot)
plotHeatmapList(sm_GC2_mot[1:5])
#plotHeatmapList(sm_GC3_mot)
```


## Cluster analysis


```{r cluster_analysis, fig.height=20, fig.width=20}
# # Accessory functions
# clusterHeatmap <- function(hm, k = 2) kmeans(image(hm), k)
# 
# orderHeatmap <- function(hm, cl) {
#   image(hm) <- image(hm)[order(cl$cluster),]
#   hm
# }
# 
# subsetHeatmap <- function(hm, bool) {
#   image(hm) <- image(hm)[bool,]
#   hm
# }
# 
# # DAta
# hm_GC   <- bp_heatmap(      gr_Oki_O, basep_range  = 1000, pat = "GC",     direction = "left")
# hm_TATA <- bp_heatmap(      gr_Oki_O, basep_range  = 1000, pat = "TATA",   direction = "left")
# hm_tan  <- feature_coverage(gr_Oki_O, tan_Oki, win = 1000, lab = "Tandem", direction = "left")
# 
# # Define 3 K-mean clusters
# clusterHeatmap(hm_GC, 3) -> hm_cl_k4
# 
# # Order and smooth
# shm_GC <- orderHeatmap(hm_GC, hm_cl_k4) %>%
#   smoothHeatmap(output.size = c(2000,500), algorithm = "kernel")
# 
# shm_TATA <- orderHeatmap(hm_TATA, hm_cl_k4) %>%
#   smoothHeatmap(output.size = c(2000,500), algorithm = "kernel")
# 
# shm_tan <- orderHeatmap(hm_tan, hm_cl_k4) %>%
#   smoothHeatmap(output.size = c(2000,500), algorithm = "kernel")
# 
# # Plot the ordered data
# plotHeatmapList(list(shm_GC, shm_TATA, shm_tan))
# par(mfrow = c(1,1)) # plotHeatmapList messes with mrfrow...
# plotHeatmapMeta(list(hm_GC, hm_TATA, hm_tan))
# 
# plotHeatmapMeta(list(subsetHeatmap(hm_GC, hm_cl_k4$cluster == 1),
#                      subsetHeatmap(hm_GC, hm_cl_k4$cluster == 2),
#                      subsetHeatmap(hm_GC, hm_cl_k4$cluster == 3)))
# 
# kmeanOrderedPlot <- function (hm, k=3, seed = 1) {
#   set.seed(seed)
#   
#   cl <- kmeans(image(hm), k)
#   mat <- image(hm)[order(cl$cluster),]
#   
#   kmhm = Heatmap(
#     mat,
#     coords=c(-500,500),
#     label="kmeans",
#     scale=range(mat))
#   
#   plotHeatmapList(kmhm,
#                   cex.label=1.5,
#                   partition=as.vector(table(cl$cluster)),
#                   partition.legend=TRUE,
#                   partition.lines=TRUE,
#                   legend=TRUE,
#                   legend.pos="r",
#                   legend.width=0.3)
# }
# 
# kmeanOrderedPlot(shm_GC)
```

## Evidence for breakpoint hotspots

The function `?GenomicBreaks::bp_pair_analysis` takes two pairwise alignments
with the same target genome, and plots the alignment stops on to the centred
alignment stops of the other.

In the plot below, Osaka is there consistent target genome, and as such acts as
a coordinate system to relate alignment stops across genomes. Lets produce two
of these 3-way analyses; one between Osaka-Okinawa-Norway, and one between
Osaka-Okinawa-Aomori.

```{r breakpoint_hotspot_gbs}
bp_pair_analysis(gr_ref_q1 = gbs$Osa_Oki, gr_ref_q2 = gbs$Osa_Nor, win = 1000, lab = "Oki~Nor") |> plotHeatmapMeta()
bp_pair_analysis(gr_ref_q1 = gbs$Osa_Oki, gr_ref_q2 = gbs$Osa_Aom, win = 1000, lab = "Oki~Aom") |> plotHeatmapMeta()
```

The accumulation of alignment breaks of one pairwise alignment onto another
suggests the existence of breakpoint hotspots; regions where breaks are far
more likely to occur. Intuitively, this would lead to the presumption of synteny
blocks, also. The pattern is consistent after coalescing, too;

```{r breakpoint_hotspot_coa}
bp_pair_analysis(gr_ref_q1 = coa$Osa_Oki, gr_ref_q2 = coa$Osa_Nor, win = 1000, lab = "Oki~Nor") |> plotHeatmapMeta()
bp_pair_analysis(gr_ref_q1 = coa$Osa_Oki, gr_ref_q2 = coa$Osa_Aom, win = 1000, lab = "Oki~Aom") |> plotHeatmapMeta()
```

# Gene feature coverage around alignment stops (breakpoints)

Breakpoints are between mapped regions.  If the unmapped region is broad we have
little information where the breakpoint originally was.  We set arbitrarly the
breakpoints to the left-side (end-side) coordinate of mapped regions.

Mapped regions can consist of multiple colinear aligned regions, or be a single
uncoalesced aligned region.  We will see that they have different properties.

The function `feature_coverage` will plot the coverage of tandem repeats around
centred alignment stops. 

```{r genomic_features, cache=FALSE}
current_GB <- coa$Oki_Osa
hmList_OKI <- list()

hmList_OKI$genes      <- feature_coverage(current_GB, genes(annots$Oki),                         win = 2000, lab = "Oki genes", direction = "left")
hmList_OKI$promoters  <- feature_coverage(current_GB, promoters(annots$Oki),                     win = 2000, lab = "Oki promoters", direction = "left")
hmList_OKI$exons      <- feature_coverage(current_GB, exonicParts(annots$Oki),                   win = 2000, lab = "Oki exons", direction = "left")
hmList_OKI$introns    <- feature_coverage(current_GB, intronicParts(annots$Oki),                 win = 2000, lab = "Oki introns", direction = "left")
hmList_OKI$cds        <- feature_coverage(current_GB, cds(annots$Oki),                           win = 2000, lab = "Oki cds", direction = "left")
```

```{r genomic_features_genes_exons_cds, cache=FALSE}
plotHeatmapMeta(hmList_OKI[c("genes", "exons", "cds")]) # Show they look alike.  We keep "exons"
```

The features _genes_, _exons_ and _cds_ have comparable profiles.  Let's keep only _exons_ in the rest of the analysis.

```{r genomic_features_2, cache=FALSE}
plotHeatmapMeta(hmList_OKI[c("promoters", "exons", "introns")])
```

Positive coordinates start in aligned regions and negative coordinates start
in unaligned regions.  As we move further from 0, we can not guarantee that
the statement is still true because some regions have a width narrower than
the plot window.  This is why the values tend to equilibrate near the
boundaries.

Aligned regions are enriched in exons and depleted in introns.

## Breakpoints of wide and narrow regions

Most of the narrow-width aligned regions did not coalesce.  We use this
as a classifier instead of an arbitrary width cutoff.  See
`vignette("RegionWidths", package = "OikScrambling")` for details.

### Coding sequences

Close to the breakpoint of uncoalesced mapped regions, exon annotations are
depleted, which makes sense, as exons are usually mapable.  Within the mapped
regions, frequency of introns and exons are comparable.  In contrary, within
coalesced mapped regions, the exon annotations are over-represented.

```{r genomic_features_byType_accessory_Functions}
prepareFreqPlot <- function(gb, annot, rep, win = 1e3) {
  l <- list()
  l$genes  <- feature_coverage(gb,     genes(annot),         win = win, lab = "genes",  direction = "left")
  #l$cds    <- feature_coverage(gb,     cds(annot),           win = win, lab = "CDS",    direction = "left")
  l$intron <- feature_coverage(gb,     intronicParts(annot), win = win, lab = "intron", direction = "left")
  l$exon   <- feature_coverage(gb,     exonicParts(annot),   win = win, lab = "exon",   direction = "left")
  l$reps   <- feature_coverage(gb,     rep,                  win = win, lab = "repeats",direction = "left")
  #reorder
  newOrder <- order(rowSums(l$intron@image))
  l$intron@image <- l$intron@image[newOrder,]
  l$exon@image   <- l$exon@image[newOrder,]
  l
}

prepareGGFreqPlot <- function(x, desc = NULL) {
  l <- lapply(names(x), \(name){
    val <- colSums(x[[name]]@image)
    what <- name
    tibble::tibble(val, freq = val / nrow(x[[name]]@image), what, pos = 1:length(val) - round(length(val)) / 2, desc)
  })
   do.call(rbind, l)
}
```

#### Synteny as a proxy for aligned region width.

```{r genomic_features_byType}
current_GB_wide   <- coa$Oki_Osa[ ! coa$Oki_Osa$nonCoa] |> plyranges::arrange(width)
current_GB_narrow <- coa$Oki_Osa[   coa$Oki_Osa$nonCoa]
current_GB_unmap   <- unmap$Oki_Osa
current_GB_unalMap <- unalMap$Oki_Osa

current_GB_wide   |> width() |> summary()
current_GB_narrow |> width() |> summary()
current_GB_unmap  |> width() |> summary()
current_GB_unalMap|> width() |> summary()

hmListWide    <- prepareFreqPlot(current_GB_wide,    annots$Oki, reps$Oki)
hmListNarrow  <- prepareFreqPlot(current_GB_narrow,  annots$Oki, reps$Oki)
hmListUnmap   <- prepareFreqPlot(current_GB_unmap,   annots$Oki, reps$Oki)
hmListUnalMap <- prepareFreqPlot(current_GB_unalMap, annots$Oki, reps $Oki)

rbind(
  hmListNarrow  |> prepareGGFreqPlot("01_narrow"),
  hmListUnmap   |> prepareGGFreqPlot("02_unmap"),
  hmListWide    |> prepareGGFreqPlot("03_wide"),
  hmListUnalMap |> prepareGGFreqPlot("04_unalMap")

)|> ggplot() +
  aes(pos, freq, col = what) +
  geom_line() +
  facet_wrap(~desc, nrow = 1)
```

#### Linked regions

Same approach, but enforcing a succession of just-aligned, unaligned and
syntenic regions.

```{r genomic_features_byType2}
flag_aln_unal_syn <- function (x) {
  p0 <- x$type
  p1 <- c(tail(p0, -1), factor('aligned'))
  p2 <- c(tail(p0, -2), factor('aligned'), factor('aligned'))
  p0 == 'aligned' & p1 == 'unaligned' & p2 == 'syntenic'
}
current_GB$flag_a_u_s <- flag_aln_unal_syn(current_GB)

current_GB_aln     <- current_GB[which(current_GB$flag_a_u_s) + 0]
current_GB_unal    <- current_GB[which(current_GB$flag_a_u_s) + 1]
current_GB_syn     <- current_GB[which(current_GB$flag_a_u_s) + 2]

current_GB_aln   |> width() |> summary()
current_GB_unal  |> width() |> summary()
current_GB_syn   |> width() |> summary()

hmListAln     <- prepareFreqPlot(current_GB_aln,     annots$Oki, reps$Oki)
hmListUnal    <- prepareFreqPlot(current_GB_unal,    annots$Oki, reps$Oki)
hmListSyn     <- prepareFreqPlot(current_GB_syn,     annots$Oki, reps$Oki)

rbind(
  hmListAln  |> prepareGGFreqPlot("01_narrow"),
  hmListUnal |> prepareGGFreqPlot("02_unal"),
  hmListSyn  |> prepareGGFreqPlot("03_syn")

)|> ggplot() +
  aes(pos, freq, col = what) +
  geom_line() +
  facet_wrap(~desc, nrow = 1)
```

This mildens the differences observed in the earlier section, probably because
it requires the aligned region to be nearby a syntenic region.

#### Aligning on center instead of border.

As the plots are hardcoded to use the left border, let's artificially make
regions of 1 bp on centers, rather than changing the accessory function.

```{r genomic_features_byType_center}
current_GB_wide_c    <- current_GB_wide    |> plyranges::anchor_center() |> plyranges::mutate(width=1)
current_GB_narrow_c  <- current_GB_narrow  |> plyranges::anchor_center() |> plyranges::mutate(width=1)
current_GB_unmap_c   <- current_GB_unmap   |> plyranges::anchor_center() |> plyranges::mutate(width=1)
current_GB_unalMap_c <- current_GB_unalMap |> plyranges::anchor_center() |> plyranges::mutate(width=1)

hmListWide_c    <- prepareFreqPlot(current_GB_wide_c,    annots$Oki, reps$Oki)
hmListNarrow_c  <- prepareFreqPlot(current_GB_narrow_c,  annots$Oki, reps$Oki)
hmListUnmap_c   <- prepareFreqPlot(current_GB_unmap_c,   annots$Oki, reps$Oki)
hmListUnalMap_c <- prepareFreqPlot(current_GB_unalMap_c, annots$Oki, reps$Oki)

rbind(
  hmListNarrow_c  |> prepareGGFreqPlot("01_narrow"),
  hmListUnmap_c   |> prepareGGFreqPlot("02_unmap"),
  hmListWide_c    |> prepareGGFreqPlot("03_wide"),
  hmListUnalMap_c |> prepareGGFreqPlot("04_unalMap")

)|> ggplot() +
  aes(pos, freq, col = what) +
  geom_line() +
  facet_wrap(~desc, nrow = 1)
```


### PWM

The PWM motif, which is rare in comparison to the other features, follows
a profile that bears resemblance to the repeat profile.

```{r genomic_pwm_bpByWidth, cache=FALSE}
gadems.invLeftGap <- readRDS("gadems.invLeftGap.Rda")
pwm <- gadems.invLeftGap$Oki_Osa[[1]]
pwm@consensus
# pwmHits <- matchPWM(pwm = sapply(pwm@alignList, \(x) x@seq) |> as("DNAStringSet") |> PWM(), genomes$Oki) # Gives different scores...
pwmHits <- matchPWM(pwm = rGADEM::getPWM(pwm), genomes$Oki) |> suppressWarnings()
# Suppressing warnings like:
# Warning messages:
# 1: In .Call2("XString_match_PWM", pwm, subject, min.score, count.only,  :
#   'subject' contains letters not in [ACGT] ==> assigned weight 0 to them

plotHeatmapMeta(list(feature_coverage(current_GB_wide,   pwmHits, win = 1e3, lab = "wide",    direction = "left")))
plotHeatmapMeta(list(feature_coverage(current_GB_narrow, pwmHits, win = 1e3, lab = "narrow",  direction = "left")))
```

### Question

in `vignette("ColinearityInterruptors", package = "OikScrambling")`, we saw
that some uncoalesced regions map uniquely and are well conserved across
genomes.  What are they... enhancers ?

## Gene feature coverage around PWM hits

Let's look at coverage around PWM hits of the AAGCsGCwwmkCGrCTTyn motif

```{r genomic_features_pwmHits, cache=FALSE}
current_GB <- pwmHits

hmList_PWM_OKI <- list()
hmList_PWM_OKI$genes     <- feature_coverage(current_GB, genes(annots$Oki),                         win = 2000, lab = "Oki genes", direction = "left")
hmList_PWM_OKI$promoters <- feature_coverage(current_GB, promoters(annots$Oki),                     win = 2000, lab = "Oki promoters", direction = "left")
hmList_PWM_OKI$exons     <- feature_coverage(current_GB, exonicParts(annots$Oki),                   win = 2000, lab = "Oki exons", direction = "left")
hmList_PWM_OKI$introns   <- feature_coverage(current_GB, intronicParts(annots$Oki),                 win = 2000, lab = "Oki introns", direction = "left")
hmList_PWM_OKI$cds       <- feature_coverage(current_GB, cds(annots$Oki),                           win = 2000, lab = "Oki cds", direction = "left")

plotHeatmapMeta(hmList_PWM_OKI[c("genes", "exons", "cds")]) # Show they look alike.  We keep "exons"
plotHeatmapMeta(hmList_PWM_OKI[c("promoters", "exons", "introns")])
```

They are enriched in introns...

```{r genomic_features3, cache=FALSE}
# 
# # Sandbox to make sanity checks.
# 
# a <- coa$Oki_Osa
# b <- unlist(fiveUTRsByTranscript(annots$Oki))
# 
# hm_a <- feature_coverage(a, b, win = 2000, lab = "All ranges", direction = "left")
# hm_b <- feature_coverage(subsetByOverlaps(a,  b), b, win = 2000, lab = "Subsetted ranges", direction = "left")
# 
# plotHeatmapMeta(list(hm_a))
# plotHeatmapMeta(list(hm_b))
```

## Breakpoint coverage around PWM hits

TODO: triplecheck `feature_coverage`, it is old…

```{r genomic_features_pwmHits2, cache=FALSE}
current_GB <- pwmHits

hmList_PWM_OKI$gbOsa     <- feature_coverage(current_GB, gbs$Oki_Osa,  win = 5000, lab = "Oki-Osa", direction = "left")
hmList_PWM_OKI$gbBar     <- feature_coverage(current_GB, gbs$Oki_Bar,  win = 5000, lab = "Oki-Bar", direction = "left")
hmList_PWM_OKI$gbKum     <- feature_coverage(current_GB, gbs$Oki_Kum,  win = 5000, lab = "Oki-Kum", direction = "left")

plotHeatmapMeta(hmList_PWM_OKI[c("gbOsa", "gbBar", "gbKum")])

hmList_PWM_OKI$coOsa     <- feature_coverage(current_GB, coa$Oki_Osa,  win = 5000, lab = "Oki-Osa", direction = "left")
hmList_PWM_OKI$coBar     <- feature_coverage(current_GB, coa$Oki_Bar,  win = 5000, lab = "Oki-Bar", direction = "left")
hmList_PWM_OKI$coKum     <- feature_coverage(current_GB, coa$Oki_Kum,  win = 5000, lab = "Oki-Kum", direction = "left")

plotHeatmapMeta(hmList_PWM_OKI[c("coOsa", "coBar", "coKum")])
```

## Okinawa genome coverage

As previously discussed, low coverage over an alignment stop could lower the likelihood of it being considered as a breakpoint. We have per-base coverage depth information for the Okinawan genome (`Oki_cov_pb`). However, the coverage of this particular assembly is quite good. In fact, we can investigate the coverge over alignment stops from the information obtained using `master_bp_analysis`. 

```{r echo=T, message=F, warning=F}
# fin_Oki <- fin_gr_O_Oki[[2]]
# min_cov <- min(min(fin_Oki$left_cov_pb), min(fin_Oki$right_cov_pb)) # minimum coverage over an alignment stop
# min_cov
# length(fin_Oki[fin_Oki$left_cov_pb == min_cov]) + length(fin_Oki[fin_Oki$right_cov_pb == min_cov]) # how many of the minimum coverage is observed
# length(fin_Oki[fin_Oki$left_cov_pb <= 50]) + length(fin_Oki[fin_Oki$right_cov_pb <= 50]) # how many alignment stops have a coverage of less than or euqal to 50

```

We may choose to kick out the one alignment stop for which there is no coverage. However, only 15 out of 34572 alignment stops have a coverage of less than or equal to 50, meaning that it would be hard to exclude more than just a few alignment stops using coverage information for breakpoint analysis. 

# Coverage

_Needs coverage information to be recomputed_

Another characteristic of alignment stops that we can examine is the coverage depth over said alignment stops. By aligning raw reads to assembled genomes, we can obtain per-base coverage depth for target or query genome. Low coverage directly on and surrounding an alignment stop may suggest unreliability in it being a true breakpoint. The function `bp_coverage` returns a GRanges object of the bps, with associated averaged and point converage in the metadatacolumns. 

```{r coverage}
# cov_gr_O_Oki <- bp_coverage(gr_ob = q_Oki, cov_gr = Oki_cov_pb, win = 50)
# cov_gr_O_Oki
```

# Session information

```{r sessioninfo}
sessionInfo()
```
