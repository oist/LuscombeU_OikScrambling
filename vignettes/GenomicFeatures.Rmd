---
title: "Genomic features of the breakpoints"
author: 
 - "Charlotte West"
 - "Charles Plessy"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEncoding{UTF-8}
  %\VignetteIndexEntry{Genomic features of the breakpoints}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

Load packages and data
======================

See `?OikScrambling:::loadAllGenomes`, `?OikScrambling:::loadAllTranscriptsGR`,
and `vignette("LoadGenomicBreaks", package = "OikScrambling")` for how the
different objects are prepared.

```{r load_packages_and_data}
library('OikScrambling')   |> suppressPackageStartupMessages()
library('GenomicFeatures') |> suppressPackageStartupMessages()
library('heatmaps')        |> suppressPackageStartupMessages()
library('patchwork')       |> suppressPackageStartupMessages()
genomes     <- OikScrambling:::loadAllGenomes(compat = F)
# Cannot use Knitr cache as long as "annot" objects are used.
annots      <- OikScrambling:::loadAllAnnotations()   |> suppressWarnings()
reps        <- OikScrambling:::loadAllRepeats(compat = F)
genes       <- sapply(annots, function(a) sort(genes(a))) |> SimpleList()
load("BreakPoints.Rdata")
requireNamespace("rGADEM")    |> suppressPackageStartupMessages()
requireNamespace("ggseqlogo") |> suppressPackageStartupMessages()
ces <- readRDS("CEs.Rds")
tfbs <- readRDS("pwmMatchesOki_12_95.Rds")
```

# Nucleic acid content heatmaps

The `GenomicBreaks::bp_heatmap()` function plots nucleic acid content in windows
centered on alignment stops.

## GC

Lets look at `GC` content before and after coalescing: 

```{r echo=T, fig.height=6, fig.width=12, message=FALSE, warning=FALSE}
maxHeight <- 2000
sm_GC2 <- sapply(coa[1:15],  bp_heatmap, win = 1000, pat = "GC", direction = "left") |>
          sapply(smoothHeatmap, output.size = c(maxHeight,     500), algorithm = "kernel") |> SimpleList()
plotHeatmapList(sm_GC2[1:5])
```

The alignment stops are ordered in such a way that start (or left breaks) are
centred on the top half of the plot, and end alignment stops are centred on the
bottom. This is why we see different directionality in the plots. At the
alignment stops, the GC content seems to be lower, but higher once within the
aligned region, except for the Oki – Kum pair.

## TATA

Now looking at TATA content:

```{r TATA, fig.height=6, fig.width=12, message=FALSE, warning=FALSE}
maxHeight <- 2000
sm_GC2_TATA <- sapply(coa[1:15], bp_heatmap, window = 1000, pat = "TATA", direction = "left") |> 
               sapply(smoothHeatmap, output.size = c(maxHeight,     500), algorithm = "kernel") |> SimpleList()
plotHeatmapList(sm_GC2_TATA[1:5])
```

The directionaility here is consistent with the `GC` content analysis.
Furthermore; "TATA box sequence can act as a basal promoter element not only for
RNA polymerase II (RNAP II) transcription, but also for transcription by RNA
polymerase III (RNAP III)" - Wang Y, Jensen RC, Stumph WE. Role of TATA box
sequence and orientation in determining RNA polymerase II/III transcription
specificity. Nucleic Acids Res. 1996;24(15):3100–3106.
doi:10.1093/nar/24.15.3100. However, the areas are not particularly enriched
for TATA boxes, so it does not necessarily show that breakpoints are occurring
directly after promoter regions. 


```{r AAGCsGCwwmkCGrCTTyn, fig.height=6, fig.width=12, message=FALSE, warning=FALSE}
maxHeight <- 2000
sm_GC2_mot <- sapply(coa[1:15], bp_heatmap, window = 1000, pat = "AGCNGC", direction = "left") |> 
              sapply(smoothHeatmap, output.size = c(maxHeight,     500), algorithm = "kernel") |> SimpleList()
plotHeatmapList(sm_GC2_mot[1:5])
```


## Cluster analysis

```{r cluster_analysis, fig.height=20, fig.width=20}
# # Accessory functions
# clusterHeatmap <- function(hm, k = 2) kmeans(image(hm), k)
# 
# orderHeatmap <- function(hm, cl) {
#   image(hm) <- image(hm)[order(cl$cluster),]
#   hm
# }
# 
# subsetHeatmap <- function(hm, bool) {
#   image(hm) <- image(hm)[bool,]
#   hm
# }
# 
# # DAta
# hm_GC   <- bp_heatmap(      gr_Oki_O, basep_range  = 1000, pat = "GC",     direction = "left")
# hm_TATA <- bp_heatmap(      gr_Oki_O, basep_range  = 1000, pat = "TATA",   direction = "left")
# hm_tan  <- feature_coverage(gr_Oki_O, tan_Oki, win = 1000, lab = "Tandem", direction = "left")
# 
# # Define 3 K-mean clusters
# clusterHeatmap(hm_GC, 3) -> hm_cl_k4
# 
# # Order and smooth
# shm_GC <- orderHeatmap(hm_GC, hm_cl_k4) %>%
#   smoothHeatmap(output.size = c(2000,500), algorithm = "kernel")
# 
# shm_TATA <- orderHeatmap(hm_TATA, hm_cl_k4) %>%
#   smoothHeatmap(output.size = c(2000,500), algorithm = "kernel")
# 
# shm_tan <- orderHeatmap(hm_tan, hm_cl_k4) %>%
#   smoothHeatmap(output.size = c(2000,500), algorithm = "kernel")
# 
# # Plot the ordered data
# plotHeatmapList(list(shm_GC, shm_TATA, shm_tan))
# par(mfrow = c(1,1)) # plotHeatmapList messes with mrfrow...
# plotHeatmapMeta(list(hm_GC, hm_TATA, hm_tan))
# 
# plotHeatmapMeta(list(subsetHeatmap(hm_GC, hm_cl_k4$cluster == 1),
#                      subsetHeatmap(hm_GC, hm_cl_k4$cluster == 2),
#                      subsetHeatmap(hm_GC, hm_cl_k4$cluster == 3)))
# 
# kmeanOrderedPlot <- function (hm, k=3, seed = 1) {
#   set.seed(seed)
#   
#   cl <- kmeans(image(hm), k)
#   mat <- image(hm)[order(cl$cluster),]
#   
#   kmhm = Heatmap(
#     mat,
#     coords=c(-500,500),
#     label="kmeans",
#     scale=range(mat))
#   
#   plotHeatmapList(kmhm,
#                   cex.label=1.5,
#                   partition=as.vector(table(cl$cluster)),
#                   partition.legend=TRUE,
#                   partition.lines=TRUE,
#                   legend=TRUE,
#                   legend.pos="r",
#                   legend.width=0.3)
# }
# 
# kmeanOrderedPlot(shm_GC)
```

## Evidence for breakpoint hotspots

The function `?GenomicBreaks::bp_pair_analysis` takes two pairwise alignments
with the same target genome, and plots the alignment stops on to the centred
alignment stops of the other.

In the plot below, Osaka is there consistent target genome, and as such acts as
a coordinate system to relate alignment stops across genomes. Lets produce two
of these 3-way analyses; one between Osaka-Okinawa-Norway, and one between
Osaka-Okinawa-Aomori.

```{r breakpoint_hotspot_gbs}
bp_pair_analysis(gbs$Osa_Oki, gbs$Osa_Nor, win = 1000, lab = "Oki~Nor") |> plotHeatmapMeta()
bp_pair_analysis(gbs$Osa_Oki, gbs$Osa_Aom, win = 1000, lab = "Oki~Aom") |> plotHeatmapMeta()
```

The accumulation of alignment breaks of one pairwise alignment onto another
suggests the existence of breakpoint hotspots; regions where breaks are far
more likely to occur. Intuitively, this would lead to the presumption of synteny
blocks, also. The pattern is consistent after coalescing, too;

```{r breakpoint_hotspot_coa}
bp_pair_analysis(coa$Osa_Oki, coa$Osa_Nor, win = 1000, lab = "Oki~Nor") |> plotHeatmapMeta()
bp_pair_analysis(coa$Osa_Oki, coa$Osa_Aom, win = 1000, lab = "Oki~Aom") |> plotHeatmapMeta()
```

# Gene feature coverage around aligned and unaligned genomic regions.

## Model operon areas

### Notes about operons

The operon of [Ganot et al., 2004](https://journals.asm.org/doi/10.1128/MCB.24.17.7795-7805.2004)
appears to be conserved in OKI and OSA (near `OSKA2016v1.9::PAR:10984831-10995276`).
In the annotation visible in ZENBU and NCBI:

 - `Oidioi.mRNA.OKI2018_I69.PAR.g12978` is the most likely start of the Ganot operon as
   it starts downstream of a CAGE TSS peak and has no trans-splicing site.  It is
   homologous to `g10133 (PAR:10985271..10985910+)` in OSKA2016v1.9 which also has a
   transcription start site and no trans-splicing site.  Best Norwegian hit is `CBY19033`.
   Gene name is unclear but weaker blast hits suggest _centrosomal POC5 isoform X1_.
 - IQ domain-containing protein K isoform X2 is `Oidioi.mRNA.OKI2018_I69.PAR.g12977`
   and is `g10134` in OSKA2016.  It has a bona fide trans-splicing site in both genomes.
   It is `CBY19034` in Norway. (Not reported in Ganot et al., 2004).
 - Exportin 7 is `Oidioi.mRNA.OKI2018_I69.PAR.g12976`. (First member
   of the operon of Ganot et al., 2004, which calls it Ran-binding protein 16).  In the current annotation of the OSKA2016v1.9
   genome, `g10135` matches well but misses the N-terminal part. Nevertheless a blastx
   search in region `PAR:10986742..10988032+` finds it.  In line with this, there is
   a trans-splicing site upstream the unannotated area.
 - Dynein light chain is `Oidioi.mRNA.OKI2018_I69.PAR.g12975`.
 - Delta tubulin is `Oidioi.mRNA.OKI2018_I69.PAR.g12974`.
 - _MBF_ is `Oidioi.mRNA.OKI2018_I69.PAR.g12973`.  Also called _enthelial differenciation-related factor 1_ in other species.
 - CycD is `Oidioi.mRNA.OKI2018_I69.PAR.g12972` and `g10138` in OSKA. Polyadenylation signal conserved.
 
(Note that the transcripts IDs here differ from the public ones.)

Ganot et al., 2004 reported very small (<30) intercistronic regions and Denoeud
et al., 2010 stated: “_The operons were predicted as co-oriented genes
separated by 60 nucleotides at most : 1761 operons containing 4997 genes were
predicted on the reference assembly_”.  However, in our annotation, we do not
have the UTRs, but only the distances between translation stops and starts, so
we need a broader window.  The example below shows that a window of 400 would
break the Ganot 2004 operon, so let's use 500 instead.

```{r ganot_operon}
transcripts(annots$Oki) |> subsetByOverlaps(GRanges("PAR:15956430-15967745"))
transcripts(annots$Oki) |> subsetByOverlaps(GRanges("PAR:15956430-15967745")) |> cleanGaps() |> width()
```

### Compute operons

```{r guess_operons}
operons <- lapply(annots, \(a) {a |> genes() |> OikScrambling:::calcOperons(window = 500) }) |> SimpleList() |> suppressWarnings()
operons$Nor <- OikScrambling:::calcOperons(window = 500, transcripts(annots$Nor) |> reduce()) |> suppressWarnings()
sapply(operons, length)
sapply(operons, \(o) {table(o$n)})
```

With the OdB3 genome, the results are apparently close to those of Denoeud et
al., 2010 (see above for why the difference).  We have a few more (1844 instead
of 1761), they contain more genes (5814 instead of 4997), mostly because our
computation outputs 50 operons longer than 9 genes (617 genes in total).
Nevertheless, the proportion of operons of length 2, 3 and 4 are visually
similar in both cases.

#### Confirming the validity of operon sizes
One of our key observations is that operons are not conserved. Is that because of our restrictive cutoff?

```{r confirm_operon_size_1}
operon_windows <- c(2, 5, 10, 20, 30, 40, 50, 75, 100, 125, 150, 175, 200, 225, 250, 500, 1000)
operon_window_factor <- lapply(operon_windows, function(x) paste0("cutoff_", x)) |> unlist()
operon_window_factor <- factor(operon_window_factor, levels=operon_window_factor)

operons_diff_sizes <- sapply(c("Oki", "Osa", "Bar"), function(sp) {
  o <- lapply(operon_windows, function(size) {
    genes[[sp]] |> OikScrambling:::calcOperons(window = size) |> suppressWarnings()
  }) |> SimpleList()
  names(o) <- operon_window_factor
  o
}) |> SimpleList()
names(operons_diff_sizes) <- c("Oki", "Osa", "Bar")

# How many operons do we get per species at these cutoffs?
operons_diff_sizes_df <- rbind(
  lapply(operons_diff_sizes$Oki, function(x) length(x) ) |> as.data.frame() |> t() |> as.data.frame() |> tibble::rownames_to_column() |> dplyr::rename(count=V1, cutoff=rowname) |> dplyr::mutate(species="Okinawa"),
  lapply(operons_diff_sizes$Osa, function(x) length(x) ) |> as.data.frame() |> t() |> as.data.frame() |> tibble::rownames_to_column() |> dplyr::rename(count=V1, cutoff=rowname) |> dplyr::mutate(species="Osaka"),
  lapply(operons_diff_sizes$Bar, function(x) length(x) ) |> as.data.frame() |> t() |> as.data.frame() |> tibble::rownames_to_column() |> dplyr::rename(count=V1, cutoff=rowname) |> dplyr::mutate(species="Barcelona") 
)
ggplot(operons_diff_sizes_df) + aes(x=factor(cutoff, levels=operon_window_factor), y=count, fill=species) + geom_bar(stat='identity') + facet_wrap(~species, ncol=1) + ggtitle("Operons per species vs. distance cutoffs") + xlab('Distance cutoff') + theme(axis.text.x = element_text(angle = 90))
```

With these operon sets confirmed, check whether they are indeed equivalent between species. First, process the orthogroups into a manageable format.

```{r confirm_operon_size_2}
pho <- read.delim(system.file("extdata/OrthoFinder/N19.tsv", package="BreakpointsData"))
pho <- pho[,!apply(pho, 2, function(d) all(is.na(d)))]
colnames(pho) <- c('HOG', 'OG', 'GTPC', 'Aom', 'Bar', 'Kum', 'Oki', 'Osa', 'Nor')

of_to_list <- function(of_ids, gene_id_separator='\\.', gene_id_field=2){
  of_list <- strsplit(of_ids, ', ')
  lapply(of_list, function(hog) {
    if(length(hog)==0){ 
      return(NA)
    } else {
      r <- lapply(hog, function(h) unlist(strsplit(h, gene_id_separator))[gene_id_field]) |> unlist()
    }
  })
}
of_to_list(pho$Aom)

pho$Aom <- of_to_list(pho$Aom, gene_id_field = 2)
pho$Bar <- of_to_list(pho$Bar, gene_id_field = 2)
pho$Kum <- of_to_list(pho$Kum, gene_id_field = 2)
pho$Oki <- of_to_list(pho$Oki, gene_id_field = 3)
pho$Osa <- of_to_list(pho$Osa, gene_id_field = 3)
pho$Nor <- of_to_list(pho$Nor, gene_id_field = 2)
```

Given a `GBreaks` relating one-to-ones between species, calculate how many genes per operon are equivalent, then plot these as Venn diagrams.

This section uses two key functions, `gene_equivalence` and `operon_equivalence`.
* `gene_equivalence`: Input is the sanitised `data.frame` of the phylogenetic hierarchical orthogroups produced by OrthoFinder (named `pho` above), and one gene identifier. It checks whether this identifier has an equivalent gene within the orthogroups according to the `criterion` argument, returning `TRUE` or `FALSE`. There are two options for equivalence, `one_to_one` (strict) or `same_hierarchical_orthogroup` (slightly more permissive), or `same_orthogroup` (extremely permissive).
* `operon_equivalence`: Input is an `orthoPair` `GBreaks` object, and two sets of operons (one for the query, one for the target). It checks every operon longer than `min_size` in `sp1` for an equivalent operon in `sp2` according to both `single_gene_criterion` and `operon_criterion`. Arguments to `operon_criterion` can be either `exact` (every gene in the operon is in an operon of the same size in the other species), `drop_1` (operon considered equivalent if there is a match minus one gene), or `drop_2` (considered equivalent if there is a match minus two genes). 
** `drop_1` explanation: There are two ways that we can consider operons equivalent by dropping 1 gene from them. The first is `drop_location`=`"ends"`. If this is true, then all of the genes in one species' operon are equivalent to the second species' operon after removing either 1 gene from the beginning (`FALSE TRUE TRUE ...`), or 1 gene from the end (`...TRUE TRUE FALSE`). The second possibility is when a gene can be inserted in the middle of an operon. In this author's opinion, that should count as breaking an operon (`...TRUE FALSE TRUE...`). However, it is included here using `drop_location`=`"any"`.

```{r confirm_operon_size_3}
gene_equivalence <- function(pho, target_gene, target_sp, query_sp, criterion="one_to_one"){
  equivalence <- FALSE
  # If target gene not in orthogroup table, it is species-specific and therefore FALSE
  if(target_gene %in% unlist(pho[[target_sp]])) {
    matching_target_index <- lapply(pho[[target_sp]], function(x) target_gene %in% x) |> unlist()
    target_hog <- pho[[target_sp]][matching_target_index] |> unlist()
    query_hog  <- pho[[query_sp]][matching_target_index]  |> unlist()
    if(criterion=="one_to_one"){
      # A HOG entry can be either NA or a list of gene IDs as processed above.
      # Check if NA and check the length.
      if(!all(is.na(target_hog)) && !all(is.na(query_hog)) && length(target_hog)==1 && length(query_hog)==1){
        equivalence <- TRUE
      }
    } else if(criterion=="same_hierarchical_orthogroup") {
      if(!all(is.na(target_hog)) && !all(is.na(query_hog)) && length(target_hog)>=1 && length(query_hog)>=1) {
        equivalence <- TRUE
      }
    } else if (criterion=="same_orthogroup"){
      if(!all(is.na(target_hog)) && length(target_hog)>=1) {
        target_og <- pho[["OG"]][matching_target_index]
        query_sp_in_target_og <- pho[[query_sp]][pho$OG == target_og]
        # If ANY sequence of the query species is within the same orthogroup, it is equivalent.
        any_query_sp_in_target_og <- any(unlist(lapply(query_sp_in_target_og, function(x) !is.na(x) )))
        if(any_query_sp_in_target_og){
          equivalence <- TRUE
        }
      }
    }
  }
  equivalence
}
# 1-to-1s
(pho[pho$Oki == "g16808",]) # Single-copy gene
gene_equivalence(pho, target_sp="Oki", query_sp="Osa", target_gene="g16808")
(pho[pho$Oki == "g10565",]) # Non-PHO gene
gene_equivalence(pho, target_sp="Oki", query_sp="Osa", target_gene="g10565")
(pho[pho$Oki == "g9611",]) # Non-single-copy gene
gene_equivalence(pho, target_sp="Oki", query_sp="Osa", target_gene="g9611")
# Hierarchical groups
(pho[pho$Oki == "g16808",]) # Single-copy gene
gene_equivalence(pho, target_sp="Oki", query_sp="Osa", target_gene="g16808", criterion="same_hierarchical_orthogroup")
(pho[pho$Oki == "g10565",]) # Non-PHO gene
gene_equivalence(pho, target_sp="Oki", query_sp="Osa", target_gene="g10565", criterion="same_hierarchical_orthogroup")
(pho[pho$Oki == "g9611",]) # Non-single-copy gene
gene_equivalence(pho, target_sp="Oki", query_sp="Osa", target_gene="g9611", criterion="same_hierarchical_orthogroup")
# Orthogroups
(pho[pho$Oki == "g10223",]) # Big orthogroup with many HOGs
(pho[pho$OG  == "OG0000000",])
gene_equivalence(pho, target_sp="Oki", query_sp="Osa", target_gene="g10223", criterion="same_hierarchical_orthogroup")
gene_equivalence(pho, target_sp="Oki", query_sp="Osa", target_gene="g10223", criterion="same_orthogroup")
# Identifying cases with species lacking an orthogroup
# as.data.frame(table(pho$OG)) |> dplyr::filter(Freq==1) -> orphan_ogs
# pho[pho$OG %in% orphan_og$Var1,] |> View()
# Seems to be missing in Osaka...
gene_equivalence(pho, target_sp="Oki", query_sp="Osa", target_gene="g7782", criterion="same_orthogroup")
# ...but exists in Barcelona.
gene_equivalence(pho, target_sp="Oki", query_sp="Bar", target_gene="g7782", criterion="same_orthogroup")

# A function to do the above, but instead return the list of query genome gene IDs.
# So that we can check which operons those genes are in later.
# It has a somewhat punny name. Sorry, I can't help myself.
gene_equivalents <- function(pho, target_gene, target_sp, query_sp, criterion="one_to_one"){
  equivalents <- NA
  if(target_gene %in% unlist(pho[[target_sp]])) {
    matching_target_index <- lapply(pho[[target_sp]], function(x) target_gene %in% x) |> unlist()
    target_hog <- pho[[target_sp]][matching_target_index] |> unlist()
    query_hog  <- pho[[query_sp]][matching_target_index]  |> unlist()
    if(criterion=="one_to_one"){
      if(!all(is.na(target_hog)) && !all(is.na(query_hog)) && length(target_hog)==1 && length(query_hog)==1){
        equivalents <- query_hog
      }
    } else if(criterion=="same_hierarchical_orthogroup") {
      if(!all(is.na(target_hog)) && !all(is.na(query_hog)) && length(target_hog)>=1 && length(query_hog)>=1) {
        equivalents <- query_hog
      }
    } else if (criterion=="same_orthogroup"){
      if(!all(is.na(target_hog)) && length(target_hog)>=1) {
        target_og <- pho[["OG"]][matching_target_index]
        query_sp_in_target_og <- pho[[query_sp]][pho$OG == target_og]
        any_query_sp_in_target_og <- any(unlist(lapply(query_sp_in_target_og, function(x) !is.na(x) )))
        if(any_query_sp_in_target_og){
          equivalents <- query_sp_in_target_og |> unlist() |> na.omit()
        }
      }
    }
  }
  equivalents
}
# 1-to-1s
(pho[pho$Oki == "g16808",]) # Single-copy gene
gene_equivalents(pho, target_sp="Oki", query_sp="Osa", target_gene="g16808")
(pho[pho$Oki == "g10565",]) # Non-PHO gene
gene_equivalence(pho, target_sp="Oki", query_sp="Osa", target_gene="g10565")
(pho[pho$Oki == "g9611",]) # Non-single-copy gene
gene_equivalence(pho, target_sp="Oki", query_sp="Osa", target_gene="g9611")
# Hierarchical groups
(pho[pho$Oki == "g16808",]) # Single-copy gene
gene_equivalents(pho, target_sp="Oki", query_sp="Osa", target_gene="g16808", criterion="same_hierarchical_orthogroup")
(pho[pho$Oki == "g10565",]) # Non-PHO gene
gene_equivalents(pho, target_sp="Oki", query_sp="Osa", target_gene="g10565", criterion="same_hierarchical_orthogroup")
(pho[pho$Oki == "g9611",]) # Non-single-copy gene
gene_equivalents(pho, target_sp="Oki", query_sp="Osa", target_gene="g9611", criterion="same_hierarchical_orthogroup")
# Orthogroups
(pho[pho$Oki == "g10223",]) # Big orthogroup with many HOGs
(pho[pho$OG  == "OG0000000",])
gene_equivalents(pho, target_sp="Oki", query_sp="Osa", target_gene="g10223", criterion="same_hierarchical_orthogroup")
gene_equivalents(pho, target_sp="Oki", query_sp="Osa", target_gene="g10223", criterion="same_orthogroup")
gene_equivalents(pho, target_sp="Oki", query_sp="Osa", target_gene="g7782", criterion="same_orthogroup")
gene_equivalents(pho, target_sp="Oki", query_sp="Bar", target_gene="g7782", criterion="same_orthogroup")

# A function to quickly iterate over a list of genes and get the genes that satisfy
# gene_equivalents - i.e., genes in an operon.
gene_to_gene_equivalents <- function(pho, list_of_target_genes, target_sp, query_sp, criterion="one_to_one") {
  sapply(list_of_target_genes, function(gene) {
    gene_equivalents(pho=pho, target_gene=gene, target_sp = target_sp, query_sp=query_sp, criterion=criterion)
  })
}
# Hint: the function above by itself is sufficient to answer the question of how many 
# operons are conserved. See commented regions below.
# operons$Oki$Osa_orthologues <- mclapply(mc.cores=8, operons$Oki$gene_id, function(g) sapply(unlist(g), function(x) gene_equivalents(pho = pho, target_gene=x, target_sp = "Oki", query_sp = "Osa", criterion = "one_to_one") ) |> unlist())
# operons$Oki$Bar_orthologues <- mclapply(mc.cores=8, operons$Oki$gene_id, function(g) sapply(unlist(g), function(x) gene_equivalents(pho = pho, target_gene=x, target_sp = "Oki", query_sp = "Bar", criterion = "one_to_one") ) |> unlist())
# operons$Osa$Oki_orthologues <- mclapply(mc.cores=8, operons$Osa$gene_id, function(g) sapply(unlist(g), function(x) gene_equivalents(pho = pho, target_gene=x, target_sp = "Osa", query_sp = "Oki", criterion = "one_to_one") ) |> unlist())
# operons$Osa$Bar_orthologues <- mclapply(mc.cores=8, operons$Osa$gene_id, function(g) sapply(unlist(g), function(x) gene_equivalents(pho = pho, target_gene=x, target_sp = "Osa", query_sp = "Bar", criterion = "one_to_one") ) |> unlist())
# operons$Bar$Oki_orthologues <- mclapply(mc.cores=8, operons$Bar$gene_id, function(g) sapply(unlist(g), function(x) gene_equivalents(pho = pho, target_gene=x, target_sp = "Bar", query_sp = "Oki", criterion = "one_to_one") ) |> unlist())
# operons$Bar$Osa_orthologues <- mclapply(mc.cores=8, operons$Bar$gene_id, function(g) sapply(unlist(g), function(x) gene_equivalents(pho = pho, target_gene=x, target_sp = "Bar", query_sp = "Osa", criterion = "one_to_one") ) |> unlist())
# operons$Oki[lapply(operons$Oki$Osa_orthologues, function(x) all(!is.na(x)))|>unlist()] |> as.data.frame() |> View()
#  


# A function that tests if a specific gene in query species should be
# considered equivalent to a specific gene in target species.
gene_equivalence_test <- function(pho, target_gene, target_sp, query_gene, query_sp, criterion="one_to_one"){
  test <- FALSE
  # If target gene not in orthogroup table, it is species-specific and therefore FALSE
  if(target_gene %in% unlist(pho[[target_sp]]) && query_gene %in% unlist(pho[[query_sp]]) ) {
    matching_target_index <- lapply(pho[[target_sp]], function(x) target_gene %in% x) |> unlist() |> which()
    matching_query_index  <- lapply(pho[[query_sp]], function(x) query_gene %in% x) |> unlist() |> which()

    g_t <- pho[[target_sp]][matching_target_index] |> unlist()
    g_q <- pho[[query_sp]][matching_query_index]   |> unlist()
    if(criterion=="one_to_one") {
      if(matching_target_index == matching_query_index) {
        if(length(g_t)==1 && length(g_q)==1) {
          test <- TRUE
        }
      }
    } else if(criterion=="same_hierarchical_orthogroup"){
      if(matching_target_index == matching_query_index) {
        test <- TRUE
      }
    } else if(criterion=="same_orthogroup") {
      if(pho[["OG"]][matching_target_index] == pho[["OG"]][matching_query_index]) {
        test <- TRUE
      }
    }
  }
  test
}

# (pho[pho$Oki == "g16808",]) # Single-copy gene
gene_equivalence_test(pho=pho, target_gene = "g16808", target_sp = "Oki", query_gene="g12947", query_sp="Osa", criterion = "one_to_one")
# (pho[pho$Oki == "g10565",]) # Non-PHO gene
gene_equivalence_test(pho=pho, target_gene = "g16808", target_sp = "Oki", query_gene="g9811", query_sp="Osa", criterion = "one_to_one")
# (pho[pho$Oki == "g9611",]) # Non-single-copy gene
gene_equivalence_test(pho=pho, target_gene = "g9611", target_sp = "Oki", query_gene="g4413", query_sp="Osa", criterion = "one_to_one")
gene_equivalence_test(pho=pho, target_gene = "g9611", target_sp = "Oki", query_gene="g4413", query_sp="Osa", criterion = "same_hierarchical_orthogroup")
gene_equivalence_test(pho=pho, target_gene = "g9611", target_sp = "Oki", query_gene="g4413", query_sp="Osa", criterion = "same_orthogroup")
# (pho[pho$Oki == "g10223",]) # Big orthogroup with many HOGs
# (pho[pho$OG  == "OG0000000",])
gene_equivalence_test(pho=pho, target_gene = "g9611", target_sp = "Oki", query_gene="g10171", query_sp="Osa", criterion = "same_orthogroup")
```

With a good single-gene comparison function on hand, we expand this to compare operons. 

```{r confirm_operon_size_4}
# A couple helper functions that may be necessary
operon_of_gene <- function(id, op) {
  matching_operon <- which(lapply(op$gene_id, function(o) id %in% o) |> unlist()) |> unname()
  op[matching_operon]
}
operon_of_gene("g57", operons$Oki) 

which_operon <- function(id, op) {
  which(lapply(op$gene_id, function(o) id %in% o) |> unlist()) |> unname()
}
which_operon("g57", operons$Oki)

genes_of_operon <- function(op) {
  op$gene_id
}
operon_of_gene("g57", operons$Oki) |> genes_of_operon()
```
```{r whatever}
compare_operons <- function(op_sp1, op_sp2, operon_criterion="exact", pho, target_sp, query_sp, single_gene_criterion="one_to_one", drop_location="ends") {
  equivalent <- FALSE
  # Do a check that there are no 0-length operons first...
  if(length(op_sp1)!=0 && length(op_sp2)!=0){
    strand_op1 <- strand(op_sp1)
    strand_op2 <- strand(op_sp2)
    genes_sp1 <- op_sp1$gene_id |> unlist()
    genes_sp2 <- op_sp2$gene_id |> unlist()
    if(as.character(strand_op1) == "-") {
      genes_sp1 <- rev(genes_sp1)
    }
    if(as.character(strand_op2) == "-") {
      genes_sp2 <- rev(genes_sp2)
    }
  
    if(operon_criterion=="exact") {
      # Exact-matching operons must be the same length.
      # If the lengths differ, they can never be equivalent under "exact".
      if(!length(genes_sp1)!=length(genes_sp2)) {
        gene_checks <- lapply(1:length(genes_sp1), function(i) {
          gene_equivalence_test(pho=pho, target_gene=genes_sp1[i], target_sp=target_sp, query_gene=genes_sp2[i], query_sp=query_sp, criterion=single_gene_criterion)
        }) |> unlist()
        if(all(gene_checks)){
          equivalent <- TRUE
        }
      } 
    } else if (operon_criterion == "drop_1") {
      # The two operons can be differ in length by at most 1 gene.
        gene_checks <- lapply(1:length(genes_sp1), function(i) {
          print()
          gene_equivalence_test(pho=pho, target_gene=genes_sp1[i], target_sp=target_sp, query_gene=genes_sp2[i], query_sp=query_sp, criterion=single_gene_criterion)
      }) |> unlist()
        if(all(gene_checks)){
          equivalent <- TRUE
        } else if(drop_location=="ends") {
          drop_first <- gene_checks[2:length(gene_checks)]
          drop_last  <- gene_checks[1:length(gene_checks)-1]
          if(all(drop_first) || all(drop_last)) {
            equivalent <- TRUE
          }
        }
      }
  }
  equivalent
}
# Easy examples:
# compare_operons(pho=pho, operon_of_gene("g57", operons$Oki), operon_of_gene("g383", operons$Osa), target_sp="Oki", query_sp="Osa", single_gene_criterion = "one_to_one")
# compare_operons(pho=pho, operon_of_gene("g57", operons$Oki), operon_of_gene("g3848", operons$Osa), target_sp="Oki", query_sp="Osa", single_gene_criterion = "one_to_one")

# A probable example of a 5' missing gene in Osaka (where "drop_1" is helpful).
operon_of_gene("g1814", operons$Oki)
gene_equivalents(pho, "g1814", target_sp="Oki", query_sp="Osa")
gene_equivalents(pho, "g1815", target_sp="Oki", query_sp="Osa")
gene_equivalents(pho, "g1816", target_sp="Oki", query_sp="Osa")
gene_equivalents(pho, "g1817", target_sp="Oki", query_sp="Osa")
operon_of_gene("g1120", operons$Osa)
gene_equivalents(pho, "g1120", target_sp="Osa", query_sp="Oki")
gene_equivalents(pho, "g1119", target_sp="Osa", query_sp="Oki")
gene_equivalents(pho, "g1118", target_sp="Osa", query_sp="Oki")

subsetByOverlaps(coa$Oki_Osa, operon_of_gene("g1814", operons$Oki)) |> plotApairOfChrs()
subsetByOverlaps(coa$Oki_Osa, GRanges("chr1:6756288-7006643")) |> plotApairOfChrs()

compare_operons(pho=pho, operon_of_gene("g1814", operons$Oki), operon_of_gene("g1120", operons$Osa), target_sp="Oki", query_sp="Osa", single_gene_criterion = "one_to_one", operon_criterion = "drop_1")
# gene_equivalents(pho=pho, target_gene="g1681", target_sp="Oki", query_sp="Osa", criterion = "same_hierarchical_orthogroup")
# operon_of_gene("g181", operons$Oki)
```
```
# gene_equivalents
# The operon_equivalence function matches a set of operons in one species to a set of 
# operons in a second species.
# It checks every operon above min_size for being equivalent for a matching equivalent
# in a second species.
#
# 
# List of acceptable operon matching operations:
# 'exact'  = all genes in sp1 operon must be exactly equivalent in an operon of sp2
# 'drop_1' = all genes in either sp1 or sp2 must be in its pair, but considered equivalent if 1 is missing
#            All "drop" categories require at least one of its genes be single-gene equivalent in the
#            other species.
# 'drop_2' = all genes in either sp1 or sp2 must be in its pair, but considered equivalent if 2 are missing
operon_equivalence <- function(pho, operons_sp1, operons_sp2, target_sp=NULL, query_sp=NULL, single_gene_criterion="one_to_one", min_size=1, operon_criterion='exact'){
  # Remove operons that are too small
  operons_sp1 <- operons_sp1[operons_sp1$n>min_size]
  operons_sp2 <- operons_sp2[operons_sp2$n>min_size]
  # Split operons into GRangesLists and rename
  operon_names_sp1 <- paste0("o", 1:length(operons_sp1))
  operon_names_sp2 <- paste0("o", 1:length(operons_sp2))
  names(operons_sp1$gene_id) <- operon_names_sp1
  names(operons_sp2$gene_id) <- operon_names_sp2

  sp1_checks <- lapply(operons_sp1$gene_id, function(target_operon_genes) {
    equivalent <- FALSE
    # First check how many genes satisfy the criterion set for gene equivalence
    # across all the genes in the operon. Then decide what to do based on that.
    check_gene_equivalence <- lapply(target_operon_genes, function(target_gene){
      gene_equivalence(pho=pho, target_gene=target_gene, criterion = single_gene_criterion, target_sp=target_sp, query_sp=query_sp)
    }) |> unlist()
    
    if(operon_criterion=="exact"){
      # If all genes in the operon are satisfied with gene_equivalence,
      # then make sure they are also in an operon in sp2.
      if(all(check_gene_equivalence)) {
        # Retrieve all sp2 genes for every equivalent gene in the sp1 operon.
        # Note that, by definition, some genes have multiple equivalent
        # genes, so you have to iterate over a few things.
        gene_matches <- gene_to_gene_equivalents(pho=pho, list_of_target_genes = target_operon_genes, criterion = single_gene_criterion, target_sp=target_sp, query_sp=query_sp)
        # Remove equivalent genes of sp2 which are not in operons.
        gene_matches <- sapply(gene_matches, function(x) x[x %in% unlist(operons_sp2$gene_id)])
        # Retrieve operons for all equivalent genes from sp2.
        operons_of_matches <- lapply(gene_matches, function(target_match) {
          q_t_operons <- lapply(target_match, function(query) {
            r <- operon_of_gene(query,  op=operons_sp2) |> genes_of_operon()
            r
          })
          # For every gene, if 
          #print(q_t_operons )
         })
        #print(operons_of_matches)
        gene_matches
      }
    }
   # equivalent
  }) |> unlist()
  sp1_checks
}
#operon_equivalence(pho=pho, operons$Oki[1], operons$Osa, target_sp="Oki", query_sp="Osa", single_gene_criterion = "one_to_one", operon_criterion = "exact")
operon_equivalence(pho=pho, operons$Oki[6], operons$Osa, target_sp="Oki", query_sp="Osa", single_gene_criterion = "one_to_one", operon_criterion = "exact")
# operon_equivalence(pho=pho, operons$Oki[6], operons$Osa, target_sp="Oki", query_sp="Osa", single_gene_criterion = "same_hierarchical_orthogroup", operon_criterion = "exact")
operon_equivalence(pho=pho, operons$Oki[6], operons$Osa, target_sp="Oki", query_sp="Osa", single_gene_criterion = "same_orthogroup", operon_criterion = "exact")
```


## Accessory functions

```{r genomic_features_byType_accessory_Functions}
prepareFreqPlot <- function(gb, annot = NULL, rep = NULL, cne = NULL, tfbs = NULL, operons = NULL, win = 1000, direction = "left", withGenes=c("yes", "no", "only")) {
  withGenes <- match.arg(withGenes)
  l <- list()
  # Note that get_bps(direction="mid") is probably not what you think.
  if(direction == "mid") {
    gb <- resize(gb, 1, "center")
    direction <- "left"
  }
  if (!is.null(annot)) {
    if (withGenes %in% c("yes", "only")) {
      l$genes  <- feature_coverage(gb,     genes(annot),         win = win, lab = "genes",  direction = direction)
    }
    if (withGenes %in% c("yes", "no")) {
      l$intron <- feature_coverage(gb,     intronicParts(annot), win = win, lab = "intron", direction = direction)
      l$exon   <- feature_coverage(gb,     exonicParts(annot),   win = win, lab = "exon",   direction = direction)
      #reorder
      newOrder <- order(rowSums(l$intron@image))
      l$intron@image <- l$intron@image[newOrder,]
      l$exon@image   <- l$exon@image[newOrder,]
    }
  }
  if (!is.null(operons))
    l$operons<-feature_coverage(gb,    operons,              win = win, lab = "operons",direction = direction)
  if (!is.null(rep))
    l$reps   <- feature_coverage(gb,   rep,                  win = win, lab = "repeats",direction = direction)
  if (!is.null(cne))
    l$CNE   <- feature_coverage(gb,    cne,                  win = win, lab = "CNE",    direction = direction)
  if (!is.null(tfbs))
    l$tfbs  <- feature_coverage(gb,    tfbs,                 win = win, lab = "TFBS",   direction = direction)
  l
}

#' Prepare a long tibble for frequency plotting
#' 
#' Loop over a list of `Heatmap` objects to produce a long tibble that can be
#' used with ggplot to plot frequency of each feature included in the list.
#'
#' @param x A list of `Heatmap` objects
#' @param desc An additional description (character string)
#'
#' @return A long `tibble` that is the vertical concatenation of all tibbles
#' produced for each element of the list `x`.  Its `what` column is made from
#' the names of the heatmaps in the list, and its `desc` column is made from the
#' `desc` arguments.  The other columns (`val`, `freq` and `pos`) originate from
#' the `Heatmap_to_freq_tibble` function call.
prepareGGFreqPlot <- function(x, desc = NULL) {
  l <- lapply(names(x), \(name){
    tib <- Heatmap_to_freq_tibble(x[[name]], desc = desc)
    tib$what <- name
    tib
  })
   do.call(rbind, l)
}

#' Heatmap to long tibble for ggplot
#' 
#' Coerce a Heatmap object into a \dQuote{long} tibble with one value per
#' position, either as raw counts or as a frequency.
#' 
#' The tibble can then be passed to ggplot.  The `image` matrix of the `Heatmap`
#' object has one column per nucleotide position and it is assumed that its
#' central column is for position zero.
#'
#' @param h a `Heatmap` object
#'
#' @return a `tibble` with `val`, `freq` and `pos` columns
Heatmap_to_freq_tibble <- function(h, desc = NULL) {
  val  <- colSums(h@image)
  tibble::tibble( val  = val
                , freq = val / nrow(h@image)
                , pos  = 1:ncol(h@image) - round(ncol(h@image)) / 2
                , desc = desc)
}

```

## Centering on left-aligned boundaries.

Breakpoints are between mapped regions.  If the unmapped region is broad we have
little information where the breakpoint originally was.  We set arbitrarly the
breakpoints to the left-side (end-side) coordinate of genomic regions.

Mapped regions can consist of multiple colinear aligned regions, or be a single
uncoalesced aligned region.  We will see that they have different properties.

Our annotations is mostly made of coding exons, so the features _exons_ and
_cds_ have very similar profiles.  Therefore we keep only _exons_ in the rest of
the analysis.

Positive coordinates (and zero) start in selected regions and negative
coordinates start outside these regions.  As we move further from 0, we can not
guarantee that the statement is still true because some regions have a width
narrower than the plot window.  This is why the values tend to equilibrate
away from the boundaries.

Aligned regions are enriched in exons and depleted in introns.

Close to the breakpoint of uncoalesced mapped regions, exon annotations are
depleted, which makes sense, as exons are usually mapable.  Within the mapped
regions, frequency of introns and exons are comparable.  In contrary, within
coalesced mapped regions, the exon annotations are over-represented.

```{r genomic_features_byType, fig.width=15, fig.height=5, dev=c("svg", "pdf", "png"), fig.ext=c("svg", "pdf", "png")}
#' Pre-compute feature frequencies in fixed windows
#'
#' @param target 3-letter name of one Oik genome
#' @param query 3-letter name of another Oik genome
#' @param perpareFreqPlot a `perpareFreqPlot` function
#' @param reps `SimpleList` of `GRanges` of repeat regions
#' @param CE `SimpleList` of `GRanges` with conserved non-coding elements
#' @param tfbs `SimpleList` of `GRanges` of putative transcription factor binding sites
#' @param operons `SimpleList` of `GRanges` of operon regions.
#' @param direction Where to center the windows (`left`, `right` or `mid`)
#'
#' @return A `SimpleList` of Heatmap objects
computePlotData <- function(target, query, annots=NULL, reps=NULL, CE=NULL, tfbs=NULL, operons=NULL, direction="left") {
  pair <- paste(target, query, sep = "_")
  current_GB_aln_nonCoa     <- gbs[[pair]][   gbs[[pair]]$nonCoa]
  current_GB_aln_coa        <- gbs[[pair]][ ! gbs[[pair]]$nonCoa]
  current_GB_syn_block      <- coa[[pair]][ ! coa[[pair]]$nonCoa]
  # We do not use unal, because it overlaps with bri
  current_GB_unmap          <- unmap[[pair]]
  current_GB_bri        <- bri[[pair]]
  
  targetGenome <- unique(genome(gbs[[pair]]))
  
  prepareFreqPlot_default <- \(x) prepareFreqPlot(x, annot = annots[[target]], rep = reps[[targetGenome]], cne = CE[[pair]], tfbs = tfbs, operons = operons[[target]], direction = direction)
  
  hmList <- SimpleList()
  hmList$aln_nonCoa <- prepareFreqPlot_default(current_GB_aln_nonCoa)
  hmList$aln_coa    <- prepareFreqPlot_default(current_GB_aln_coa)
  hmList$syn_block  <- prepareFreqPlot_default(current_GB_syn_block)
  hmList$unmap      <- prepareFreqPlot_default(current_GB_unmap)
  hmList$bri        <- prepareFreqPlot_default(current_GB_bri)
  hmList
}

hmList_to_plot_noncoding <- computePlotData("Oki", "Osa", reps = reps, CE = ces$ce__50__48)
hmList_to_plot_coding    <- computePlotData("Oki", "Osa", annots = annots, operons = operons)

list_of_heatmaps_to_long_tibble <- function(hmList_to_plot, desc = NULL) {
  tib <-rbind(
    hmList_to_plot$aln_nonCoa  |> prepareGGFreqPlot("01_isolated_alns"),
    hmList_to_plot$unmap       |> prepareGGFreqPlot("02_unmapped"),
    hmList_to_plot$syn_block   |> prepareGGFreqPlot("03_colinear_reg"),
    hmList_to_plot$bri         |> prepareGGFreqPlot("04_bridge"),
    hmList_to_plot$aln_coa     |> prepareGGFreqPlot("05_colinear_alns")
  )
  tib$desc2 <- desc
  tib
}

rbind(
  list_of_heatmaps_to_long_tibble(hmList_to_plot_noncoding, "noncoding"),
  list_of_heatmaps_to_long_tibble(hmList_to_plot_coding, "coding")
) |> ggplot() +
  aes(pos, freq, col = what) +
  geom_line() +
  facet_wrap(~desc2 + desc, nrow = 2) +
  theme_bw() +
  ggtitle("Aligned on regions left boundary. CNE is 50/48.  Okinawa - Osaka")
```

Most of the narrow-width aligned regions did not coalesce.  We use this
as a classifier instead of an arbitrary width cutoff.  See
`vignette("RegionWidths", package = "OikScrambling")` for details.

#### Simplified version

With only 2 panels, for unmapped–aligned and bridge–aligned, we display
almost all the information present in the 5-panel version above.

```{r genomic_features_byType_2, fig.width=6, fig.height=8, dev=c("svg", "pdf", "png"), fig.ext=c("svg", "pdf", "png")}
computePlotData_simplified <- function(target, query, annots=NULL, reps=NULL, CE=NULL, tfbs=NULL, operons=NULL, direction="left", withGenes = c("yes", "no", "only")) {
  withGenes <- match.arg(withGenes)
  pair <- paste(target, query, sep = "_")
  current_GB_brk <- unmap[[pair]] |> subsetByOverlaps(coa[[pair]][!coa[[pair]]$nonCoa] + 1) # The unmapped region flanking colinear regions
  current_GB_bri <- bri[[pair]]
  
  targetGenome <- unique(genome(gbs[[pair]]))
  
  prepareFreqPlot_default <- \(x) prepareFreqPlot(x, annot = annots[[target]], rep = reps[[targetGenome]], cne = CE[[pair]], tfbs = tfbs, operons = operons[[target]], direction = direction, withGenes = withGenes)
  
  hmList <- SimpleList()
  hmList$brk <- prepareFreqPlot_default(current_GB_brk)
  hmList$bri <- prepareFreqPlot_default(current_GB_bri)
  hmList
}

hmList_to_plot_noncoding    <- computePlotData_simplified("Oki", "Osa", reps = reps, CE = ces$ce__50__48, direction = "right")
hmList_to_plot_genesoperons <- computePlotData_simplified("Oki", "Osa", annots = annots, operons = operons, direction = "right", withGenes = "only")
hmList_to_plot_exonintron   <- computePlotData_simplified("Oki", "Osa", annots = annots, direction = "right", withGenes = "no")

list_of_heatmaps_to_long_tibble <- function(hmList_to_plot, desc = NULL) {
  tib <-rbind(
    hmList_to_plot$brk         |> prepareGGFreqPlot("01_break"),
    hmList_to_plot$bri         |> prepareGGFreqPlot("02_bridge")
  )
  tib$desc2 <- desc
  tib
}

rbind(
  list_of_heatmaps_to_long_tibble(hmList_to_plot_noncoding,    "noncoding"),
  list_of_heatmaps_to_long_tibble(hmList_to_plot_genesoperons, "genes and operons"),
  list_of_heatmaps_to_long_tibble(hmList_to_plot_exonintron,   "exons and introns")
) |> ggplot() +
  aes(pos, freq, col = what) +
  geom_line() +
  facet_wrap(~desc2 + desc, nrow = 3) +
  theme_bw() +
  ggtitle("Aligned on regions left boundary. CNE is 50/48.  Okinawa - Osaka")
```

### Bridge regions classified by width.

Short bridge regions contain small introns.  Long bridge regions contain repeats,
which may be in introns.

```{r bridge_width_features}
computePlotData_for_bridge <- function(target, query, annots=NULL, reps=NULL, CE=NULL, tfbs=NULL, operons=NULL, direction="left") {
  pair <- paste(target, query, sep = "_")

  current_GB_bri       <- bri[[pair]]
  current_GB_bri_small <- current_GB_bri[width(current_GB_bri) <  150]
  current_GB_bri_long  <- current_GB_bri[width(current_GB_bri) >= 150]

  targetGenome <- unique(genome(gbs[[pair]]))
  
  prepareFreqPlot_default <- \(x) prepareFreqPlot(x, annot = annots[[target]], rep = reps[[targetGenome]], cne = CE[[pair]], tfbs = tfbs, operons = operons[[target]], direction = direction)
  
  hmList <- SimpleList()
  hmList$bri       <- prepareFreqPlot_default(current_GB_bri)
  hmList$bri_small <- prepareFreqPlot_default(current_GB_bri_small)
  hmList$bri_long  <- prepareFreqPlot_default(current_GB_bri_long)
  hmList
}

hmList_to_plot_noncoding <- computePlotData_for_bridge("Oki", "Osa", reps = reps, CE = ces$ce__50__48)
hmList_to_plot_coding    <- computePlotData_for_bridge("Oki", "Osa", annots = annots, operons = operons)

list_of_heatmaps_to_long_tibble <- function(hmList_to_plot, desc = NULL) {
  tib <-rbind(
    hmList_to_plot$bri         |> prepareGGFreqPlot("01_bridge"),
    hmList_to_plot$bri_small   |> prepareGGFreqPlot("02_bridge_small"),
    hmList_to_plot$bri_long    |> prepareGGFreqPlot("02_bridge_long")
  )
  tib$desc2 <- desc
  tib
}

rbind(
  list_of_heatmaps_to_long_tibble(hmList_to_plot_noncoding, "noncoding"),
  list_of_heatmaps_to_long_tibble(hmList_to_plot_coding, "coding")
) |> ggplot() +
  aes(pos, freq, col = what) +
  geom_line() +
  facet_wrap(~desc2 + desc, nrow = 2) +
  theme_bw() +
  ggtitle("Aligned on regions left boundary. CNE is 50/48.  Okinawa - Osaka")
```

### Aligning on center instead of border.

```{r genomic_features_byType.centered, fig.width=15, fig.height=5, dev=c("svg", "pdf", "png"), fig.ext=c("svg", "pdf", "png")}
hmList_to_plot.centered <- computePlotData("Oki", "Osa", annots = annots, CE = ces$ce__50__48, tfbs =  tfbs, operons = operons, direction = "mid")

(p_boundary <- rbind(
  hmList_to_plot.centered$aln_nonCoa  |> prepareGGFreqPlot("01_isolated_alns"),
  hmList_to_plot.centered$unmap       |> prepareGGFreqPlot("02_unmapped"),
  hmList_to_plot.centered$syn_block   |> prepareGGFreqPlot("03_colinear_reg"),
  hmList_to_plot.centered$bri         |> prepareGGFreqPlot("04_bridge"),
  hmList_to_plot.centered$aln_coa     |> prepareGGFreqPlot("05_colinear_alns")

)|> ggplot() +
  aes(pos, freq, col = what) +
  geom_line() +
  facet_wrap(~desc, nrow = 1) +
  theme_bw() +
  ggtitle("Aligned on center of regions. CNE is 50/48.  Okinawa - Osaka"))
```

### Splice junctions

```{r splice_junctions}
rbind(
  feature_coverage(gbs$Oki_Osa[gbs$Oki_Osa$nonCoa], intronicParts(annots$Oki) |> resize(1), window = 1000, lab = "splicejunctions", dir = "left") |>
    Heatmap_to_freq_tibble("01_isolated"),
  feature_coverage(unal$Oki_Osa[unal$Oki_Osa$nonCoa], intronicParts(annots$Oki) |> resize(1), window = 1000, lab = "splicejunctions", dir = "left") |>
    Heatmap_to_freq_tibble("02_unaligned"),
  feature_coverage(coa$Oki_Osa[!coa$Oki_Osa$nonCoa], intronicParts(annots$Oki) |> resize(1), window = 1000, lab = "splicejunctions", dir = "left") |>
    Heatmap_to_freq_tibble("03_colinear_reg"),
  feature_coverage(bri$Oki_Osa, intronicParts(annots$Oki) |> resize(1), window = 1000, lab = "splicejunctions", dir = "left") |>
    Heatmap_to_freq_tibble("04_bridge") 
) |> ggplot() + aes(pos, freq, col = desc) + geom_line()
```

### PWM

The PWM motif, which is rare in comparison to the other features, follows
a profile that bears resemblance to the repeat profile.

```{r genomic_pwm_bpByWidth}
gadems.invLeftGap <- readRDS("gadems.invLeftGap.Rda")
pwm <- gadems.invLeftGap$Oki_Osa[[1]]
pwm@consensus
# pwmHits <- matchPWM(pwm = sapply(pwm@alignList, \(x) x@seq) |> as("DNAStringSet") |> PWM(), genomes$Oki) # Gives different scores...
pwmHits <- matchPWM(pwm = rGADEM::getPWM(pwm), genomes$OKI2018.I69) |> suppressWarnings()
# Suppressing warnings like:
# Warning messages:
# 1: In .Call2("XString_match_PWM", pwm, subject, min.score, count.only,  :
#   'subject' contains letters not in [ACGT] ==> assigned weight 0 to them
# 
# plotHeatmapMeta(list(feature_coverage(current_GB_wide,   pwmHits, win = 1e3, lab = "wide",    direction = "left")))
# plotHeatmapMeta(list(feature_coverage(current_GB_narrow, pwmHits, win = 1e3, lab = "narrow",  direction = "left")))
```

### Question

in `vignette("ColinearityInterruptors", package = "OikScrambling")`, we saw
that some uncoalesced regions map uniquely and are well conserved across
genomes.  What are they... enhancers ?

## Gene feature coverage around PWM hits

Let's look at coverage around PWM hits of the AAGCsGCwwmkCGrCTTyn motif

```{r genomic_features_pwmHits}
current_GB <- pwmHits

hmList_PWM_OKI <- list()
hmList_PWM_OKI$genes     <- feature_coverage(current_GB, genes(annots$Oki),                         win = 2000, lab = "Oki genes", direction = "left")
hmList_PWM_OKI$promoters <- feature_coverage(current_GB, promoters(annots$Oki),                     win = 2000, lab = "Oki promoters", direction = "left")
hmList_PWM_OKI$exons     <- feature_coverage(current_GB, exonicParts(annots$Oki),                   win = 2000, lab = "Oki exons", direction = "left")
hmList_PWM_OKI$introns   <- feature_coverage(current_GB, intronicParts(annots$Oki),                 win = 2000, lab = "Oki introns", direction = "left")
hmList_PWM_OKI$cds       <- feature_coverage(current_GB, cds(annots$Oki),                           win = 2000, lab = "Oki cds", direction = "left")

plotHeatmapMeta(hmList_PWM_OKI[c("genes", "exons", "cds")]) # Show they look alike.  We keep "exons"
plotHeatmapMeta(hmList_PWM_OKI[c("promoters", "exons", "introns")])
```

They are enriched in introns...

```{r genomic_features3}
# 
# # Sandbox to make sanity checks.
# 
# a <- coa$Oki_Osa
# b <- unlist(fiveUTRsByTranscript(annots$Oki))
# 
# hm_a <- feature_coverage(a, b, win = 2000, lab = "All ranges", direction = "left")
# hm_b <- feature_coverage(subsetByOverlaps(a,  b), b, win = 2000, lab = "Subsetted ranges", direction = "left")
# 
# plotHeatmapMeta(list(hm_a))
# plotHeatmapMeta(list(hm_b))
```

## Breakpoint coverage around PWM hits

TODO: triplecheck `feature_coverage`, it is old…

```{r genomic_features_pwmHits2}
current_GB <- pwmHits

hmList_PWM_OKI$gbOsa     <- feature_coverage(current_GB, gbs$Oki_Osa,  win = 5000, lab = "Oki-Osa", direction = "left")
hmList_PWM_OKI$gbBar     <- feature_coverage(current_GB, gbs$Oki_Bar,  win = 5000, lab = "Oki-Bar", direction = "left")
hmList_PWM_OKI$gbKum     <- feature_coverage(current_GB, gbs$Oki_Kum,  win = 5000, lab = "Oki-Kum", direction = "left")

plotHeatmapMeta(hmList_PWM_OKI[c("gbOsa", "gbBar", "gbKum")])

hmList_PWM_OKI$coOsa     <- feature_coverage(current_GB, coa$Oki_Osa,  win = 5000, lab = "Oki-Osa", direction = "left")
hmList_PWM_OKI$coBar     <- feature_coverage(current_GB, coa$Oki_Bar,  win = 5000, lab = "Oki-Bar", direction = "left")
hmList_PWM_OKI$coKum     <- feature_coverage(current_GB, coa$Oki_Kum,  win = 5000, lab = "Oki-Kum", direction = "left")

plotHeatmapMeta(hmList_PWM_OKI[c("coOsa", "coBar", "coKum")])
```

## Okinawa genome coverage

As previously discussed, low coverage over an alignment stop could lower the likelihood of it being considered as a breakpoint. We have per-base coverage depth information for the Okinawan genome (`Oki_cov_pb`). However, the coverage of this particular assembly is quite good. In fact, we can investigate the coverge over alignment stops from the information obtained using `master_bp_analysis`. 

```{r echo=T, message=F, warning=F}
# fin_Oki <- fin_gr_O_Oki[[2]]
# min_cov <- min(min(fin_Oki$left_cov_pb), min(fin_Oki$right_cov_pb)) # minimum coverage over an alignment stop
# min_cov
# length(fin_Oki[fin_Oki$left_cov_pb == min_cov]) + length(fin_Oki[fin_Oki$right_cov_pb == min_cov]) # how many of the minimum coverage is observed
# length(fin_Oki[fin_Oki$left_cov_pb <= 50]) + length(fin_Oki[fin_Oki$right_cov_pb <= 50]) # how many alignment stops have a coverage of less than or euqal to 50

```

We may choose to kick out the one alignment stop for which there is no coverage. However, only 15 out of 34572 alignment stops have a coverage of less than or equal to 50, meaning that it would be hard to exclude more than just a few alignment stops using coverage information for breakpoint analysis. 

# Operons and genes

Do alignments often cross gene or operon boundaries ?

## Operons boundaries

Operon boundaries tend to coincide with alignment boundaries and the largest
shift in frequency is for colinear alignments.  Baseline frequency of colinear
regions is higher than 0.6 on both side of operon boundaries.

```{r operons}
feature_coverage_on_operons <- {
  function(feat, desc)
    feature_coverage(operons$Oki, feat, window = 1000, lab = "", dir = "left") |> Heatmap_to_freq_tibble(desc)
}

pairname <- "Oki_Bar"
pairname <- "Oki_Osa"

p_op_scrambling <- rbind(
  feature_coverage_on_operons(gbs[[pairname]][gbs[[pairname]]$nonCoa], "01_isolated"),
  feature_coverage_on_operons(unal[[pairname]][unal[[pairname]]$nonCoa], "02_unaligned"),
  feature_coverage_on_operons(gbs[[pairname]][!gbs[[pairname]]$nonCoa], "03_colinear_aln"),
  #feature_coverage_on_operons(subsetByOverlaps(gbs$Oki_Osa[!gbs$Oki_Osa$nonCoa], granges(coa$Oki_Osa[!coa$Oki_Osa$nonCoa] - 1),type = "within"), "03b_colinear_aln_intern"),
  #feature_coverage_on_operons(subsetByOverlaps(gbs$Oki_Osa[!gbs$Oki_Osa$nonCoa], unal$Oki_Osa[unal$Oki_Osa$nonCoa] + 1), "03c_colinear_aln_extern"),

  feature_coverage_on_operons(bri[[pairname]], "04_bridge"),
  feature_coverage_on_operons(coa[[pairname]][!coa[[pairname]]$nonCoa], "05_colinear_reg")
) |> ggplot() + aes(pos, freq, col = desc) + geom_line() + ggtitle("operons", subtitle = "n = 2017") + theme_bw()
```

## Gene boundaries inside operons

```{r genes}
# Shrinking operons of 1 base and requesting full overlap
# in order to exclude the genes at the boundaries.
genes_inside_operons  <- subsetByOverlaps(genes(annots$Oki),           operons$Oki -1, type = "within")
genes_outside_operons <- subsetByOverlaps(genes(annots$Oki), cleanGaps(operons$Oki),   type = "within")

feature_coverage_on_genes <- {
  function(feat, desc)
    feature_coverage(genes_inside_operons, feat, window = 1000, lab = "", dir = "left") |> Heatmap_to_freq_tibble(desc)
}

p_gene_int_scrambling <- rbind(
  feature_coverage_on_genes(gbs$Oki_Osa[gbs$Oki_Osa$nonCoa], "01_isolated"),
  feature_coverage_on_genes(unal$Oki_Osa[unal$Oki_Osa$nonCoa], "02_unmapped"),
  feature_coverage_on_genes(gbs$Oki_Osa[!gbs$Oki_Osa$nonCoa], "03_colinear_aln"),
  feature_coverage_on_genes(bri$Oki_Osa, "04_bridge"),
  feature_coverage_on_genes(coa$Oki_Osa[!coa$Oki_Osa$nonCoa], "05_colinear_reg")
) |> ggplot() + aes(pos, freq, col = desc) + geom_line() + ggtitle("genes_internal_to_operons", subtitle = "n = 1348") + theme_bw()

feature_coverage_on_genes_outside <- {
  function(feat, desc)
    feature_coverage(genes_outside_operons, feat, window = 1000, lab = "", dir = "left") |> Heatmap_to_freq_tibble(desc)
}

p_gene_ext_scrambling <- rbind(
  feature_coverage_on_genes_outside(gbs$Oki_Osa[gbs$Oki_Osa$nonCoa], "01_isolated"),
  feature_coverage_on_genes_outside(unal$Oki_Osa[unal$Oki_Osa$nonCoa], "02_unmapped"),
  feature_coverage_on_genes_outside(gbs$Oki_Osa[!gbs$Oki_Osa$nonCoa], "03_colinear_aln"),
  feature_coverage_on_genes_outside(bri$Oki_Osa, "04_bridge"),
  feature_coverage_on_genes_outside(coa$Oki_Osa[!coa$Oki_Osa$nonCoa], "05_colinear_reg")
) |> ggplot() + aes(pos, freq, col = desc) + geom_line() + ggtitle("genes_outside_operons", subtitle = "n = 11688") + theme_bw()
```

## Summary plot

```{r operon_scrambling, fig.width=15, fig.height=4, dev=c("svg", "pdf", "png"), fig.ext=c("svg", "pdf", "png")}
p_gene_ext_scrambling + p_op_scrambling + p_gene_int_scrambling + plot_layout(nrow = 1, guides = 'collect')
```

## Operon conservation

```{r operon_conservation}
# Distribution of operon lengths
operons$Oki$n |> table()

# An operon is scrambled if it overlaps with an unaligned noncoalesced (= unmapped) region
scrambled_operons     <- subsetByOverlaps(operons$Oki, unal$Oki_Osa[unal$Oki_Osa$nonCoa])
not_scrambled_operons <- operons$Oki[! operons$Oki %in% scrambled_operons ]

# Distribution of operon lengths (scrambled)
scrambled_operons$n     |> table()
not_scrambled_operons$n |> table()

# Example of long scrambled operons
scrambled_operons[scrambled_operons$n > 5]
```

In comparison: genes

```{r gene_conservation_Oki_Osa}
all_genes <- genes(annots$Oki)
scrambled_genes <- (subsetByOverlaps(all_genes, unal$Oki_Osa[unal$Oki_Osa$nonCoa])) |> sort(i=F) |> flagLongShort(longShort$OKI2018.I69)
not_scrambled_genes <- all_genes[! all_genes %in% scrambled_genes]                  |> sort(i=F) |> flagLongShort(longShort$OKI2018.I69)

length(scrambled_genes)
length(all_genes)

scr_g_tbl <- table(paste(seqnames(    scrambled_genes), scrambled_genes$Arm))
nsc_g_tbl <- table(paste(seqnames(not_scrambled_genes), not_scrambled_genes$Arm))

Oki_Osa_scr_ratio_long_arm <- c(
  scr_g_tbl[["chr1 long"]] / ( scr_g_tbl[["chr1 long"]] + nsc_g_tbl[["chr1 long"]]),
  scr_g_tbl[["chr2 long"]] / ( scr_g_tbl[["chr2 long"]] + nsc_g_tbl[["chr2 long"]]),
  scr_g_tbl[["PAR long"]]  / ( scr_g_tbl[["PAR long"]]  + nsc_g_tbl[["PAR long"]])
)
mean(Oki_Osa_scr_ratio_long_arm)
Oki_Osa_scr_ratio_short_arm <- c(
  scr_g_tbl[["chr1 short"]] / ( scr_g_tbl[["chr1 short"]] + nsc_g_tbl[["chr1 short"]]),
  scr_g_tbl[["chr2 short"]] / ( scr_g_tbl[["chr2 short"]] + nsc_g_tbl[["chr2 short"]]),
  scr_g_tbl[["PAR short"]]  / ( scr_g_tbl[["PAR short"]]  + nsc_g_tbl[["PAR short"]])
)
mean(Oki_Osa_scr_ratio_short_arm)

t.test(Oki_Osa_scr_ratio_long_arm, Oki_Osa_scr_ratio_short_arm, paired = T)
```

Replicate on an independent pair of genomes.

```{r gene_conservation_Bar_Kum}
all_genes <- genes(annots$Bar)
scrambled_genes <- (subsetByOverlaps(all_genes, unal$Bar_Kum[unal$Bar_Kum$nonCoa])) |> sort(i=F) |> flagLongShort(longShort$Bar2.p4)
not_scrambled_genes <- all_genes[! all_genes %in% scrambled_genes]                  |> sort(i=F) |> flagLongShort(longShort$Bar2.p4)

length(scrambled_genes)
length(all_genes)

scr_g_tbl <- table(paste(seqnames(    scrambled_genes), scrambled_genes$Arm))
nsc_g_tbl <- table(paste(seqnames(not_scrambled_genes), not_scrambled_genes$Arm))

Bar_Kum_scr_ratio_long_arm <- c(
  scr_g_tbl[["Chr1 long"]] / ( scr_g_tbl[["Chr1 long"]] + nsc_g_tbl[["Chr1 long"]]),
  scr_g_tbl[["Chr2 long"]] / ( scr_g_tbl[["Chr2 long"]] + nsc_g_tbl[["Chr2 long"]]),
  scr_g_tbl[["PAR long"]]  / ( scr_g_tbl[["PAR long"]]  + nsc_g_tbl[["PAR long"]])
)
Bar_Kum_scr_ratio_short_arm <- c(
  scr_g_tbl[["Chr1 short"]] / ( scr_g_tbl[["Chr1 short"]] + nsc_g_tbl[["Chr1 short"]]),
  scr_g_tbl[["Chr2 short"]] / ( scr_g_tbl[["Chr2 short"]] + nsc_g_tbl[["Chr2 short"]]),
  scr_g_tbl[["PAR short"]]  / ( scr_g_tbl[["PAR short"]]  + nsc_g_tbl[["PAR short"]])
)

t.test(Bar_Kum_scr_ratio_long_arm, Bar_Kum_scr_ratio_short_arm, paired = TRUE)
```

```{r gene_conservation_all}
mean(c(Oki_Osa_scr_ratio_long_arm, Bar_Kum_scr_ratio_long_arm))
mean(c(Oki_Osa_scr_ratio_short_arm, Bar_Kum_scr_ratio_short_arm))
t.test(
  c(Oki_Osa_scr_ratio_long_arm, Bar_Kum_scr_ratio_long_arm),
  c(Oki_Osa_scr_ratio_short_arm, Bar_Kum_scr_ratio_short_arm),
  paired = TRUE
)
```

How about exons ?

```{r exon_conservation}
all_exons <- exonicParts(annots$Oki)
scrambled_exons <- (subsetByOverlaps(all_exons, unal$Oki_Osa[unal$Oki_Osa$nonCoa])) |> sort(i=F) |> flagLongShort(longShort$OKI2018.I69)
not_scrambled_exons <- all_exons[! all_exons %in% scrambled_exons]                  |> sort(i=F) |> flagLongShort(longShort$OKI2018.I69)

length(scrambled_exons)
length(all_exons)

scr_g_tbl <- table(paste(seqnames(    scrambled_exons), scrambled_exons$Arm))
nsc_g_tbl <- table(paste(seqnames(not_scrambled_exons), not_scrambled_exons$Arm))

Oki_Osa_scr_ratio_long_arm <- c(
  scr_g_tbl[["chr1 long"]] / ( scr_g_tbl[["chr1 long"]] + nsc_g_tbl[["chr1 long"]]),
  scr_g_tbl[["chr2 long"]] / ( scr_g_tbl[["chr2 long"]] + nsc_g_tbl[["chr2 long"]]),
  scr_g_tbl[["PAR long"]]  / ( scr_g_tbl[["PAR long"]]  + nsc_g_tbl[["PAR long"]])
)
mean(Oki_Osa_scr_ratio_long_arm)
Oki_Osa_scr_ratio_short_arm <- c(
  scr_g_tbl[["chr1 short"]] / ( scr_g_tbl[["chr1 short"]] + nsc_g_tbl[["chr1 short"]]),
  scr_g_tbl[["chr2 short"]] / ( scr_g_tbl[["chr2 short"]] + nsc_g_tbl[["chr2 short"]]),
  scr_g_tbl[["PAR short"]]  / ( scr_g_tbl[["PAR short"]]  + nsc_g_tbl[["PAR short"]])
)
mean(Oki_Osa_scr_ratio_short_arm)

t.test(Oki_Osa_scr_ratio_long_arm, Oki_Osa_scr_ratio_short_arm, paired = T)
```

# Operon summary plots for Figure 3

```{r operon_summary_stats_plots, fig.height=6, fig.width=12, message=FALSE, warning=FALSE, dev=c("svg", "png", "pdf"), fig.ext=c("svg", "png", "pdf")}
# Add an index for matching to scrambled set
operons$Oki$index <- 1:length(operons$Oki)
operons$Oki$scrambled <- 'no_breakpoint_region'
operons$Oki$scrambled[operons$Oki %over% unal$Oki_Osa[unal$Oki_Osa$nonCoa]] <- 'overlaps_breakpoint_region'

operons$Osa$index <- 1:length(operons$Osa)
operons$Osa$scrambled <- 'no_breakpoint_region'
operons$Osa$scrambled[operons$Osa %over% unal$Osa_Oki[unal$Osa_Oki$nonCoa]] <- 'overlaps_breakpoint_region'

operons$Bar$index <- 1:length(operons$Bar)
operons$Bar$scrambled <- 'no_breakpoint_region'
operons$Bar$scrambled[operons$Bar %over% unal$Bar_Oki[unal$Bar_Oki$nonCoa]] <- 'overlaps_breakpoint_region'

tb1 <- operons$Oki
# Note that the operon objects do not have unique names, which makes as.data.frame() complain.
names(tb1) <- NULL
p1 <- ggplot(as.data.frame(tb1)) + aes(y=factor(n, levels = 2:max(operons$Oki$n, operons$Osa$n))) + geom_bar() + geom_text(stat='count', aes(label=..count.., hjust=-0.2)) + expand_limits(x=c(0,750)) + ylab("number of genes in operon") + xlab("Count") + facet_wrap(~scrambled, nrow=2) + ggtitle("Okinawa operons") + scale_y_discrete(drop=F)
p1

tb2 <- operons$Osa
names(tb2) <- NULL
p2 <- ggplot(as.data.frame(tb2)) + aes(y=factor(n, levels = 2:max(operons$Oki$n, operons$Osa$n))) + geom_bar() + geom_text(stat='count', aes(label=..count.., hjust=-0.2)) + expand_limits(x=c(0,750)) + ylab("number of genes in operon") + xlab("Count") + facet_wrap(~scrambled, nrow=2) + ggtitle("Osaka operons") + scale_y_discrete(drop=F)
p2

rbind(
  operons$Oki |> as.data.frame() |> dplyr::mutate(species="Okinawa"),
  operons$Osa |> as.data.frame() |> dplyr::mutate(species="Osaka"),
  operons$Bar |> as.data.frame() |> dplyr::mutate(species="Barcelona")
) |> ggplot() +
  aes(y=factor(n)) +
  geom_bar() +
  facet_wrap(~scrambled + species) +
  geom_text(stat='count', aes(label=..count.., hjust=-0.2)) +
  theme_bw() +
  scale_x_continuous("Number operons", limits = c(0,1200)) +
  scale_y_discrete("Number of genes in operon")
  
p3 <- ggplot(as.data.frame(tb1)) + aes(y=factor(n, levels = 2:max(operons$Oki$n, operons$Osa$n))) + geom_bar() + geom_text(stat='count', aes(label=..count.., hjust=-0.2)) + expand_limits(x=c(0,750)) + ylab("number of genes in operon") + xlab("Count") + facet_wrap(~scrambled, ncol=2) + ggtitle("Okinawa operons") + scale_y_discrete(drop=F)
p3

p4 <- ggplot(as.data.frame(tb2)) + aes(y=factor(n, levels = 2:max(operons$Oki$n, operons$Osa$n))) + geom_bar() + geom_text(stat='count', aes(label=..count.., hjust=-0.2)) + expand_limits(x=c(0,750)) + ylab("number of genes in operon") + xlab("Count") + facet_wrap(~scrambled, ncol=2) + ggtitle("Osaka operons") + scale_y_discrete(drop=F)
p4

( p3 / p4 )

tb1$sp <- "Oki"
tb2$sp <- "Osa"
tb3 <- rbind(as.data.frame(tb1), as.data.frame(tb2))
ggplot(tb3) + aes(x=factor(n, levels = 2:max(operons$Oki$n, operons$Osa$n))) + geom_bar(position='dodge', aes(fill=paste0(sp, "_", scrambled))) + scale_x_discrete(drop=F)
```

```{r operon_summary_stats_plots_2, fig.height=6, fig.width=12, message=FALSE, warning=FALSE, dev=c("svg", "png")}
genes$Oki$scrambled <- 'no_breakpoint_region'
genes$Oki$scrambled[genes$Oki %over% unal$Oki_Osa[unal$Oki_Osa$nonCoa]] <- 'overlaps_breakpoint_region'
genes$Oki$scrambled |> table()

genes$Osa$scrambled <- 'no_breakpoint_region'
genes$Osa$scrambled[genes$Osa %over% unal$Osa_Oki[unal$Osa_Oki$nonCoa]] <- 'overlaps_breakpoint_region'
genes$Osa$scrambled |> table()

genes$Bar$scrambled <- 'no_breakpoint_region'
genes$Bar$scrambled[genes$Bar %over% unal$Bar_Oki[unal$Bar_Oki$nonCoa]] <- 'overlaps_breakpoint_region'
genes$Bar$scrambled |> table()

exons <- sapply(annots, function(a) sort(exons(a))) |> SimpleList()
exons <- sapply(exons, function(e) {
  names(e) <- e$exon_id
  e
}) |> SimpleList()

exons$Oki$scrambled <- 'no_breakpoint_region'
exons$Oki$scrambled[exons$Oki %over% unal$Oki_Osa[unal$Oki_Osa$nonCoa]] <- 'overlaps_breakpoint_region'
exons$Oki$scrambled |> table()

exons$Osa$scrambled <- 'no_breakpoint_region'
exons$Osa$scrambled[exons$Osa %over% unal$Osa_Oki[unal$Osa_Oki$nonCoa]] <- 'overlaps_breakpoint_region'
exons$Osa$scrambled |> table()

exons$Bar$scrambled <- 'no_breakpoint_region'
exons$Bar$scrambled[exons$Bar %over% unal$Bar_Oki[unal$Bar_Oki$nonCoa]] <- 'overlaps_breakpoint_region'
exons$Bar$scrambled |> table()

oki_feat_bp_ovl <- rbind(
  operons$Oki$scrambled |> table(),
  genes$Oki$scrambled |> table(),
  exons$Oki$scrambled |> table()
) |> as.data.frame(row.names = c('operons', 'genes', 'exons'))
oki_feat_bp_ovl$pct <- oki_feat_bp_ovl[,2]/(oki_feat_bp_ovl[,1]+oki_feat_bp_ovl[,2])*100
oki_feat_bp_ovl$type <- rownames(oki_feat_bp_ovl)
oki_feat_bp_ovl$species <- "Okinawa"

osa_feat_bp_ovl <- rbind(
  operons$Osa$scrambled |> table(),
  genes$Osa$scrambled |> table(),
  exons$Osa$scrambled |> table()
) |> as.data.frame(row.names = c('operons', 'genes', 'exons'))
osa_feat_bp_ovl$pct <- osa_feat_bp_ovl[,2]/(osa_feat_bp_ovl[,1]+osa_feat_bp_ovl[,2])*100
osa_feat_bp_ovl$type <- rownames(osa_feat_bp_ovl)
osa_feat_bp_ovl$species <- "Osaka"

bar_feat_bp_ovl <- rbind(
  operons$Bar$scrambled |> table(),
  genes$Bar$scrambled |> table(),
  exons$Bar$scrambled |> table()
) |> as.data.frame(row.names = c('operons', 'genes', 'exons'))
bar_feat_bp_ovl$pct <- bar_feat_bp_ovl[,2]/(bar_feat_bp_ovl[,1]+bar_feat_bp_ovl[,2])*100
bar_feat_bp_ovl$type <- rownames(bar_feat_bp_ovl)
bar_feat_bp_ovl$species <- "Barcelona"

df <- operons$Oki
names(df) <- NULL
oki_feat_bp_ovl_join <- rbind(
  as.data.frame(df)        |> dplyr::mutate(type='operon') |> dplyr::select(seqnames, start, end, scrambled, type),
  as.data.frame(genes$Oki) |> dplyr::mutate(type='gene')   |> dplyr::select(seqnames, start, end, scrambled, type),
  as.data.frame(exons$Oki) |> dplyr::mutate(type='exon')   |> dplyr::select(seqnames, start, end, scrambled, type)
) |> dplyr::mutate(species='Oki')

df <- operons$Osa
names(df) <- NULL
osa_feat_bp_ovl_join <- rbind(
  as.data.frame(df)        |> dplyr::mutate(type='operon') |> dplyr::select(seqnames, start, end, scrambled, type),
  as.data.frame(genes$Osa) |> dplyr::mutate(type='gene')   |> dplyr::select(seqnames, start, end, scrambled, type),
  as.data.frame(exons$Osa) |> dplyr::mutate(type='exon')   |> dplyr::select(seqnames, start, end, scrambled, type)
) |> dplyr::mutate(species='Osa')

p1 <- ggplot(oki_feat_bp_ovl) + aes(x=type, y=pct, fill=type) + geom_bar(stat='identity') + ylab('percent overlapping breakpoint region') + ggtitle('Okinawa feature plot') + ylim(c(0, 50)) + theme_bw()

p2 <- ggplot(osa_feat_bp_ovl) + aes(x=type, y=pct, fill=type) + geom_bar(stat='identity') + ylab('percent overlapping breakpoint region') + ggtitle('Osaka feature plot') + ylim(c(0, 50)) + theme_bw()

p3 <- ggplot(bar_feat_bp_ovl) + aes(x=type, y=pct, fill=type) + geom_bar(stat='identity') + ylab('percent overlapping breakpoint region') + ggtitle('Barcelona feature plot') + ylim(c(0, 50)) + theme_bw()

( p1 | p2 | p3)
```

```{r operon_overlap_stats_plot, dev=c("svg", "png", "pdf"), fig.ext=c("svg", "png", "pdf")}
rbind(oki_feat_bp_ovl, osa_feat_bp_ovl, bar_feat_bp_ovl) |>
  ggplot() +
  aes(type, pct, fill = species) +
  geom_bar(stat = "identity", position="dodge")  +
  scale_y_continuous("Percent features overlaping breakpoint regions") +
  scale_x_discrete("Feature type") +
  theme_bw()
```

# Coverage

_Needs coverage information to be recomputed_

Another characteristic of alignment stops that we can examine is the coverage depth over said alignment stops. By aligning raw reads to assembled genomes, we can obtain per-base coverage depth for target or query genome. Low coverage directly on and surrounding an alignment stop may suggest unreliability in it being a true breakpoint. The function `bp_coverage` returns a GRanges object of the bps, with associated averaged and point converage in the metadatacolumns. 

```{r coverage}
# cov_gr_O_Oki <- bp_coverage(gr_ob = q_Oki, cov_gr = Oki_cov_pb, win = 50)
# cov_gr_O_Oki
```

# Session information

```{r sessioninfo}
sessionInfo()
```
