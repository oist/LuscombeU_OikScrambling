---
title: "Multiple-to-one relations among genomes"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEncoding{UTF-8}
  %\VignetteIndexEntry{Multiple-to-one relationships}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup}
knitr::opts_knit$set(cache = TRUE)
options(width = 200)
```

Load packages and data
======================

See `?OikScrambling:::loadAllGenomes()` and `vignette("LoadGenomicBreaks",
package = "OikScrambling")` for how the different objects are prepared.

```{r load_packages_and_data}
suppressPackageStartupMessages({
  library("dplyr")
  library("GenomicBreaks")
  library("ggplot2")
  library("BreakpointsData")
  library("patchwork")
})
genomes <- OikScrambling:::loadAllGenomes(compat = FALSE)

load("BreakPoints.Rdata")

loadLongShort <- function(file, genome) {
  file <- system.file(paste0("extdata/Annotations/", file), package = "BreakpointsData")
  gr <- rtracklayer::import.gff3(file)
  gr$source <- gr$type <- gr$score <- gr$phase <- NULL
  GRanges(gr, seqinfo = seqinfo(getBSgenome(genome)), strand = "*")
}

flagLongShort_ <- function(gr, longShort) {
  genomeT <- gr |> genome() |> unique()
  if(genomeT %in% names(longShort))
    gr <- flagLongShort(gr, longShort[[genomeT]])
  if("GBreaks" %in% class(gr)) {
      genomeQ <- gr$query |> genome() |> unique()
      if(genomeQ %in% names(longShort)) {
        # sort, flag, unsort, extract flag
        grq <- gr$query
        grq$idx <- seq_along(grq)
        grq <- sort(grq, ignore.strand = TRUE)
        grq <- flagLongShort(grq, longShort[[genomeQ]])
        gr$query$Arm <- grq$Arm[order(grq$idx)]
      }
  }
  gr
}

longShort <- SimpleList()
longShort$OKI2018.I69   <- loadLongShort("OKI2018_I69.v2/OKI2018_I69.arms.gff3", "OKI2018.I69")
longShort$OSKA2016v1.9  <- loadLongShort("OSKA2016v1.9/OSKA2016v1.9.arms.gff3",  "OSKA2016v1.9")
longShort$Bar2.p4       <- loadLongShort("Bar2_p4.Flye/Bar2_p4.Flye.arms.gff3",  "Bar2.p4")

#' Loading functions from:
#' \code{vignette("LoadGenomicBreaks", package = "OikScrambling")}
```

# Accounting for multiple-to-one alignments

In general, we work at the level of one-to-one correspondence. However, some regions may have multiple-to-one correspondence, or else multiple-to-multiple correspondence. To disentangle these, we must examine the non-one-to-one alignments.

Below, I take a look at the properties of these alignments.

The precomputed `.gff` files were generated using `maf-convert` from the output of the pairwise alignment pipeline.

On our cluster, the files are available on:

`/bucket/LuscombeU/live/michaelmansfield/Breakpoints/2022.03.29-tandem_inverted_duplications`

```{r original_alignments}
# Local function to add extra annotation on long/short arms while loading data
load_genomic_breaks_ <- function(file, prefix=NULL, genomeT, genomeQ, longShort=NULL) {
  file <- paste0(prefix, file)
  # Note that "match_part" is not present when the -J option is not used.
  gb <- load_genomic_breaks(file, getBSgenome(genomeT),  getBSgenome(genomeQ), type="match")
  flagLongShort_(gb, longShort)
}

load_all_multi2ones <- function(prefix=NULL) {
  many2one <- SimpleList()
  many2one$Oki_Osa <- load_genomic_breaks_("Oki__OSKA2016v1.9.gff.gz", prefix=prefix, "OKI2018.I69",  "OSKA2016v1.9", longShort)
  many2one$Oki_Aom <- load_genomic_breaks_("Oki__AOM-5-5f.gff.gz", prefix=prefix, "OKI2018.I69",  "AOM.5.5f", longShort)
  many2one$Oki_Bar <- load_genomic_breaks_("Oki__Bar2_p4.gff.gz", prefix=prefix, "OKI2018.I69", "Bar2.p4", longShort)
  many2one$Oki_Nor <- load_genomic_breaks_("Oki__OdB3.gff.gz", prefix=prefix, "OKI2018.I69", "OdB3", longShort)
  many2one$Oki_Kum <- load_genomic_breaks_("Oki__KUM-M3-7f.gff.gz", prefix=prefix, "OKI2018.I69", "KUM.M3.7f", longShort)
  
  many2one$Osa_Oki <- load_genomic_breaks_("Osa__OKI2018_I69_1.0.gff.gz", prefix=prefix, "OSKA2016v1.9", "OKI2018.I69",  longShort)
  many2one$Osa_Bar <- load_genomic_breaks_("Osa__Bar2_p4.gff.gz", prefix=prefix, "OSKA2016v1.9", "Bar2.p4",     longShort)
  many2one$Osa_Kum <- load_genomic_breaks_("Osa__KUM-M3-7f.gff.gz", prefix=prefix, "OSKA2016v1.9", "KUM.M3.7f", longShort)
  many2one$Osa_Aom <- load_genomic_breaks_("Osa__AOM-5-5f.gff.gz", prefix=prefix, "OSKA2016v1.9", "AOM.5.5f",   longShort)
  many2one$Osa_Nor <- load_genomic_breaks_("Osa__OdB3.gff.gz", prefix=prefix, "OSKA2016v1.9", "OdB3",           longShort)

  many2one$Bar_Oki <- load_genomic_breaks_("Bar__OKI2018_I69_1.0.gff.gz", prefix=prefix, "Bar2.p4", "OKI2018.I69", longShort)
  many2one$Bar_Osa <- load_genomic_breaks_("Bar__OSKA2016v1.9.gff.gz", prefix=prefix, "Bar2.p4", "OSKA2016v1.9", longShort)
  many2one$Bar_Kum <- load_genomic_breaks_("Bar__KUM-M3-7f.gff.gz", prefix=prefix, "Bar2.p4", "KUM.M3.7f", longShort)
  many2one$Bar_Aom <- load_genomic_breaks_("Bar__AOM-5-5f.gff.gz", prefix=prefix, "Bar2.p4", "AOM.5.5f", longShort)
  many2one$Bar_Nor <- load_genomic_breaks_("Bar__OdB3.gff.gz", prefix=prefix, "Bar2.p4", "OdB3", longShort)
  many2one
}

load('../../m2o.Rd')
# m2o <- SimpleList()
# 
# m2o$original01   <- load_all_multi2ones(prefix="../../Alignments/1_converted_maf_01.original_alignment/Oidioi_v3/")
# m2o$split03      <- load_all_multi2ones(prefix="../../Alignments/1_converted_maf_03.split/Oidioi_v3/")
# m2o$split05      <- load_all_multi2ones(prefix="../../Alignments/1_converted_maf_05.split/Oidioi_v3/")
# m2o$postmasked07 <- load_all_multi2ones(prefix="../../Alignments/1_converted_maf_07.postmasked/Oidioi_v3/")

```

Let's examine the properties of these alignments.

```{r confirming_one_to_one_ness}
# Make sure that some target regions match more than one region in the query.
paste0(seqnames(m2o$split03$Oki_Osa), "_", ranges(m2o$split03$Oki_Osa)) |> table() |> sort() |> tail()
# Make sure each query region matches exactly one region.
paste0(seqnames(m2o$split03$Oki_Osa$query), "_", ranges(m2o$split03$Oki_Osa$query)) |> table() |> sort() |> tail()

# Check the range totals for each of these objects.
(m2o$split03$Oki_Osa       |> width() |> sum() )
(m2o$split03$Oki_Osa       |> reduce() |> width() |> sum() )
(m2o$split03$Oki_Osa$query |> width() |> sum() )
(m2o$split03$Oki_Osa$query |> reduce() |> width() |> sum() )

(m2o$split03$Oki_Osa       |> width() |> sum() )
(m2o$split03$Oki_Osa       |> reduce() |> width() |> sum() )
(m2o$split03$Oki_Osa$query |> width() |> sum() )
(m2o$split03$Oki_Osa$query |> reduce() |> width() |> sum() )

(m2o$split05$Oki_Osa       |> width() |> sum() )
(m2o$split05$Oki_Osa       |> reduce() |> width() |> sum() )
(m2o$split05$Oki_Osa$query |> width() |> sum() )
(m2o$split05$Oki_Osa$query |> reduce() |> width() |> sum() )

(m2o$postmasked07$Oki_Osa       |> width() |> sum() )
(m2o$postmasked07$Oki_Osa       |> reduce() |> width() |> sum() )
(m2o$postmasked07$Oki_Osa$query |> width() |> sum() )
(m2o$postmasked07$Oki_Osa$query |> reduce() |> width() |> sum() )

(gbs$Oki_Osa |> width() |> sum())
(gbs$Oki_Osa$query |> width() |> sum())
```

## Flagging alignment correspondence
Alignments are originally created as multiple-to-multiple, or many-to-many, correspondence. However, not every segment
within these regions is actually many-to-many. Below, I create some functions to return what kind of correspondence
each aligned region has.

N.B. Computing the `m2o_cor` requires lots of memory. I saved it to an `.Rdata` image which is not part of the vignette. This is commented out in the chunk below.

```{r flagging_correspondence_1}
# Function to report correspondence in GBreaks countOverlaps() for target and query.
query_target_correspondence <- function(target_overlaps, query_overlaps) {
  types <- rep(NA, length(target_overlaps))
  for(i in seq_along(1:length(types))){
    if(target_overlaps[i] == 1){
      if(query_overlaps[i] == 1){
        types[i] <- "one_to_one"
      } else {
        types[i] <- "one_to_many"
      }
    } else {
      if(query_overlaps[i] == 1) {
        types[i] <- "many_to_one"
      } else {
        types[i] <- "many_to_many"
      }
    }
  }
  types
}

correspondence <- function(gb) {
  gb$target_overlaps <- countOverlaps(gb)
  gb$query_overlaps  <- countOverlaps(gb$query)
  gb$correspondence <- query_target_correspondence(gb$target_overlaps, gb$query_overlaps)
  gb
}
(correspondence(head(gbs$Oki_Osa, n=10)))

load_all_multi2ones_correspondence <- function(prefix=NULL) {
  many2one <- SimpleList()
  many2one$Oki_Osa <- load_genomic_breaks_("Oki__OSKA2016v1.9.gff.gz", prefix=prefix, "OKI2018.I69",  "OSKA2016v1.9", longShort) |> correspondence()
  many2one$Oki_Aom <- load_genomic_breaks_("Oki__AOM-5-5f.gff.gz", prefix=prefix, "OKI2018.I69",  "AOM.5.5f", longShort) |> correspondence()
  many2one$Oki_Bar <- load_genomic_breaks_("Oki__Bar2_p4.gff.gz", prefix=prefix, "OKI2018.I69", "Bar2.p4", longShort) |> correspondence()
  many2one$Oki_Nor <- load_genomic_breaks_("Oki__OdB3.gff.gz", prefix=prefix, "OKI2018.I69", "OdB3", longShort) |> correspondence()
  many2one$Oki_Kum <- load_genomic_breaks_("Oki__KUM-M3-7f.gff.gz", prefix=prefix, "OKI2018.I69", "KUM.M3.7f", longShort) |> correspondence()
  
  many2one$Osa_Oki <- load_genomic_breaks_("Osa__OKI2018_I69_1.0.gff.gz", prefix=prefix, "OSKA2016v1.9", "OKI2018.I69",  longShort) |> correspondence() 
  many2one$Osa_Bar <- load_genomic_breaks_("Osa__Bar2_p4.gff.gz", prefix=prefix, "OSKA2016v1.9", "Bar2.p4",     longShort) |> correspondence()
  many2one$Osa_Kum <- load_genomic_breaks_("Osa__KUM-M3-7f.gff.gz", prefix=prefix, "OSKA2016v1.9", "KUM.M3.7f", longShort) |> correspondence()
  many2one$Osa_Aom <- load_genomic_breaks_("Osa__AOM-5-5f.gff.gz", prefix=prefix, "OSKA2016v1.9", "AOM.5.5f",   longShort) |> correspondence()
  many2one$Osa_Nor <- load_genomic_breaks_("Osa__OdB3.gff.gz", prefix=prefix, "OSKA2016v1.9", "OdB3",           longShort) |> correspondence()

  many2one$Bar_Oki <- load_genomic_breaks_("Bar__OKI2018_I69_1.0.gff.gz", prefix=prefix, "Bar2.p4", "OKI2018.I69", longShort) |> correspondence()
  many2one$Bar_Osa <- load_genomic_breaks_("Bar__OSKA2016v1.9.gff.gz", prefix=prefix, "Bar2.p4", "OSKA2016v1.9", longShort) |> correspondence()
  many2one$Bar_Kum <- load_genomic_breaks_("Bar__KUM-M3-7f.gff.gz", prefix=prefix, "Bar2.p4", "KUM.M3.7f", longShort) |> correspondence()
  many2one$Bar_Aom <- load_genomic_breaks_("Bar__AOM-5-5f.gff.gz", prefix=prefix, "Bar2.p4", "AOM.5.5f", longShort) |> correspondence()
  many2one$Bar_Nor <- load_genomic_breaks_("Bar__OdB3.gff.gz", prefix=prefix, "Bar2.p4", "OdB3", longShort) |> correspondence()
  many2one
}

load('../../m2o_cor.Rd')
# m2o_cor <- SimpleList()
# m2o_cor$original01   <- load_all_multi2ones_correspondence(prefix="../../Alignments/1_converted_maf_01.original_alignment/Oidioi_v3/")
# m2o_cor$split03      <- load_all_multi2ones_correspondence(prefix="../../Alignments/1_converted_maf_03.split/Oidioi_v3/")
# m2o_cor$split05      <- load_all_multi2ones_correspondence(prefix="../../Alignments/1_converted_maf_05.split/Oidioi_v3/")
# m2o_cor$postmasked07 <- load_all_multi2ones_correspondence(prefix="../../Alignments/1_converted_maf_07.postmasked/Oidioi_v3/")

```

```{r reduce_keep_meta}
# An mc-version of the sapply function.
# From https://stackoverflow.com/questions/31050556/parallel-version-of-sapply
mcsapply <- function (X, FUN, ..., simplify = TRUE, USE.NAMES = TRUE) {
  FUN <- match.fun(FUN)
  answer <- parallel::mclapply(X = X, FUN = FUN, ...)
  if (USE.NAMES && is.character(X) && is.null(names(answer))) 
    names(answer) <- X
  if (!isFALSE(simplify) && length(answer)) 
    simplify2array(answer, higher = (simplify == "array"))
  else answer
}

# Reduce a GRanges, turning all of the reduced metadata columns into lists and binding them
# to the reduced GRanges.
reduce_keepMeta <- function(gr, mc.cores=1){
  gr_red <- reduce(gr, with.revmap=TRUE)
  revmap <- mcols(gr_red)$revmap
  gr_relist <- relist(gr[unlist(revmap)], revmap)
  gr_red$constituents <- gr_relist

  new_mcols <- mcsapply(mc.cores=mc.cores, gr_red$constituents, function(constitutent) {
    mcol_names <- colnames(mcols(constitutent))
    listed_mcols <- setNames(lapply(mcol_names, function(m) {
      SimpleList(mcols(constitutent)[[m]])
    }), mcol_names) |> SimpleList()
    df <- do.call(cbind, listed_mcols)
    return(df)
  })
  new_mcols <- do.call(rbind, new_mcols)
  mcols(gr_red) <- cbind(mcols(gr_red), new_mcols)
  mcols(gr_red) <- mcols(gr_red)[,which( ! colnames(mcols(gr_red)) %in% c('revmap', 'constituents'))]
  gr_red
}
# This takes a ton of memory and compute. Hold on to your butts.
#reduce_keepMeta(m2o$original01$Oki_Osa, mc.cores=8)
#load('../../m2o_red.Rd')
#m2o_red <- sapply(m2o, function(o) sapply(o, function(p) reduce_keepMeta(p)) |> SimpleList() ) |> SimpleList()

```

Below, I assess the one-to-one correspondence of a variety of alignments using a different method using `GenomicRanges::reduce`. 

The logic goes as follows:
- one-to-one: `length(revmap(reduce(target))) == 1` and `length(revmap(reduce(query))) == 1`
- one-to-many: `length(revmap(reduce(target))) == 1` and `length(revmap(reduce(query))) > 1`
- many-to-one: `length(revmap(reduce(target))) > 1` and `length(revmap(reduce(query))) == 1`
- many-to-many: `length(revmap(reduce(target))) > 1` and `length(revmap(reduce(query))) > 1`

N.B. As above, computing the `m2o_gr` object requires lots of memory. I saved it to an `.Rdata` image which is not part of the vignette. This is commented out in the chunk below.

```{r flagging_correspondence_2}
query_target_correspondence_gr <- function(gb, mc.cores=1) {
  # Reduce query and target with GenomicRanges::reduce.
  gr_red <- reduce(gb, with.revmap=TRUE)
  revmap <- mcols(gr_red)$revmap
  gr_red$revmap_len <- unlist(lapply(revmap, length))
  gr_relist <- relist(gb[unlist(revmap)], revmap)
  # For every range within every split, reduced GRange, calculate one-to-one-ness.
  q_revmaps <- mcsapply(mc.cores=mc.cores, seq_along(gr_relist), function(i) {
    r <- unlist(gr_relist[i])
    q <- r$query
    q_red <- reduce(q, with.revmap=TRUE)
    q_revmap <- mcols(q_red)$revmap
    q_revmap
  })

  gr_red$q_revmap_len <- unlist(lapply(q_revmaps, length))
  
  compare_revmaps <- function(rv1, rv2) {
    corres <- lapply(1:length(rv1), function(s) {
      if(rv1[s] == 1 & rv2[s] == 1){
        return('one_to_one')
      } else if(rv1[s] > 1 & rv2[s] == 1){
        return('many_to_one')
      } else if(rv1[s] == 1 & rv2[s] > 1){
        return('one_to_many')
      } else if(rv1[s] > 1 & rv2[s] > 1){
        return('many_to_many')
      }
    })
    corres <- unlist(corres)
    corres
  }
  gr_red$correspondence <- compare_revmaps(gr_red$revmap_len, gr_red$q_revmap_len)
  gr_red
}
(query_target_correspondence_gr(head(m2o$original01$Oki_Osa)))

load('../../m2o_gr.Rd')
# m2o_gr <- SimpleList()
# m2o_gr$original01 <- sapply(m2o$original01, function(sp) query_target_correspondence_gr(sp, mc.cores=1)) |> SimpleList()
# m2o_gr$split03 <- sapply(m2o$split03, function(sp) query_target_correspondence_gr(sp, mc.cores=1)) |> SimpleList()
# m2o_gr$split05 <- sapply(m2o$split05, function(sp) query_target_correspondence(sp, mc.cores=1)) |> SimpleList()
# m2o_gr$postmasked07 <- sapply(m2o$postmasked07, function(sp) query_target_correspondence_gr(sp, mc.cores=1)) |> SimpleList()

```

The strategy above combines the multiple-to-one regions into single continuous stretches with `reduce()`, analogous to `GenomicBreaks::coalesce_contigs()`. The lengths of the reduced ranges in the target and query are used to annotate the one-to-one-ness of a segment.

Now, examine the overlaps of one-to-one and non-one-to-one regions with different alignment categories. How do many-to-many alignments correspond to different alignment categories? First, some functions to make this easier.

```{r flagging_correspondence_3, fig.height=8, fig.width=12, dev=c("svg", "pdf", "png"), fig.ext=c("svg", "pdf", "png")}
compare_m2o_wgo <- function(pair, m2o_obj, m2o_align, m2o_category="one_to_one", wgo_obj) {
  many2one <- m2o_obj[[m2o_align]][[pair]]
  many2one <- many2one[many2one$correspondence == m2o_category]
  
  wgo_total_len <- sapply(split(wgo_obj[[pair]], wgo_obj[[pair]]$type), function(x) sum(width(x))) |> as.data.frame() |> t() |> as.data.frame()
  rownames(wgo_total_len) <- NULL
  
  wgo_ovl <- subsetByOverlaps(wgo_obj[[pair]], many2one)
  wgo_ovl_len <- sapply(split(wgo_ovl, wgo_ovl$type), function(x) sum(width(x))) |> as.data.frame() |> t() |> as.data.frame()
  rownames(wgo_ovl_len) <- NULL

  df <- wgo_ovl$type |> table() |> as.data.frame() |> mutate(pct=Freq/sum(Freq)*100)
  colnames(df) <- c("alignment_category", "count", "percent_within_m2o_category")
  df$pair <- pair
  df$m2o_align <- m2o_align
  df$m2o_category <- m2o_category
  df$wgo_size <- unlist(wgo_total_len)
  df$wgo_ovl_size <- unlist(wgo_ovl_len)
  df <- df[,c(4,5,6,1,2,3,7,8)]
  df
}
compare_m2o_wgo("Oki_Osa", m2o_gr, "original01", "one_to_one", wgo)

compare_m2o_wgo_all <- function(pair, m2o_obj, m2o_align, wgo){
  df <- rbind(
    compare_m2o_wgo(pair, m2o_obj, m2o_align, m2o_category="one_to_one", wgo),
    compare_m2o_wgo(pair, m2o_obj, m2o_align, m2o_category="many_to_one", wgo),
    compare_m2o_wgo(pair, m2o_obj, m2o_align, m2o_category="many_to_many", wgo)
  )
  df$percent_overall <- df$count/sum(df$count)*100
  df
}
```

Then, some plots.

```{r flagging_correspondence_4, fig.height=8, fig.width=12, dev=c("svg", "pdf", "png"), fig.ext=c("svg", "pdf", "png")}
# Okinawa
tmp <- do.call(rbind, lapply(list("Oki_Osa", "Oki_Bar", "Oki_Kum"), function(pair) compare_m2o_wgo_all(pair, m2o_gr, "original01", wgo)))
tmp$pair <- factor(tmp$pair, levels=c("Oki_Osa", "Oki_Bar", "Oki_Kum"))

p1 <- ggplot(tmp) + aes(x=m2o_category, y=percent_within_m2o_category, fill=alignment_category) + geom_bar(stat='identity', position='stack') + facet_grid(~pair)
p1 + ggtitle("Okinawa alignment categories vs. many-to-many alignments")

# Osaka
tmp <- do.call(rbind, lapply(list("Osa_Oki", "Osa_Bar", "Osa_Aom"), function(pair) compare_m2o_wgo_all(pair, m2o_gr, "original01", wgo)))
tmp$pair <- factor(tmp$pair, levels=c("Osa_Oki", "Osa_Bar", "Osa_Aom"))

p2 <- ggplot(tmp) + aes(x=m2o_category, y=percent_within_m2o_category, fill=alignment_category) + geom_bar(stat='identity', position='stack') + facet_grid(~pair)
p2 + ggtitle("Osaka alignment categories vs. many-to-many alignments")

# Barcelona
tmp <- do.call(rbind, lapply(list("Bar_Oki", "Bar_Osa", "Bar_Nor"), function(pair) compare_m2o_wgo_all(pair, m2o_gr, "original01", wgo)))
tmp$pair <- factor(tmp$pair, levels=c("Bar_Oki", "Bar_Osa", "Bar_Nor"))

p3 <- ggplot(tmp) + aes(x=m2o_category, y=percent_within_m2o_category, fill=alignment_category) + geom_bar(stat='identity', position='stack') + facet_grid(~pair)
p3 + ggtitle("Barcelona: alignment categories vs. many-to-many alignments")

( p1 / p2 / p3 )

```

### Intersecting different alignment objects with many-to-many annotations

```{r flagging_correspondence_6}
compare_m2o_gb <- function(pair, m2o_obj, m2o_align, m2o_category=c("one_to_one"), gb, gb_name) {
  many2one <- m2o_obj[[m2o_align]][[pair]]
  many2one <- many2one[many2one$correspondence == m2o_category]
  ovl <- subsetByOverlaps(gb, many2one[many2one$correspondence %in% m2o_category])
  df <- data.frame(pair=pair, m2o_align=m2o_align, m2o_category=m2o_category, gb_name=gb_name, overlapN=length(ovl), overlapWidth=sum(width(ovl)) )
  df
}

category_df <- rbind(
  compare_m2o_gb(pair="Oki_Osa", m2o_obj=m2o_gr, m2o_align="original01", m2o_category=c("one_to_one"), gb=wgo$Oki_Osa[wgo$Oki_Osa$type=='collinear alignment'], gb_name="collinear region"),
  compare_m2o_gb(pair="Oki_Osa", m2o_obj=m2o_gr, m2o_align="original01", m2o_category=c("many_to_many"), wgo$Oki_Osa[wgo$Oki_Osa$type=='collinear alignment'], gb_name="collinear region"),
  
  compare_m2o_gb(pair="Oki_Osa", m2o_obj=m2o_gr, m2o_align="original01", m2o_category=c("one_to_one"), gb=wgo$Oki_Osa[wgo$Oki_Osa$type=='isolated alignment'], gb_name="isolated alignment"),
  compare_m2o_gb(pair="Oki_Osa", m2o_obj=m2o_gr, m2o_align="original01", m2o_category=c("many_to_many"),  gb=wgo$Oki_Osa[wgo$Oki_Osa$type=='isolated alignment'], gb_name="isolated alignment"),
  
  compare_m2o_gb(pair="Oki_Osa", m2o_obj=m2o_gr, m2o_align="original01", m2o_category=c("one_to_one"), gb=wgo$Oki_Osa[wgo$Oki_Osa$type=='breakpoint region'], gb_name="breakpoint region"),
  compare_m2o_gb(pair="Oki_Osa", m2o_obj=m2o_gr, m2o_align="original01", m2o_category=c("many_to_many"), gb=wgo$Oki_Osa[wgo$Oki_Osa$type=='breakpoint region'], gb_name="breakpoint region"),
  
  compare_m2o_gb(pair="Oki_Osa", m2o_obj=m2o_gr, m2o_align="original01", m2o_category=c("one_to_one"), gb=wgo$Oki_Osa[wgo$Oki_Osa$type=='bridge region'], gb_name="bridge region"),
  compare_m2o_gb(pair="Oki_Osa", m2o_obj=m2o_gr, m2o_align="original01", m2o_category=c("many_to_many"), gb=wgo$Oki_Osa[wgo$Oki_Osa$type=='bridge region'], gb_name="bridge region")
)
(category_df)
(sum(category_df$overlapWidth))
```

How much of each genome pair is neither one-to-one, nor one-to-many, nor many-to-many?

```{r flagging_correspondence_7}
wgo_breaks <- sapply(wgo, function(s) s[s$type=='breakpoint region'] |> width() |> sum())
(wgo_breaks)

breakpoints_with_some_alignment <- sapply(names(m2o_gr$original01), function(pair) {
  subsetByOverlaps(wgo[[pair]][wgo[[pair]]$type=='breakpoint region'], m2o_gr$original01[[pair]], invert=F) |> width() |> sum()
})
(breakpoints_with_some_alignment)

breakpoints_without_any_alignment <-sapply(names(m2o_gr$original01), function(pair) {
  subsetByOverlaps(wgo[[pair]][wgo[[pair]]$type=='breakpoint region'], m2o_gr$original01[[pair]], invert=T) |> width() |> sum()
})
(breakpoints_without_any_alignment)

wgo_breaks <- wgo_breaks[names(wgo_breaks) %in% names(breakpoints_with_some_alignment)]
wgo_breaks <- wgo_breaks[match( names(breakpoints_without_any_alignment), names(wgo_breaks))]

# Fraction of breakpoint regions with some alignments.
(breakpoints_with_some_alignment/(wgo_breaks)*100)
# Fraction of breakpoint regions without any alignments.
(breakpoints_without_any_alignment/(wgo_breaks)*100)

```

## Coverage-based version
An alternative design based on `GRanges::coverage()`.

```{r flagging_correspondence_8}
query_target_correspondence_cov <- function(gr) {
  # Count overlaps, using coverage
  t_gr <- gr |> coverage() |> as("GRanges")
  # remove 0-width GRanges
  t_gr <- t_gr |> plyranges::filter(score>0)
  t_gr$correspondence <- NA
  t_gr[t_gr$score==1]$correspondence <- "one_match"
  t_gr[t_gr$score>1]$correspondence <- "not_one_match"
  
  # Repeat the above, but for query ranges.
  q_gr <- gr$query |> coverage() |> as("GRanges")
  q_gr <- q_gr |> plyranges::filter(score>0)
  q_gr$correspondence <- NA
  q_gr[q_gr$score==1]$correspondence <- "one_match"
  q_gr[q_gr$score>1]$correspondence <- "not_one_match"
  
  result <- SimpleList()
  result$target <- t_gr
  result$query <- q_gr
  result
}
(query_target_correspondence_cov(m2o$original01$Oki_Osa)) -> tmp
(tmp$target)
(tmp$query)

#load('../../m2o_gr.Rd')
m2o_cov <- sapply(m2o$original01, function(sp) query_target_correspondence_cov(sp)) |> SimpleList()
```

Using the `m2o_cov` object, it is easy to compare with different alignment categories.

```{r flagging_correspondence_9}
compare_cov_wgo <- function(pair, m2o_obj, wgo, m2o_category="one_match", alignment_category='breakpoint region') {
  category_gr <- wgo[[pair]][wgo[[pair]]$type==alignment_category]
  category_m2o <- m2o_obj[[pair]]$target
  category_m2o <- category_m2o[category_m2o$correspondence == m2o_category]
  
  gr <- category_m2o |> subsetByOverlaps(category_gr)

  full_wgo_size <- wgo[[pair]] |> width() |> sum()
  category_size <- category_gr |> width() |> sum()
  overlap_size <- gr |> width() |> sum()
  
  data.frame(pair=pair, alignment_category=alignment_category, m2o_category=m2o_category, category_size=category_size, overlap_size=overlap_size, category_pct=overlap_size/category_size*100, total_pct=overlap_size/full_wgo_size*100)
}
(compare_cov_wgo("Oki_Osa", m2o_cov, wgo, m2o_category="one_match", alignment_category="breakpoint region"))


m2o_df <- do.call(rbind, lapply(unique(wgo$Oki_Osa$type), function(wgo_category) {
  do.call(rbind, lapply(c("one_match", "not_one_match"), function(m2o_category) {
    do.call(rbind, lapply(names(m2o_cov), function(pair) {
      compare_cov_wgo(pair, m2o_cov, wgo, m2o_category=m2o_category, alignment_category=wgo_category)
    }))
  }))
}))

(m2o_df)
```

Making summary plots with `m2o_df`:

```{r flagging_correspondence_10, fig.height=8, fig.width=12, dev=c("svg", "pdf", "png"), fig.ext=c("svg", "pdf", "png")}
ggplot(m2o_df) + aes(x=pair, y=overlap_size, fill=alignment_category) + facet_wrap(~m2o_category, nrow=2) + geom_bar(stat='identity', position='stack') + theme(axis.text.x=element_text(angle=90)) + ggtitle("Total overlap of alignment categories with regions in many-to-many alignments")

ggplot(m2o_df) + aes(x=pair, y=total_pct, fill=alignment_category) + facet_wrap(~m2o_category, nrow=2) + geom_bar(stat='identity', position='stack') + theme(axis.text.x=element_text(angle=90)) + ggtitle("Percentage of total alignment category covered in many-to-many alignments")


```

## Plotting distribution of matches across genome

In the following, I create some functions for visualising the distribution of alignment categories across the genome. 

`binWidth` sets a constant bin size, while `nIntervals` sets a number of intervals to divide `start` into. Using this approach, the short and long arms or chromosomes will always have different numbers of observations.

```{r plot_correspondence_1, fig.height=8, fig.width=12, dev=c("svg", "pdf", "png"), fig.ext=c("svg", "pdf", "png")}
# Function to transform a GBreaks into a tibble counting up X-to-X correspondence values.
categories_m2o <- function(gb, nIntervals=NULL, binWidth=NULL) {
  gb$seqnames_arm <- paste0(seqnames(gb), "_", gb$Arm)
  gb$seqnames_arm <- factor(gb$seqnames_arm, levels=unique(gb$seqnames_arm))
  gb$w <- width(gb)
  df <- as.data.frame(gb)
  
  if(!is.null(nIntervals)){
    df <- df |> mutate(bin=as.numeric(cut_interval(start, nIntervals))) |> group_by(bin, seqnames_arm, correspondence) |> summarise(n=n(), w_mean=mean(w), w_median=median(w), w_sum=sum(w)) |> mutate(freq=n/sum(n)*100)
  } else if (!is.null(binWidth)) {
    df <- df |> mutate(bin=as.numeric(cut_width(start, binWidth, center=0))) |> group_by(bin, seqnames_arm, correspondence) |> summarise(n=n(), w_mean=mean(w), w_median=median(w), w_sum=sum(w)) |> mutate(freq=n/sum(n)*100)
  }
  df
}
(categories_m2o(flagLongShort(m2o_gr$original01$Oki_Osa |> plyranges::filter(seqnames != 'YSR'), longShort$OKI2018.I69), nIntervals=25))
```

Now make some plots with these values, showing the distribution of many-to-many-ness across the genome.

```{r plot_correspondence_2, fig.height=8, fig.width=12, dev=c("svg", "pdf", "png"), fig.ext=c("svg", "pdf", "png")}
plot_categories_m2o <- function(gb, arms, nIntervals=25, binWidth=NULL, plot.what='n'){
  if(!is.null(nIntervals)){
    df <- categories_m2o(flagLongShort(gb, arms), nIntervals=nIntervals)
  } else if (!is.null(binWidth)) {
    df <- categories_m2o(flagLongShort(gb, arms), binWidth=binWidth)
  }
  
  if(plot.what=='n'){
    p <- ggplot(df) + aes(x=as.numeric(bin), y=n, fill=correspondence) + geom_bar(stat='identity', position='stack')+ facet_wrap(~seqnames_arm, nrow=1, scales='free_x') + xlab('bin')
  } else if(plot.what=='w_sum'){
    p <- ggplot(df) + aes(x=as.numeric(bin), y=w_sum, fill=correspondence) + geom_bar(stat='identity', position='stack')+ facet_wrap(~seqnames_arm, nrow=1, scales='free_x') + xlab('bin')
  } else if(plot.what=='w_mean'){
    p <- ggplot(df) + aes(x=as.numeric(bin), y=w_mean, fill=correspondence) + geom_bar(stat='identity', position='stack')+ facet_wrap(~seqnames_arm, nrow=1, scales='free_x') + xlab('bin')
  } else if(plot.what=='w_median'){
    p <- ggplot(df) + aes(x=as.numeric(bin), y=w_median, fill=correspondence) + geom_bar(stat='identity', position='stack')+ facet_wrap(~seqnames_arm, nrow=1, scales='free_x') + xlab('bin')
  }
  p
}

plot_categories_m2o(m2o_gr$original01$Oki_Osa |> plyranges::filter(seqnames != 'YSR'), longShort$OKI2018.I69, nIntervals=25, plot.what='w_sum') + ggtitle("Okinawa-Osaka: alignment types across genome")
```

```{r plot_correspondence_3, fig.height=8, fig.width=12, message=FALSE, warning=FALSE, dev=c("svg", "png")}
p1 <- plot_categories_m2o(m2o_gr$original01$Oki_Osa |> plyranges::filter(seqnames != 'YSR'), longShort$OKI2018.I69, nIntervals=25, plot.what='w_sum') + ggtitle('Oki-Osa: original01 alignment')
p2 <- plot_categories_m2o(m2o_gr$original01$Oki_Bar |> plyranges::filter(seqnames != 'YSR'), longShort$OKI2018.I69, nIntervals=25, plot.what='w_sum') + ggtitle('Oki-Bar: original01 alignment')
p3 <- plot_categories_m2o(m2o_gr$original01$Oki_Kum |> plyranges::filter(seqnames != 'YSR'), longShort$OKI2018.I69, nIntervals=25, plot.what='w_sum') + ggtitle('Oki-Kum: original01 alignment')

( p1 / p2 / p3 )
```

```{r plot_correspondence_4, fig.height=8, fig.width=12, message=FALSE, warning=FALSE, dev=c("svg", "png")}
plot_categories_m2o_allAlignments <- function(pair, arms, m2o, nIntervals=NULL, binWidth=NULL, plot.what='w_sum') {
  p1 <- plot_categories_m2o(m2o$original01[[pair]]  |> plyranges::filter(seqnames != 'YSR'), arms, nIntervals=nIntervals, binWidth=binWidth, plot.what=plot.what) + ggtitle(paste0(pair, ": original01 alignment"))
  p2 <- plot_categories_m2o(m2o$split03[[pair]]  |> plyranges::filter(seqnames != 'YSR'), arms, nIntervals=nIntervals, binWidth=binWidth, plot.what=plot.what) + ggtitle(paste0(pair, ": split03 alignment"))
  p3 <- plot_categories_m2o(m2o$split05[[pair]]  |> plyranges::filter(seqnames != 'YSR'), arms, nIntervals=nIntervals, binWidth=binWidth, plot.what=plot.what) + ggtitle(paste0(pair, ": split05 alignment"))
  p4 <- plot_categories_m2o(m2o$postmasked07[[pair]]  |> plyranges::filter(seqnames != 'YSR'), arms, nIntervals=nIntervals, binWidth=binWidth, plot.what=plot.what) + ggtitle(paste0(pair, ": postmasked alignment"))
  (p1 / p2 / p3 / p4 )
}
(plot_categories_m2o_allAlignments("Oki_Osa", longShort$OKI2018.I69, m2o_gr, nIntervals=20, plot.what='w_sum'))
(plot_categories_m2o_allAlignments("Oki_Bar", longShort$OKI2018.I69, m2o_gr, nIntervals=20, plot.what='w_sum'))
(plot_categories_m2o_allAlignments("Oki_Kum", longShort$OKI2018.I69, m2o_gr, nIntervals=20, plot.what='w_sum'))

(plot_categories_m2o_allAlignments("Osa_Oki", longShort$OSKA2016v1.9, m2o_gr, nIntervals=20, plot.what='w_sum'))
(plot_categories_m2o_allAlignments("Osa_Bar", longShort$OSKA2016v1.9, m2o_gr, nIntervals=20, plot.what='w_sum'))
```

# Session information

```{r session_information}
sessionInfo()
```
