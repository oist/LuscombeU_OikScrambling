---
title: "Chromosome-scale feature density plots"
author: 
 - "Michael Mansfield"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEncoding{UTF-8}
  %\VignetteIndexEntry{Chromosome plots}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup}
knitr::opts_chunk$set(cache = TRUE, cache.lazy = FALSE)
knitr::opts_knit$set(verbose = TRUE)
```

# Introduction

In this vignette, we develop some of the materials needed to produce plots that summarize genomic data at chromosome-scale.

The core functions used here are maintained in our _GenomicBreaks_ R package,
which is fully documented at: <https://oist.github.io/GenomicBreaks>.

## Load packages

# Load R packages and data

```{r load_packages_and_data}
library('OikScrambling') |> suppressPackageStartupMessages()
library('dplyr')
library('ggplot2')
library('purrr')
library('viridis') |> suppressPackageStartupMessages()
(genomes <- OikScrambling:::loadAllGenomes())
(transcripts <- OikScrambling:::loadAllTranscriptsGR())
(load("BreakPoints.Rdata"))
```

### Creating chromosome-scale plots
In this vignette, we create the plumbing needed to generate summary plots that show windows of genomic features on a chromosome scale. 

#### Summarizing genomic windows of annotated `GRanges` objects
Below, I create some of the functions needed to produce these plots.

```{r chromosome_plot_helper_fxns, cache=TRUE, fig.height=6, fig.width=12, message=FALSE, warning=FALSE, dev=c("svg", "png")}
# Find midpoints of a GRanges object
grMidpoint <- function(gr) {
  starts <- as.data.frame(ranges(gr))$start
  ends <- as.data.frame(ranges(gr))$end
  mids <- (starts+ends)/2
  mids
}

# Make a BSgenome into a GRanges object, one range per chromosome
BSgenomeToGR <- function(genome) {
  df <- data.frame(seqnames=seqnames(genome), start=1, end=lengths(genome), strand="*")
  gr <- makeGRangesFromDataFrame(df)
  gr
}
(BSgenomeToGR(genomes$Oki))

# Make a genome into a bunch of windows of length N
genomeGRToWindows <- function(gr, windowSize=10000) {
  df <- as.data.frame(gr)
  chr <- split(df, df$seqnames)
  chr <- lapply(chr, function(l) {
    start_positions <- seq(from=1, to=l$end, by=windowSize)
    end_positions = start_positions + windowSize
    end_positions[length(end_positions)] <- l$end
    df <- data.frame(seqnames=l$seqnames, start=start_positions, end=end_positions)
    df
  })
  chr <- do.call(rbind, chr)
  rownames(chr) <- NULL
  gr <- makeGRangesFromDataFrame(chr)
  gr
}
(genomeGRToWindows(tmp))

# Generate counts and stats for a column within mcol(GRanges)
mcolStats <- function(mcol, mcolName=NULL, windowSize=10000) {
  count <- length(na.omit(mcol))
  count_norm <- count/windowSize
  
  # Create a new DF and overwrite NA's as needed
  df <- data.frame('count'=count, 'count_norm'=count_norm, 'mean'=NA, 'median'=NA, 'sd'=NA)
  if(is.numeric(mcol)){
    df$mean <- mean(mcol, na.rm=T)
    df$median <- median(mcol, na.rm=T)
    df$sd <- sd(mcol, na.rm=T)
  }
  
  # Add column name prefix to facilitate cbind later
  if(!is.null(mcolName)){
    colnames(df) <- sapply(colnames(df), function(s) paste(mcolName, '.', s, sep='') )
  }
  df
}
(mcolStats(subsetByOverlaps(transcripts$Oki, tmp2[1:70,])$dNdS_HmmCleaner))

# Wrapper to calculate stats (i.e., mcolStats) on every column in a metadata GRanges
mcolStatsArray <- function(metaSubset, windowSize=10000, includeMetaCols=NULL) {
  metaSubset <- as.data.frame(mcols(metaSubset))
  meta_cols <- colnames(metaSubset)
  # If metaCols is supplied, then only include metaCols in the array.
  if(!is.null(includeMetaCols)){
    meta_cols <- meta_cols[which(meta_cols %in% includeMetaCols)]
  }
  # For every remaining metadata column, calculate stats, using the column name to allow cbinding
  mcolSA <- lapply(meta_cols, function(m) mcolStats(metaSubset[[m]], mcolName=m, windowSize=windowSize))
  mcolSA <- do.call(cbind, mcolSA)
  mcolSA
}
(mcolStatsArray(subsetByOverlaps(transcripts$Oki, tmp2[1:70,])))

# Intersect each genome window with some other GRange (meta, as in metadata)
metaPerWindow <- function(genomeWindows, meta, windowSize=10000, includeMetaCols=NULL, threads=1) {
  # For every genomic window...
  gwl <- BiocParallel::bplapply(1:length(genomeWindows), function(gw){
    ovl <- subsetByOverlaps(meta, genomeWindows[gw,]) # Get metadata window aligning with genome window
    mc <- mcolStatsArray(ovl, windowSize=windowSize, includeMetaCols=includeMetaCols) # For every metadata window, calculate stats
    annot <- ovl # Create annotated GRanges
    #annot <- lapply(colnames(mc), function(col) annot[[col]] <- mc[[col]])
    annot
  })
  gwl
}
metaPerWindow(tmp2, transcripts$Oki[1:100,], windowSize=10000, includeMetaCols=NULL, threads=4)


# Function to do everything
grWindows <- function(genome=NULL, meta=NULL, windowSize=10000, includeMetaCols=NULL, threads=1){
  genome <- BSgenomeToGR(genome)                             # Make GRanges from genome
  genome <- genomeGRToWindows(genome, windowSize=windowSize) # Make a windowed GRange from chromosome GRanges
  mpw <- metaPerWindow(genome, meta, windowSize=windowSize, includeMetaCols=includeMetaCols, threads=threads) # if 
}
tmp <- grWindows(genome=genomes$Oki, meta=transcripts$Oki, windowSize=10000, threads=4)
```



# Session information

```{r sessionInfo}
sessionInfo()
```


