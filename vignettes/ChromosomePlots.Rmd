---
title: "Chromosome-scale feature density plots"
author: 
 - "Michael Mansfield"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEncoding{UTF-8}
  %\VignetteIndexEntry{Chromosome plots}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup}
knitr::opts_chunk$set(cache = TRUE, cache.lazy = FALSE)
knitr::opts_knit$set(verbose = TRUE)
```

# Introduction

In this vignette, we develop some of the materials needed to produce plots that summarize genomic data at chromosome-scale.

The core functions used here are maintained in our _GenomicBreaks_ R package,
which is fully documented at: <https://oist.github.io/GenomicBreaks>.

## Load packages

# Load R packages and data

```{r load_packages_and_data}
library('GenomicBreaks') |> suppressPackageStartupMessages()
library('OikScrambling') |> suppressPackageStartupMessages()
library('dplyr')
library('ggplot2')
library('purrr')
library('viridis') |> suppressPackageStartupMessages()
(genomes <- OikScrambling:::loadAllGenomes())
(transcripts <- OikScrambling:::loadAllTranscriptsGR())
(load("BreakPoints.Rdata"))
```

### Creating chromosome-scale plots
In this vignette, we create the plumbing needed to generate summary plots that show windows of genomic features on a chromosome scale. 

#### Summarizing genomic windows of annotated `GRanges` objects
Below, I create some of the functions needed to produce these plots.

```{r chromosome_plot_helper_fxns, cache=TRUE, fig.height=6, fig.width=12, message=FALSE, warning=FALSE, dev=c("svg", "png")}
# Find midpoints of a GRanges object
grMidpoint <- function(gr) {
  (start(gr) + end(gr)) / 2
}

# Make a BSgenome into a GRanges object, one range per chromosome
BSgenomeToGR <- function(genome) {
  as(seqinfo(genome), "GRanges")
}
tmp <- genomes$Oki |> BSgenomeToGR()
(tmp)

# Make a genome into a bunch of windows of length N
genomeGRToWindows <- function(gr, windowSize=10000) {
  chr <- split(gr, seqnames(gr))
  chr <- endoapply(chr, function(l) {
    start_positions <- seq(from=1, to=end(l), by=windowSize)
    end_positions   <- start_positions + windowSize
    end_positions[length(end_positions)] <- end(l)
    GRanges(seqlevelsInUse(l), IRanges(start_positions, end=end_positions), seqinfo = seqinfo(gr))
  })
  unlist(chr)
}
#tmp <- genomes$Oki |> BSgenomeToGR() |> genomeGRToWindows()
#(tmp)
(genomes$Oki |> BSgenomeToGR() |> genomeGRToWindows())
# See also (genomes$Oki |> BSgenomeToGR() |> tile(w=10000)) |> unlist() |> unname()

# Generate counts and stats for a column within mcol(GRanges)
mcolStats <- function(mcol, mcolName=NULL, windowSize=10000) {
  count <- length(na.omit(mcol))
  count_norm <- count/windowSize
  
  # Create a new DF and overwrite NA's as needed
  df <- data.frame('count'=count, 'count_norm'=count_norm, 'mean'=NA, 'median'=NA, 'sd'=NA)
  if(is.numeric(mcol)){
    df$mean <- mean(mcol, na.rm=T)
    df$median <- median(mcol, na.rm=T)
    df$sd <- sd(mcol, na.rm=T)
  }
  
  # Add column name prefix to facilitate cbind later
  if(!is.null(mcolName)){
    colnames(df) <- sapply(colnames(df), function(s) paste(mcolName, '.', s, sep='') )
  }
  df
}
# Picked a random line with a dN/dS value (65) 
#tmp2 <- mcolStats(subsetByOverlaps(transcripts$Oki, tmp[65])$dNdS_HmmCleaner, mcolName = 'dNdS_HmmCleaner')
#(tmp2)
(mcolStats(subsetByOverlaps(transcripts$Oki, tmp[65])$dNdS_HmmCleaner, mcolName = 'dNdS_HmmCleaner'))

# Wrapper to calculate stats (i.e., mcolStats) on every column in a metadata GRanges
mcolStatsArray <- function(meta, windowSize=10000, includeMetaCols=NULL) {
  metaMcols <- mcols(meta)
  metaMcolNames <- colnames(metaMcols)
  # If metaCols is supplied, then only include metaCols in the array.
  if(!is.null(includeMetaCols)){
    metaMcolNames <- metaMcolNames[which(metaMcolNames %in% includeMetaCols)]
  }
  # For every remaining metadata column, calculate stats
  mcolSA <- lapply(metaMcolNames, function(m) {
    dat <- as.list(metaMcols[[m]])
    names(dat) <- m
    df <- mcolStats(metaMcols[[m]], mcolName=m, windowSize=windowSize)
    df
  })
  mcolSA <- do.call(cbind, mcolSA)  |> DataFrame()
  mcolSA
}
(mcolStatsArray(subsetByOverlaps(transcripts$Oki, tmp[30,])))

# Separate function to make a fake stats dataframe with nothing in it
mcolBlankArray <- function(meta, includeMetaCols=NULL){
  metaMcols <- mcols(meta)
  metaMcolNames <- colnames(metaMcols)
  # If metaCols is supplied, then only include metaCols in the array.
  if(!is.null(includeMetaCols)){
    metaMcolNames <- metaMcolNames[which(metaMcolNames %in% includeMetaCols)]
  }
  # For every remaining metadata column, calculate stats
  mcolSA <- lapply(metaMcolNames, function(m) {
    dat <- as.list(metaMcols[[m]])
    names(dat) <- m
    df <- data.frame(matrix(0))
    colnames(df)[1] = paste(m, 'count', sep='.')
    df[[paste(m, 'count_norm', sep='.')]] = 0
    df[[paste(m, 'mean', sep='.')]] = NA
    df[[paste(m, 'median', sep='.')]] = NA
    df[[paste(m, 'sd', sep='.')]] = NA
    df
  })
  mcolSA <- do.call(cbind, mcolSA)  |> DataFrame()
  mcolSA
}
tmp <- genomes$Oki |> BSgenomeToGR() |> genomeGRToWindows()
(mcolBlankArray(subsetByOverlaps(transcripts$Oki, tmp[30:32])))


# Intersect each genome window with some other GRange (meta, as in metadata)
metaPerWindow <- function(genomeWindows, meta, windowSize=10000, includeMetaCols=NULL) {
  # For every genomic window...
  #gwl <- BiocParallel::bplapply(1:length(genomeWindows), function(gw){
  gwl <- lapply(1:length(genomeWindows), function(gw){
    ovl <- subsetByOverlaps(meta, genomeWindows[gw,]) # Get metadata window aligning with genome window
    if(length(ovl)==0){ # If there is no overlap between the GRanges, initialize a blank one
      cur_window <- genomeWindows[gw,]
      mc <- mcolBlankArray(meta[1,], includeMetaCols = includeMetaCols)
      mcols(cur_window) <- mc
      cur_window
    } else {
      mc <- mcolStatsArray(ovl, windowSize=windowSize, includeMetaCols=includeMetaCols) # For every metadata window, calculate stats
      cur_window <- genomeWindows[gw,] # Create annotated GRanges
      mcols(cur_window) <- mc
      cur_window
    }
  })
  gr <- do.call('c', gwl) # Change list of GRanges to a single GRanges
  gr
}
(metaPerWindow(genomeWindows=genomeGRToWindows(BSgenomeToGR(genomes$Oki))[10:60,], transcripts$Oki, windowSize=10000)[[1]])

# Function to do everything
grWindows <- function(genome=NULL, meta=NULL, windowSize=10000, includeMetaCols=NULL){
  genome <- BSgenomeToGR(genome)                             # Make GRanges from genome
  genome <- genomeGRToWindows(genome, windowSize=windowSize) # Make a windowed GRange from chromosome GRanges
  mpw <- metaPerWindow(genome, meta, windowSize=windowSize, includeMetaCols=includeMetaCols)
  mpw
}

transcripts$Oki <- flagLongShort(transcripts$Oki, longShort$OKI2018.I69)
transcripts$Osa <- flagLongShort(transcripts$Osa, longShort$OSKA2016v1.9)
transcripts$Bar <- flagLongShort(transcripts$Bar, longShort$Bar2.p4)

windowSize = 20000
chrw <- SimpleList()
chrw$Oki <- grWindows(genome=genomes$Oki, meta=transcripts$Oki, windowSize=windowSize)
seqlevels(chrw$Oki) <- sort(seqlevels(chrw$Oki))

chrw$Osa <- grWindows(genome=genomes$Osa, meta=transcripts$Osa, windowSize=windowSize)
seqlevels(chrw$Osa) <- sort(seqlevels(chrw$Osa))

chrw$Bar <- grWindows(genome=genomes$Bar, meta=transcripts$Bar, windowSize=windowSize)
seqlevels(chrw$Bar) <- sort(seqlevels(chrw$Bar))

```

```{r chromosome_plots_1, cache=TRUE, fig.height=6, fig.width=12, message=FALSE, warning=FALSE, dev=c("svg", "png")}
ggplot(as.data.frame(chrw$Oki)  %>% filter(seqnames %in% c('chr1', 'chr2', 'PAR', 'XSR', 'YSR')) ) + aes(x=start, y=dNdS_PRANK.median) + geom_point() + facet_wrap(seqnames ~ Arm)
```

# Session information

```{r sessionInfo}
sessionInfo()
```


