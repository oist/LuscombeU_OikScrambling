---
title: "Chromosome-scale feature density plots"
author: 
 - "Michael Mansfield"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEncoding{UTF-8}
  %\VignetteIndexEntry{Chromosome plots}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup}
knitr::opts_chunk$set(cache = TRUE, cache.lazy = FALSE)
knitr::opts_knit$set(verbose = TRUE)
```

# Introduction

In this vignette, we develop some of the materials needed to produce plots that summarize genomic data at chromosome-scale.

The core functions used here are maintained in our _GenomicBreaks_ R package,
which is fully documented at: <https://oist.github.io/GenomicBreaks>.

## Load packages

# Load R packages and data

```{r load_packages_and_data}
library('GenomicBreaks') |> suppressPackageStartupMessages()
library('OikScrambling') |> suppressPackageStartupMessages()
library('dplyr')
library('ggplot2')
library('purrr')
library('viridis') |> suppressPackageStartupMessages()
(genomes <- OikScrambling:::loadAllGenomes())
(transcripts <- OikScrambling:::loadAllTranscriptsGR())
(load("BreakPoints.Rdata"))
```

### Creating chromosome-scale plots
In this vignette, we create the plumbing needed to generate summary plots that show windows of genomic features on a chromosome scale. 

#### Summarizing genomic windows of annotated `GRanges` objects
Below, I create some of the functions needed to produce these plots.

```{r chromosome_plot_helper_fxns, cache=TRUE, fig.height=6, fig.width=12, message=FALSE, warning=FALSE, dev=c("svg", "png")}
# Find midpoints of a GRanges object
grMidpoint <- function(gr) {
  (start(gr) + end(gr)) / 2
}

# Make a BSgenome into a GRanges object, one range per chromosome
BSgenomeToGR <- function(genome) {
  as(seqinfo(genome), "GRanges")
}
tmp <- genomes$Oki |> BSgenomeToGR()
(tmp)

# Make a genome into a bunch of windows of length N
genomeGRToWindows <- function(gr, windowSize=10000) {
  chr <- split(gr, seqnames(gr))
  chr <- endoapply(chr, function(l) {
    start_positions <- seq(from=1, to=end(l), by=windowSize)
    end_positions   <- start_positions + windowSize -1
    end_positions[length(end_positions)] <- end(l)
    GRanges(seqlevelsInUse(l), IRanges(start_positions, end=end_positions), seqinfo = seqinfo(gr))
  })
  unlist(chr)
}
#tmp <- genomes$Oki |> BSgenomeToGR() |> genomeGRToWindows()
#(tmp)
(genomes$Oki |> BSgenomeToGR() |> genomeGRToWindows())
# See also genomes$Oki |> BSgenomeToGR() |> tile(w=10000) |> unlist() |> unname()

# Generate counts and stats for a column within mcol(GRanges)
mcolStats <- function(mcol, mcolName=NULL, windowSize=10000) {
  count <- length(na.omit(mcol))
  count_norm <- count/windowSize
  
  # Create a new DF and overwrite NA's as needed
  df <- data.frame('count'=count, 'count_norm'=count_norm, 'mean'=NA, 'median'=NA, 'sd'=NA)
  if(is.numeric(mcol)){
    df$mean <- mean(mcol, na.rm=T)
    df$median <- median(mcol, na.rm=T)
    df$sd <- sd(mcol, na.rm=T)
  }
  
  # Add column name prefix to facilitate cbind later
  if(!is.null(mcolName)){
    colnames(df) <- sapply(colnames(df), function(s) paste(mcolName, '.', s, sep='') )
  }
  df
}
# Picked a random line with a dN/dS value (65) 
#tmp2 <- mcolStats(subsetByOverlaps(transcripts$Oki, tmp[65])$dNdS_HmmCleaner, mcolName = 'dNdS_HmmCleaner')
#(tmp2)
(mcolStats(subsetByOverlaps(transcripts$Oki, tmp[65])$dNdS_HmmCleaner, mcolName = 'dNdS_HmmCleaner'))

tmp <- genomes$Oki |> BSgenomeToGR() |> genomeGRToWindows()
(mcolBlankArray(subsetByOverlaps(transcripts$Oki, tmp[30:32])))

# Match ranges to a single bin by reducing each range to its center.
# Returns the index of the matched bins
matchToOneBin <- function(ranges, bins) {
  # Ensure that a range overlaps with only one bin
  safeRanges <- ranges |> resize(1, fix="center")
  o <- findOverlaps(safeRanges, bins, type = 'within')
  subjectHits(o)
}
(matchToOneBin(transcripts$Oki, tmp))

# Apply one function to data grouped by bins, and array it according to the
# original bins (that is, insert NAs for bins that contained no data).
# This function only works as intended if the bins fully tile the genome.
binApply <- function(f, bins, data, index, ...) {
  res <- rep(NA, length(bins))
  vals <-tapply(data, index, f, ...)
  res[as.numeric(names(vals))] <- unname(vals)
  res
}
(binApply(mean, tmp, transcripts$Oki$dNdS_GUIDANCE2, matchToOneBin(transcripts$Oki, tmp), na.rm = TRUE))

# Intersect each genome window with some other GRange (meta, as in metadata)
metaPerWindow <- function(genomeWindows, meta, includeMetaCols=NULL) {
  idx <- matchToOneBin(meta, genomeWindows)
  for (name in colnames(mcols(meta))) {
    data <- mcols(meta)[[name]]
    if(is.numeric(data)) {
      mcols(genomeWindows)[[paste0(name, ".count")]]  <- binApply(length, genomeWindows, data, idx)
      mcols(genomeWindows)[[paste0(name, ".median")]] <- binApply(median, genomeWindows, data, idx, na.rm = TRUE)
      mcols(genomeWindows)[[paste0(name, ".mean")]]   <- binApply(mean,   genomeWindows, data, idx, na.rm = TRUE)
      mcols(genomeWindows)[[paste0(name, ".sd")]]     <- binApply(sd,     genomeWindows, data, idx, na.rm = TRUE)
    }
  }
  genomeWindows
}
(metaPerWindow(genomeWindows=tmp, transcripts$Oki))

# Function to do everything
grWindows <- function(genome, meta, windowSize=10000){
  genome <- BSgenomeToGR(genome)                             # Make GRanges from genome
  genome <- genomeGRToWindows(genome, windowSize=windowSize) # Make a windowed GRange from chromosome GRanges
  mpw <- metaPerWindow(genome, meta)
  mpw
}

windowSize = 20000
chrw <- SimpleList()
chrw$Oki <- grWindows(genome=genomes$Oki, meta=transcripts$Oki, windowSize=windowSize)
chrw$Oki <- flagLongShort(chrw$Oki, longShort$OKI2018.I69)
chrw$Osa <- grWindows(genome=genomes$Osa, meta=transcripts$Osa, windowSize=windowSize)
chrw$Osa <- flagLongShort(chrw$Osa, longShort$OKI2018.I69)
chrw$Bar <- grWindows(genome=genomes$Bar, meta=transcripts$Bar, windowSize=windowSize)
chrw$Bar <- flagLongShort(chrw$Bar, longShort$OKI2018.I69)
```

```{r chromosome_plots_1, cache=TRUE, fig.height=6, fig.width=12, message=FALSE, warning=FALSE, dev=c("svg", "png")}
ggplot(as.data.frame(chrw$Oki |> unname())  %>% filter(seqnames %in% c('chr1', 'chr2', 'PAR', 'XSR', 'YSR')) ) + aes(x=start, y=dNdS_PRANK.median) + geom_point() + facet_wrap(seqnames ~ Arm)
```

# Session information

```{r sessionInfo}
sessionInfo()
```
