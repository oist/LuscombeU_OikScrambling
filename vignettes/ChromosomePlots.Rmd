---
title: "Chromosome-scale feature density plots"
author: 
 - "Michael Mansfield"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEncoding{UTF-8}
  %\VignetteIndexEntry{Chromosome plots}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup}
knitr::opts_chunk$set(cache = TRUE, cache.lazy = FALSE)
knitr::opts_knit$set(verbose = TRUE)
```

# Introduction

In this vignette, we develop some of the materials needed to produce plots that summarize genomic data at chromosome-scale.

The core functions used here are maintained in our _GenomicBreaks_ R package,
which is fully documented at: <https://oist.github.io/GenomicBreaks>.

## Load packages

# Load R packages and data

```{r load_packages_and_data}
library('OikScrambling') |> suppressPackageStartupMessages()
library('dplyr')
library('ggplot2')
library('purrr')
library('viridis') |> suppressPackageStartupMessages()
(genomes <- OikScrambling:::loadAllGenomes())
(transcripts <- OikScrambling:::loadAllTranscriptsGR())
(load("BreakPoints.Rdata"))
```

### Creating chromosome-scale plots
In this vignette, we create the plumbing needed to generate summary plots that show windows of genomic features on a chromosome scale. 

#### Summarizing genomic windows of annotated `GRanges` objects
Below, I create some of the functions needed to produce these plots.

```{r chromosome_plot_helper_fxns, cache=TRUE, fig.height=6, fig.width=12, message=FALSE, warning=FALSE, dev=c("svg", "png")}
# Find midpoints of a GRanges object
grMidpoint <- function(gr) {
  starts <- as.data.frame(ranges(gr))$start
  ends <- as.data.frame(ranges(gr))$end
  mids <- (starts+ends)/2
  mids
}

# Make a BSgenome into a GRanges object, one range per chromosome
BSgenomeToGR <- function(genome) {
  df <- data.frame(seqnames=seqnames(genome), start=1, end=lengths(genome), strand="*")
  gr <- makeGRangesFromDataFrame(df)
  gr
}
tmp <- genomes$Oki |> BSgenomeToGR()
(tmp)

# Make a genome into a bunch of windows of length N
genomeGRToWindows <- function(gr, windowSize=10000) {
  df <- as.data.frame(gr)
  chr <- split(df, df$seqnames)
  chr <- lapply(chr, function(l) {
    start_positions <- seq(from=1, to=l$end, by=windowSize)
    end_positions = start_positions + windowSize
    end_positions[length(end_positions)] <- l$end
    df <- data.frame(seqnames=l$seqnames, start=start_positions, end=end_positions)
    df
  })
  chr <- do.call(rbind, chr)
  rownames(chr) <- NULL
  gr <- makeGRangesFromDataFrame(chr)
  gr
}
tmp <- genomes$Oki |> BSgenomeToGR() |> genomeGRToWindows()
(tmp)

# Generate counts and stats for a column within mcol(GRanges)
mcolStats <- function(mcol, mcolName=NULL, windowSize=10000) {
  count <- length(na.omit(mcol))
  count_norm <- count/windowSize
  
  # Create a new DF and overwrite NA's as needed
  df <- data.frame('count'=count, 'count_norm'=count_norm, 'mean'=NA, 'median'=NA, 'sd'=NA)
  if(is.numeric(mcol)){
    df$mean <- mean(mcol, na.rm=T)
    df$median <- median(mcol, na.rm=T)
    df$sd <- sd(mcol, na.rm=T)
  }
  
  # Add column name prefix to facilitate cbind later
  if(!is.null(mcolName)){
    colnames(df) <- sapply(colnames(df), function(s) paste(mcolName, '.', s, sep='') )
  }
  df
}
# Picked a random line with a dN/dS value (65) 
tmp2 <- mcolStats(subsetByOverlaps(transcripts$Oki, tmp[65,])$dNdS_HmmCleaner, mcolName = 'dNdS_HmmCleaner')
(tmp2)

# Wrapper to calculate stats (i.e., mcolStats) on every column in a metadata GRanges
mcolStatsArray <- function(meta, windowSize=10000, includeMetaCols=NULL) {
  metaMcols <- mcols(meta)
  metaMcolNames <- colnames(metaMcols)
  # If metaCols is supplied, then only include metaCols in the array.
  if(!is.null(includeMetaCols)){
    metaMcolNames <- metaMcolNames[which(metaMcolNames %in% includeMetaCols)]
  }
  # For every remaining metadata column, calculate stats
  mcolSA <- lapply(metaMcolNames, function(m) {
    dat <- as.list(metaMcols[[m]])
    names(dat) <- m
    df <- mcolStats(metaMcols[[m]], mcolName=m, windowSize=windowSize)
    df
  })
  mcolSA <- do.call(cbind, mcolSA)  |> DataFrame()
  mcolSA
}
(mcolStatsArray(subsetByOverlaps(transcripts$Oki, tmp[30,])))

# Separate function to make a fake stats dataframe with nothing in it
mcolBlankArray <- function(meta, includeMetaCols=NULL){
  metaMcols <- mcols(meta)
  metaMcolNames <- colnames(metaMcols)
  # If metaCols is supplied, then only include metaCols in the array.
  if(!is.null(includeMetaCols)){
    metaMcolNames <- metaMcolNames[which(metaMcolNames %in% includeMetaCols)]
  }
  # For every remaining metadata column, calculate stats
  mcolSA <- lapply(metaMcolNames, function(m) {
    dat <- as.list(metaMcols[[m]])
    names(dat) <- m
    df <- data.frame(matrix(0))
    colnames(df)[1] = paste(m, 'count', sep='.')
    df[[paste(m, 'count_norm', sep='.')]] = 0
    df[[paste(m, 'mean', sep='.')]] = NA
    df[[paste(m, 'median', sep='.')]] = NA
    df[[paste(m, 'sd', sep='.')]] = NA
    df
  })
  mcolSA <- do.call(cbind, mcolSA)  |> DataFrame()
  mcolSA
}
(mcolBlankArray(subsetByOverlaps(transcripts$Oki, tmp[30,])))


# Intersect each genome window with some other GRange (meta, as in metadata)
metaPerWindow <- function(genomeWindows, meta, windowSize=10000, includeMetaCols=NULL) {
  # For every genomic window...
  #gwl <- BiocParallel::bplapply(1:length(genomeWindows), function(gw){
  gwl <- lapply(1:length(genomeWindows), function(gw){
    ovl <- subsetByOverlaps(meta, genomeWindows[gw,]) # Get metadata window aligning with genome window
    if(length(ovl)==0){ # If there is no overlap between the GRanges, initialize a blank one
      cur_window <- genomeWindows[gw,]
      mc <- mcolBlankArray(meta[1,], includeMetaCols = includeMetaCols)
      mcols(cur_window) <- mc
      cur_window
    } else {
      mc <- mcolStatsArray(ovl, windowSize=windowSize, includeMetaCols=includeMetaCols) # For every metadata window, calculate stats
      cur_window <- genomeWindows[gw,] # Create annotated GRanges
      mcols(cur_window) <- mc
      cur_window
    }
  })
  gwl #<- as(gwl, "GRangesList") # |> unlist() # unlist(as(l3, "GRangesList"))
}
tmp3 <- metaPerWindow(genomeWindows=genomeGRToWindows(BSgenomeToGR(genomes$Oki))[10:60,], transcripts$Oki, windowSize=10000)

# Function to do everything
grWindows <- function(genome=NULL, meta=NULL, windowSize=10000, includeMetaCols=NULL){
  genome <- BSgenomeToGR(genome)                             # Make GRanges from genome
  genome <- genomeGRToWindows(genome, windowSize=windowSize) # Make a windowed GRange from chromosome GRanges
  mpw <- metaPerWindow(genome, meta, windowSize=windowSize, includeMetaCols=includeMetaCols) # if 
}
tmp <- grWindows(genome=genomes$Oki, meta=transcripts$Oki, windowSize=10000)
```



# Session information

```{r sessionInfo}
sessionInfo()
```


