---
title: "Distance Measures"
author: 
 - "Charles Plessy"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEncoding{UTF-8}
  %\VignetteIndexEntry{Distance Measures}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

# Purpose

We want to put numbers on visual impressions such as:

 - There is a lot of scrambling.
 - Aligned regions stay on their chromosome arm.
 - Aligned regions are more "off the diagonal" on short arms than on long arms.
 - â€¦

# Load R pacakges and data

```{r load_packages_and_data}
library('OikScrambling') |> suppressPackageStartupMessages()
load("BreakPoints.Rdata")
```

See `vignette("LoadGenomicBreaks", package = "OikScrambling")` for how the
different GBreaks objects are prepared.

# Declare service functions

```{r pretty_print_functions}
pairs2table6x3 <- function (x) {
  x <- as.list(x)
  cbind(
    Oki = c(Oki = NA,        Osa = x$Osa_Oki, Bar = x$Bar_Oki),
    Kum = c(Oki = x$Oki_Kum, Osa = x$Osa_Kum, Bar = x$Bar_Kum),
    Osa = c(Oki = x$Oki_Osa, Osa = NA,        Bar = x$Bar_Osa),
    Aom = c(Oki = x$Oki_Aom, Osa = x$Osa_Aom, Bar = x$Bar_Aom),
    Bar = c(Oki = x$Oki_Bar, Osa = x$Osa_Bar, Bar = NA       ),
    Nor = c(Oki = x$Oki_Nor, Osa = x$Osa_Nor, Bar = x$Bar_Nor)
  )
}

pairs2Kable6x3 <- function (df) df |> pairs2table6x3() |> round(2) |> knitr::kable()
```

# Synteny index

Ad-hoc index measuring to what extent a scaffold of the _target_ genome is
mostly aligned to a single scaffold in the _query_ genome.   See
`?GenomicBreaks::synteny_index` for details.  One limitation to the use of this
index is that it requires that at least the _query_ genome is a complete
chromosome assembly.

```{r synteny_index_def}
synteny_index
```

```{r synteny_index_run}
BiocParallel::bplapply(gbs,                 synteny_index  ) |> pairs2Kable6x3()
BiocParallel::bplapply(gbs, \(g) swap(g) |> synteny_index()) |> pairs2Kable6x3()
```

# Correlation

Ad-hoc index measuring the correlation of the coordinates of the syntenic
alignments in scaffolds of a _target_ genome and their best match in the
_query_ genome.  See `?GenomicBreaks::correlation_index` for details.  It is
intended to be more robust to the presence of uncollapsed haplotypes in the
_query_ genome but probably needs further testing.

```{r correlation_index_def}
correlation_index
```

```{r correlation_index_run}
BiocParallel::bplapply(gbs,                 correlation_index  ) |> pairs2Kable6x3()
BiocParallel::bplapply(gbs, \(g) swap(g) |> correlation_index()) |> pairs2Kable6x3()
```

# Gene Order Conservation

See `?GenomicBreaks::GOC` for details.

```{r goc_index_def}
GOC
```

```{r goc_index_run}
BiocParallel::bplapply(gbs,                 GOC  ) |> pairs2Kable6x3()
BiocParallel::bplapply(gbs, \(g) swap(g) |> GOC()) |> pairs2Kable6x3()
```

# Strand randomisation index

See `?GenomicBreaks::strand_randomisation_index` for details.

```{r strand_randomisation_index_def}
strand_randomisation_index
```

```{r strand_randomisation_index_run}
BiocParallel::bplapply(gbs,                 strand_randomisation_index  ) |> pairs2Kable6x3()
BiocParallel::bplapply(gbs, \(g) swap(g) |> strand_randomisation_index()) |> pairs2Kable6x3()
```

## Strand randomisation index permutation testing

In order to assess the extent to which the strand randomisation index may vary in a given pair of genomes, I do a simple permutation test. Given a `GBreaks` object, reverse the strand of a randomly-selected number of alignments drawn from a distribution according, by fitting it to a distribution that approximately describes strand orientation.

You can evaluate the relative frequency of "flips", i.e., a possible inversion, by counting the frequency of changes in the strand. I check this quickly below. Then I use the shape of this distribution to select a random number of flips to make, then make 10,000 permutations of the alignment with the randomly-selected number of flips, then calculate strand randomization indices on these randomly-flipped alignments. 

```{r strand_randomisation_permutation_test}
# Some libraries for fitting distributions...
library(fitdistrplus) |> suppressPackageStartupMessages()
library(stats4)       |> suppressPackageStartupMessages()
library(MASS)         |> suppressPackageStartupMessages()
library(survival)     |> suppressPackageStartupMessages()
library(actuar)       |> suppressPackageStartupMessages()
library(distrMod)     |> suppressPackageStartupMessages()
library(parallel)     |> suppressPackageStartupMessages()
library(patchwork)    |> suppressPackageStartupMessages()


# Each pair produces a slightly different graph. However, hopefully the distribution is similar.
plotdist(gbs$Oki_Osa |> strand() |> runLength() |> as.numeric(), demp=TRUE)
plotdist(gbs$Oki_Bar |> strand() |> runLength() |> as.numeric(), demp=TRUE)
plotdist(gbs$Osa_Bar |> strand() |> runLength() |> as.numeric(), demp=TRUE)
plotdist(gbs$Oki_Kum |> strand() |> runLength() |> as.numeric(), demp=TRUE)

descdist(gbs$Oki_Osa |> strand() |> runLength() |> as.numeric(), boot = 10000)
descdist(gbs$Oki_Bar |> strand() |> runLength() |> as.numeric(), boot = 10000)
descdist(gbs$Osa_Bar |> strand() |> runLength() |> as.numeric(), boot = 10000)
descdist(gbs$Oki_Kum |> strand() |> runLength() |> as.numeric(), boot = 10000)


# Fit a numeric vector (i.e., the strand run length) to a number of probability distributions
fit_distributions <- function(vec, distributions = c("nbinom", "pois", "lnorm", "norm", "exp", "gamma", "llogis", "weibull"), method="mle", ...) {
  setNames(lapply(distributions, function(d) {
    fitdist(vec, d, method=method, ...)
  }), distributions)
}

# We can evaluate them one at a time:
fit_then_compplot <- function(gr, method="mle", distributions=c("nbinom", "pois", "lnorm", "norm", "exp", "gamma", "llogis", "weibull"), fitlwd=0.5, fitpch=16, ...) {
  srl <- gr |> strand() |> runLength() |> as.numeric()
  f <- fit_distributions(srl, distributions=distributions, method=method, ...)
  p1 <- denscomp(f, plotstyle='ggplot', addlegend = F, fitlwd = fitlwd)
  p2 <- qqcomp(  f, plotstyle='ggplot', addlegend = T, fitpch=fitpch)
  p3 <- cdfcomp( f, plotstyle='ggplot', addlegend = F, fitlwd = fitlwd) + theme_grey() + theme(legend.position='none')
  p4 <- ppcomp(  f, plotstyle='ggplot', addlegend = T, fitpch=fitpch)
  (p1 | p2 ) / ( p3 | p4)
}

# You can evaluate the different models graphically. These plots are a little busy, though.
fit_then_compplot(gbs$Oki_Osa)
fit_then_compplot(gbs$Oki_Bar)
fit_then_compplot(gbs$Osa_Bar)
fit_then_compplot(gbs$Oki_Kum)


# Obtain goodness-of-fit statistics for each model to see which fits data best.
# Then we can use the best-fitting model as a probability distribution to randomly
# induce a realistic number of "flips", generating a randomly-flipped GBreaks object.
(gbs$Oki_Osa |> strand() |> runLength() |> as.numeric() |> fit_distributions(method="mle") |> gofstat())
(gbs$Oki_Bar |> strand() |> runLength() |> as.numeric() |> fit_distributions(method="mle") |> gofstat())
(gbs$Osa_Bar |> strand() |> runLength() |> as.numeric() |> fit_distributions(method="mle") |> gofstat())
(gbs$Oki_Kum |> strand() |> runLength() |> as.numeric() |> fit_distributions(method="mle") |> gofstat())


# Similar to the above, but only plots the comparisons.
just_compplot <- function(cpl, method="mle", distributions=c("nbinom", "pois", "lnorm", "norm", "exp", "gamma", "llogis", "weibull"), fitlwd=0.5, fitpch=16, ...) {
  p1 <- denscomp(cpl, plotstyle='ggplot', addlegend = F, fitlwd = fitlwd)
  p2 <- qqcomp(  cpl, plotstyle='ggplot', addlegend = T, fitpch=fitpch)
  p3 <- cdfcomp( cpl, plotstyle='ggplot', addlegend = F, fitlwd = fitlwd) + theme_grey() + theme(legend.position='none')
  p4 <- ppcomp(  cpl, plotstyle='ggplot', addlegend = T, fitpch=fitpch)
  (p1 | p2 ) / ( p3 | p4)
}

# Now that there is some indication that log-normal is the best distribution for making
# models, we can try different fitting methods, selecting the best from among them.
# The available fitting methdos include:
#  mle - maximum likelihood estimation
#  mge - maximum goodness-of-fit
#  mme - moment matching
#  mse - maximum spacing estimation
# 
# MGE has a number of methods available. Sometimes the plots are too complicated, so you can remove them.
#   c('mge_cvm', 'mge_ks', 'mge_ad', 'mge_adr', 'mge_adl', 'mge_ad2r', 'mge_ad2l', 'mge_ad2')
fit_methods <- function(vec, distribution="lnorm", includeMethods=c('mle', 'mge', 'mme', 'mse'), excludeMethods=NULL ) {
  m <- list()
  if('mle' %in% includeMethods){
    m <- append(m, list('mle'=fitdist(vec, distribution, method='mle')))
  }
  if('mge' %in% includeMethods){
    m <- append(m, list(
          'mge_cvm'=fitdist(vec, distribution, method='mge', gof='CvM'),
          'mge_ks'=fitdist(vec, distribution, method='mge', gof='KS'),
          'mge_ad'=fitdist(vec, distribution, method='mge', gof='AD'),
          'mge_adr'=fitdist(vec, distribution, method='mge', gof='ADR'),
          'mge_adl'=fitdist(vec, distribution, method='mge', gof='ADL'),
          'mge_ad2r'=fitdist(vec, distribution, method='mge', gof='AD2R'),
          'mge_ad2l'=fitdist(vec, distribution, method='mge', gof='AD2L'),
          'mge_ad2'=fitdist(vec, distribution, method='mge', gof='AD2')
          )
        )
  }
  if('mme' %in% includeMethods){
    m <- append(m, list('mme'=fitdist(vec, distribution, method='mme')))
  }
  if('mse' %in% includeMethods){
    m <- append(m, list('mse'=fitdist(vec, distribution, method='mse')))
  }
  m <- m[! names(m) %in% excludeMethods]
  m
}
c_oki_osa <- gbs$Oki_Osa |> strand() |> runLength() |> as.numeric() |> fit_methods()
c_oki_osa |> just_compplot()
c_oki_osa |> gofstat()

# As above, but for optimization testing.
fit_optims <- function(vec, distribution="lnorm", method='mle', maxit=10000, ...) {
  list('nelder_mead'=fitdist(vec, distribution, optim.method='Nelder-Mead', method=method, ...),
       'bfgs'=fitdist(vec, distribution, optim.method='BFGS', method=method, ...),
       'sann'=fitdist(vec, distribution, optim.method='SANN', method=method, ...),
       'cg'=fitdist(vec, distribution,   optim.method='CG', control=list(maxit=maxit), method=method, ...)
   )
}
o_oki_osa <- gbs$Oki_Osa |> strand() |> runLength() |> as.numeric() |> fit_optims()
o_oki_osa |> just_compplot()
o_oki_osa |> gofstat()


# Based on the results above, it seems that the best fits are MLE, MGE-ADR, and MGE-ADL.
gbs$Oki_Osa |> strand() |> runLength() |> as.numeric() |> fit_methods(excludeMethods = c('mse', 'mme', 'mge_cvm', 'mge_ks', 'mge_ad', 'mge_ad2r', 'mge_ad2l', 'mge_ad', 'mge_ad2') ) |> just_compplot()
# Just to be clear, let's check them out.
# ADL consistently underestimates the sizes. 
gbs$Oki_Osa |> strand() |> runLength() |> as.numeric() |> fit_methods(excludeMethods = c('mse', 'mme', 'mge_cvm', 'mge_ks', 'mge_ad', 'mge_ad2r', 'mge_ad2l', 'mge_ad', 'mge_ad2', 'mge_adr', 'mle') ) |> just_compplot()
# ADR overestimates sizes.
gbs$Oki_Osa |> strand() |> runLength() |> as.numeric() |> fit_methods(excludeMethods = c('mse', 'mme', 'mge_cvm', 'mge_ks', 'mge_ad', 'mge_ad2r', 'mge_ad2l', 'mge_ad', 'mge_ad2', 'mge_adl', 'mle') ) |> just_compplot()

# ADL and MLE are very close.
gbs$Oki_Osa |> strand() |> runLength() |> as.numeric() |> fit_methods(excludeMethods = c('mse', 'mme', 'mge_cvm', 'mge_ks', 'mge_ad', 'mge_ad2r', 'mge_ad2l', 'mge_ad', 'mge_ad2', 'mge_adr') ) |> just_compplot()

# All 3 agree that a log-normal distribution is the best fit to describe the run length distribution.
# Use this to generate randomly-generated GRanges.
randomly_flip_strand <- function(gr, times=1e4, seed=1992, threads=1, distribution="lnorm", method="mle", optim.method='Nelder-Mead',  ...) {
  # Fit the strand run length to a given distribution.
  fit <- gr |> strand() |> runLength() |> as.numeric() |> fit_distributions(distributions = distribution, method=method, optim.method=optim.method, ...)
  fit <- fit[[1]]
  
  # Make a phony GRanges (with the same dimensions as input) where all strands are positive.
  # Then iteratively flip them according to the probability of a flip.
  phony_gr <- gr
  strand(phony_gr) <- "+"

  # Flip a GRanges according to a probability distribution.
  # We fit the strand run length to a distribution above. Then, use the estimated parameters of the
  # fitted distribution to generate values (i.e., segments of length N), continuing until the length
  # of all segments equals the length of the original GRanges. Then re-write the strand information
  # according to the segments.
  generate_random_strand <- function(gr, distribution, coef, child.seed) {
    set.seed(child.seed)
    total_length <- length(gr)
    current_strand <- numeric()
    while(sum(current_strand) < total_length){
      # Get distribution function by distribution name
      # "nbinom", "pois", "lnorm", "norm", "exp", "gamma", "llogis", "weibull"
      if(distribution=="nbinom"){
        dist_fun <- rnbinom
        sel <- rnbinom(n=1, coef) |> ceiling()
      } else if(distribution == "pois") {
        dist_fun <- rpois
        sel <- rpois(n=1, coef) |> ceiling()
      } else if(distribution == "lnorm") {
        dist_fun <- rlnorm
        sel <- rlnorm(n=1, coef) |> ceiling()
      } else if(distribution == "norm" ){
        dist_fun <- rnorm
        sel <- rnorm(n=1, coef) |> ceiling()
      } else if(distribution == "exp") {
        dist_fun <- rexp
        sel <- rexp(n=1, coef) |> ceiling()
      } else if(distribution == "gamma"){
        dist_fun <- rgamma
        sel <- rgamma(n=1, coef) |> ceiling()
      } else if(distribution == "llogis"){
        dist_fun <- rlogis
        sel <- rlogis(n=1, coef) |> ceiling()
      } else if(distribution == "weibull"){
        dist_fun <- rweibull
        sel <- rweibull(n=1, coef) |> ceiling()
      } else {
        cat(paste0("Error. Unknown distribution: ", distribution, ". Not sure what function to match to?\n"))
        stop()
      }
      current_strand <- c(current_strand, sel)
      #current_strand <- c(current_strand, ceiling(dist_fun(coef)) )
    }

    # If the length of the generated strand is greater than the length of the GRanges,
    # correct the last item so that they are exactly equal in size.
    if(sum(current_strand) > total_length ) {
      # Shave off elements from the end until the random strand's length sum is smaller or equal to GRange length
      while(sum(current_strand) > total_length){
        current_strand <- head(current_strand, n=-1)
      }
      # If they are not equal, add a new one equal to the difference
      if(sum(current_strand) != total_length){
        current_strand <- c(current_strand, total_length-sum(current_strand) )
      }
      
    }
    current_strand
  }
  
  random_strand_to_gr <- function(gr, random_strand, child.seed) {
    # Make a strandless GRanges first. We'll replace the strand later.
    stripped_gr <- gr
    strand(stripped_gr) <- "*"
    
    # Determine whether the first block of the randomized strand is "+" or "-" strand.
    set.seed(child.seed)
    coin_flip <- rnorm(1)
    strand_length <- length(random_strand)
    if(coin_flip>=0) {
      strand(stripped_gr) <- strand(Rle(values=head(rep(c("+", "-"), times=length(random_strand)), n=length(random_strand)), lengths = random_strand))
    } else {
      strand(stripped_gr) <- strand(Rle(values=head(rep(c("-", "+"), times=length(random_strand)), n=length(random_strand)), lengths = random_strand))
    }
    stripped_gr
  }
  # Use seed argument to generate a number of random seeds for further simulations
  set.seed(seed)
  child.seeds <- sample(x=times*10, size = times, replace = F)
  
  randomized_strands <- mclapply(mc.cores=threads, 1:times, function(x) {
  #randomized_strands <- lapply(1:times, function(x) {
    randomized_strand <- generate_random_strand(gr=gr, distribution=distribution, coef=coef(fit), child.seed=child.seeds[x])
    randomized_strand_gr <- random_strand_to_gr(gr=gr, random_strand = randomized_strand, child.seed=child.seeds[x])
    sri <- strand_randomisation_index(randomized_strand_gr)
    sri
  }) |> unlist()
  randomized_strands
}
randomly_flip_strand(gbs$Oki_Osa, times=10)


# Make some plots comparing random strand randomisation indices to the observed values.
randomly_flip_strand(gbs$Oki_Osa, times=1000, threads=4, method='mle') |> hist(xlim=c(0,0.1), main="Oki-Osa: Histogram of random run length SRIs (MLE)", xlab='run length') |> abline(v=strand_randomisation_index(gbs$Oki_Osa), col='darkred') |> text(x=strand_randomisation_index(gbs$Oki_Osa), y=150,  label="overall", col='darkred') |> abline( v=gbs$Oki_Osa |> plyranges::filter(Arm=="short") |> strand_randomisation_index(), lty=3, col='#595959'  ) |> text(x=gbs$Oki_Osa |> plyranges::filter(Arm=="short") |> strand_randomisation_index(), y=150,  label="short", col='#595959') |> abline( v=gbs$Oki_Osa |> plyranges::filter(Arm=="long") |> strand_randomisation_index(), lty=3, col='#595959'  )  |> text(x=gbs$Oki_Osa |> plyranges::filter(Arm=="long") |> strand_randomisation_index(), y=150, label="long", col='#595959')

check_arm_rl_variance <- list(
  overall1=unlist(randomly_flip_strand(gbs$Oki_Osa, times=500, threads=4, method='mle', seed = 1234)),
  short1=unlist(randomly_flip_strand(gbs$Oki_Osa |> plyranges::filter(Arm=="short"), times=500, threads=4, method='mle', seed = 1234)),
  long1=unlist(randomly_flip_strand(gbs$Oki_Osa |> plyranges::filter(Arm=="long"), times=500, threads=4, method='mle', seed = 1234)), 
  
  overall2=unlist(randomly_flip_strand(gbs$Oki_Osa, times=500, threads=4, method='mle', seed = 4321)),
  short2=unlist(randomly_flip_strand(gbs$Oki_Osa |> plyranges::filter(Arm=="short"), times=500, threads=4, method='mle', seed = 4321)),
  long2=unlist(randomly_flip_strand(gbs$Oki_Osa |> plyranges::filter(Arm=="long"), times=500, threads=4, method='mle', seed = 4321)),
  
  overall3=unlist(randomly_flip_strand(gbs$Oki_Osa, times=500, threads=4, method='mle', seed = 6789)),
  short3=unlist(randomly_flip_strand(gbs$Oki_Osa |> plyranges::filter(Arm=="short"), times=500, threads=4, method='mle', seed = 6789)),
  long3=unlist(randomly_flip_strand(gbs$Oki_Osa |> plyranges::filter(Arm=="long"), times=500, threads=4, method='mle', seed = 6789)), 
  
  overall4=unlist(randomly_flip_strand(gbs$Oki_Osa, times=500, threads=4, method='mle', seed = 9876)),
  short4=unlist(randomly_flip_strand(gbs$Oki_Osa |> plyranges::filter(Arm=="short"), times=500, threads=4, method='mle', seed = 9876)),
  long4=unlist(randomly_flip_strand(gbs$Oki_Osa |> plyranges::filter(Arm=="long"), times=500, threads=4, method='mle', seed = 9876)),
  
  overall5=unlist(randomly_flip_strand(gbs$Oki_Osa, times=500, threads=4, method='mle', seed = 4567)),
  short5=unlist(randomly_flip_strand(gbs$Oki_Osa |> plyranges::filter(Arm=="short"), times=500, threads=4, method='mle', seed = 4567)),
  long5=unlist(randomly_flip_strand(gbs$Oki_Osa |> plyranges::filter(Arm=="long"), times=500, threads=4, method='mle', seed = 4567)) 
)

# Turn above list into a DF
check_arm_rl_variance_df <- do.call(rbind, lapply(names(check_arm_rl_variance), function(n) {
  cbind(n, check_arm_rl_variance[[n]])
} )) |> as.data.frame() |> dplyr::rename(strand_randomisation_index=V2)

check_arm_rl_variance_df$category <- sapply(check_arm_rl_variance_df$n, function(x) unlist(strsplit(x, '[[:digit:]]'))) |> unlist() |> unname()

ggplot(check_arm_rl_variance_df) +
  aes(x=as.numeric(strand_randomisation_index), fill=category) +
  
  geom_vline(xintercept = strand_randomisation_index(gbs$Oki_Osa), lwd=0.5, lty=3, col='#595959') +
  annotate("label", x=strand_randomisation_index(gbs$Oki_Osa), y=160, label="overall") + 
  
  geom_vline(xintercept = strand_randomisation_index(gbs$Oki_Osa |> plyranges::filter(Arm=="long")), lwd=0.5, lty=3, col='#595959') +
  annotate("label", x=strand_randomisation_index(gbs$Oki_Osa |> plyranges::filter(Arm=="long")), y=130, label="long") + 
  
  geom_vline(xintercept = strand_randomisation_index(gbs$Oki_Osa |> plyranges::filter(Arm=="short")), lwd=0.5, lty=3, col='#595959') +
  annotate("label", x=strand_randomisation_index(gbs$Oki_Osa |> plyranges::filter(Arm=="short")), y=130, label="short") + 
  
  geom_histogram() +
  ylim(c(0, 180)) + 
  facet_wrap(~n, nrow=3)



# Osa-Bar
randomly_flip_strand(gbs$Osa_Bar, times=1000, threads=4, method='mle') |> unlist() |> hist(xlim=c(0,1), main="Osa-Bar: Histogram of random run length SRIs (MLE)", xlab='run length') |> abline(v=strand_randomisation_index(gbs$Osa_Bar), col='darkred') |> text(x=strand_randomisation_index(gbs$Osa_Bar), y=150,  label="overall", col='darkred') |> abline( v=gbs$Osa_Bar |> plyranges::filter(Arm=="short") |> strand_randomisation_index(), lty=3, col='#595959'  ) |> text(x=gbs$Osa_Bar |> plyranges::filter(Arm=="short") |> strand_randomisation_index(), y=150,  label="short", col='#595959') |> abline( v=gbs$Osa_Bar |> plyranges::filter(Arm=="long") |> strand_randomisation_index(), lty=3, col='#595959'  )  |> text(x=gbs$Osa_Bar |> plyranges::filter(Arm=="long") |> strand_randomisation_index(), y=150, label="long", col='#595959')

detach('package:fitdistrplus')
detach('package:survival')
detach('package:actuar')
detach('package:distrMod')
detach('package:ggplotify')
detach('package:patchwork')
```

## Strand randomisation index bootstrap tests

Another way to assess the stability of the strand randomisation index is with bootstrapping, by removing some percentage of the underlying data and measuring how variable the index is.

```{r strand_randomisation_index_boot}
gr_boot <- function(gr, seed=1992, keep=0.9){
  set.seed <- seed
  gr_indices <- 1:length(gr)
  gr_keep <- sample(gr_indices, keep*length(gr), replace = F)
  gr <- gr[gr_keep] |> sort()
  gr
}
#gr_boot(gbs$Oki_Osa)

run_sri_bootstraps <- function(gr, seed=1992, n=1000, keep=0.9, threads=1){
  set.seed(seed)
  child.seeds <- sample(x=n*10, size = n, replace = F)
  sri_boot <- mclapply(mc.cores=threads, 1:length(child.seeds), function(s) {
    seed <- child.seeds[s]
    boot_gr <- gr_boot(gr, seed=seed, keep=keep)
    sri <- strand_randomisation_index(boot_gr)
    sri
  }) |> unlist()
  sri_boot
}
#run_sri_bootstraps(gbs$Oki_Osa, seed=1992, n=10, keep=0.9) |> hist()

run_sri_bootstraps_reps <- function(gr, seed=1992, n=1000, keep=0.9, threads=1, replicates=3) {
  set.seed(seed)
  child.seeds <- sample(x=replicates*10, size = replicates, replace = F)
  reps <- lapply(1:replicates, function(r){
    run_sri_bootstraps(gr, seed=child.seeds[r], n=n, keep=keep, threads=threads)
  })
  names(reps) <- paste0("rep", 1:replicates)
  reps
}

run_boots_across_arms <- function(gr, seed=1992, num_boots=100, threads=1, replicates=3) {
  rbind(
    run_sri_bootstraps_reps(gr, seed=seed, n=num_boots, threads=threads, replicates=replicates, keep=0.9) |> as.data.frame() |> tidyr::pivot_longer(cols=paste0('rep', 1:3), names_to='rep', values_to='strand_randomisation_index') |> dplyr::mutate(keep_fraction="0.9", arm='all'),
    run_sri_bootstraps_reps(gr, seed=seed, n=num_boots, threads=threads, replicates=replicates, keep=0.8) |> as.data.frame() |> tidyr::pivot_longer(cols=paste0('rep', 1:3), names_to='rep', values_to='strand_randomisation_index') |> dplyr::mutate(keep_fraction="0.8", arm='all'),
    run_sri_bootstraps_reps(gr, seed=seed, n=num_boots, threads=threads, replicates=replicates, keep=0.7) |> as.data.frame() |> tidyr::pivot_longer(cols=paste0('rep', 1:3), names_to='rep', values_to='strand_randomisation_index') |> dplyr::mutate(keep_fraction="0.7", arm='all'),
    run_sri_bootstraps_reps(gr, seed=seed, n=num_boots, threads=threads, replicates=replicates, keep=0.6) |> as.data.frame() |> tidyr::pivot_longer(cols=paste0('rep', 1:3), names_to='rep', values_to='strand_randomisation_index') |> dplyr::mutate(keep_fraction="0.6", arm='all'),
    run_sri_bootstraps_reps(gr, seed=seed, n=num_boots, threads=threads, replicates=replicates, keep=0.5) |> as.data.frame() |> tidyr::pivot_longer(cols=paste0('rep', 1:3), names_to='rep', values_to='strand_randomisation_index') |> dplyr::mutate(keep_fraction="0.5", arm='all'),
    
    run_sri_bootstraps_reps(gr |> plyranges::filter(Arm=="short"), seed=seed, n=num_boots, threads=threads, replicates=replicates, keep=0.9) |> as.data.frame() |> tidyr::pivot_longer(cols=paste0('rep', 1:3), names_to='rep', values_to='strand_randomisation_index') |> dplyr::mutate(keep_fraction="0.9", arm='short'),
    run_sri_bootstraps_reps(gr |> plyranges::filter(Arm=="short"), seed=seed, n=num_boots, threads=threads, replicates=replicates, keep=0.8) |> as.data.frame() |> tidyr::pivot_longer(cols=paste0('rep', 1:3), names_to='rep', values_to='strand_randomisation_index') |> dplyr::mutate(keep_fraction="0.8", arm='short'),
    run_sri_bootstraps_reps(gr |> plyranges::filter(Arm=="short"), seed=seed, n=num_boots, threads=threads, replicates=replicates, keep=0.7) |> as.data.frame() |> tidyr::pivot_longer(cols=paste0('rep', 1:3), names_to='rep', values_to='strand_randomisation_index') |> dplyr::mutate(keep_fraction="0.7", arm='short'),
    run_sri_bootstraps_reps(gr |> plyranges::filter(Arm=="short"), seed=seed, n=num_boots, threads=threads, replicates=replicates, keep=0.6) |> as.data.frame() |> tidyr::pivot_longer(cols=paste0('rep', 1:3), names_to='rep', values_to='strand_randomisation_index') |> dplyr::mutate(keep_fraction="0.6", arm='short'),
    run_sri_bootstraps_reps(gr |> plyranges::filter(Arm=="short"), seed=seed, n=num_boots, threads=threads, replicates=replicates, keep=0.5) |> as.data.frame() |> tidyr::pivot_longer(cols=paste0('rep', 1:3), names_to='rep', values_to='strand_randomisation_index') |> dplyr::mutate(keep_fraction="0.5", arm='short'),
    
    run_sri_bootstraps_reps(gr |> plyranges::filter(Arm=="long"), seed=seed, n=num_boots, threads=threads, replicates=replicates, keep=0.9) |> as.data.frame() |> tidyr::pivot_longer(cols=paste0('rep', 1:3), names_to='rep', values_to='strand_randomisation_index') |> dplyr::mutate(keep_fraction="0.9", arm='long'),
    run_sri_bootstraps_reps(gr |> plyranges::filter(Arm=="long"), seed=seed, n=num_boots, threads=threads, replicates=replicates, keep=0.8) |> as.data.frame() |> tidyr::pivot_longer(cols=paste0('rep', 1:3), names_to='rep', values_to='strand_randomisation_index') |> dplyr::mutate(keep_fraction="0.8", arm='long'),
    run_sri_bootstraps_reps(gr |> plyranges::filter(Arm=="long"), seed=seed, n=num_boots, threads=threads, replicates=replicates, keep=0.7) |> as.data.frame() |> tidyr::pivot_longer(cols=paste0('rep', 1:3), names_to='rep', values_to='strand_randomisation_index') |> dplyr::mutate(keep_fraction="0.7", arm='long'),
    run_sri_bootstraps_reps(gr |> plyranges::filter(Arm=="long"), seed=seed, n=num_boots, threads=threads, replicates=replicates, keep=0.6) |> as.data.frame() |> tidyr::pivot_longer(cols=paste0('rep', 1:3), names_to='rep', values_to='strand_randomisation_index') |> dplyr::mutate(keep_fraction="0.6", arm='long'),
    run_sri_bootstraps_reps(gr |> plyranges::filter(Arm=="long"), seed=seed, n=num_boots, threads=threads, replicates=replicates, keep=0.5) |> as.data.frame() |> tidyr::pivot_longer(cols=paste0('rep', 1:3), names_to='rep', values_to='strand_randomisation_index') |> dplyr::mutate(keep_fraction="0.5", arm='long'),
    
        
    run_sri_bootstraps_reps(gr |> plyranges::filter(Arm=="XSR"), seed=seed, n=num_boots, threads=threads, replicates=replicates, keep=0.9) |> as.data.frame() |> tidyr::pivot_longer(cols=paste0('rep', 1:3), names_to='rep', values_to='strand_randomisation_index') |> dplyr::mutate(keep_fraction="0.9", arm='XSR'),
    run_sri_bootstraps_reps(gr |> plyranges::filter(Arm=="XSR"), seed=seed, n=num_boots, threads=threads, replicates=replicates, keep=0.8) |> as.data.frame() |> tidyr::pivot_longer(cols=paste0('rep', 1:3), names_to='rep', values_to='strand_randomisation_index') |> dplyr::mutate(keep_fraction="0.8", arm='XSR'),
    run_sri_bootstraps_reps(gr |> plyranges::filter(Arm=="XSR"), seed=seed, n=num_boots, threads=threads, replicates=replicates, keep=0.7) |> as.data.frame() |> tidyr::pivot_longer(cols=paste0('rep', 1:3), names_to='rep', values_to='strand_randomisation_index') |> dplyr::mutate(keep_fraction="0.7", arm='XSR'),
    run_sri_bootstraps_reps(gr |> plyranges::filter(Arm=="XSR"), seed=seed, n=num_boots, threads=threads, replicates=replicates, keep=0.6) |> as.data.frame() |> tidyr::pivot_longer(cols=paste0('rep', 1:3), names_to='rep', values_to='strand_randomisation_index') |> dplyr::mutate(keep_fraction="0.6", arm='XSR'),
    run_sri_bootstraps_reps(gr |> plyranges::filter(Arm=="XSR"), seed=seed, n=num_boots, threads=threads, replicates=replicates, keep=0.5) |> as.data.frame() |> tidyr::pivot_longer(cols=paste0('rep', 1:3), names_to='rep', values_to='strand_randomisation_index') |> dplyr::mutate(keep_fraction="0.5", arm='XSR')
  )
}

num_boots <- 100
boots_across_arms <- SimpleList()
# Oki-Osa
boots_across_arms$Oki_Osa <- run_boots_across_arms(gbs$Oki_Osa, num_boots = num_boots, threads=4, replicates=3)
boots_across_arms$Oki_Osa |> ggplot() + aes(x=keep_fraction, y=strand_randomisation_index, fill=rep) + facet_wrap(~arm, nrow=1) + geom_boxplot() + ggtitle(paste0("Oki-Osa: Bootstrap stability of strand randomisation index (n=", num_boots, ")"))

# Oki-Bar
boots_across_arms$Oki_Bar <- run_boots_across_arms(gbs$Oki_Bar, num_boots = num_boots, threads=4, replicates=3)
boots_across_arms$Oki_Bar |> ggplot() + aes(x=keep_fraction, y=strand_randomisation_index, fill=rep) + facet_wrap(~arm, nrow=1) + geom_boxplot() + ggtitle(paste0("Oki-Osa: Bootstrap stability of strand randomisation index (n=", num_boots, ")"))

# Osa-Bar
boots_across_arms$Osa_Bar <- run_boots_across_arms(gbs$Osa_Bar, num_boots = num_boots, threads=4, replicates=3)
boots_across_arms$Osa_Bar |> ggplot() + aes(x=keep_fraction, y=strand_randomisation_index, fill=rep) + facet_wrap(~arm, nrow=1) + geom_boxplot() + ggtitle(paste0("Osa-Bar: Bootstrap stability of strand randomisation index (n=", num_boots, ")"))

# Oki-Kum
boots_across_arms$Oki_Kum <- run_boots_across_arms(gbs$Oki_Kum, num_boots = num_boots, threads=4, replicates=3)
boots_across_arms$Oki_Kum |> ggplot() + aes(x=keep_fraction, y=strand_randomisation_index, fill=rep) + facet_wrap(~arm, nrow=1) + geom_boxplot() + ggtitle(paste0("Oki-Kum: Bootstrap stability of strand randomisation index (n=", num_boots, ")"))

```

## Strand randomisation bootstrap-flipping
As above, but instead of randomly subsetting a `GBreaks` before caculating SRI, instead randomly flip some proportion of it, then calculate SRI.

```{r strand_randomisation_index_boot}
flip_strand <- function(strand_rle) {
  runValues <- runValue(strand_rle)
  runLengths <- runLength(strand_rle)
  flipped_strand <- as.character(runValue(strand_rle))
  flipped_strand <- gsub("\\+", "F", flipped_strand)
  flipped_strand <- gsub("\\-", "+", flipped_strand)
  flipped_strand <- gsub("F", "-", flipped_strand)
  flipped_strand <- Rle(factor(flipped_strand, levels=c("+", "-", "*")), lengths = runLengths)
  flipped_strand
} 
# flip_strand(head(strand(gbs$Oki_Osa)))

gr_boot_flipper <- function(gr, seed=1992, flip=0.01){
  set.seed(seed)
  gr_indices <- 1:length(gr)
  gr_to_flip <- sample(gr_indices, flip*length(gr), replace = F) |> sort()
  strand(gr[gr_to_flip]) <- flip_strand(strand(gr[gr_to_flip]))
  gr
}
# gbs$Oki_Osa[strand(gbs$Oki_Osa) != strand(gr_boot_flipper(gbs$Oki_Osa, seed=1992))]

run_sri_flip_bootstraps <- function(gr, seed=1992, n=1000, flip=0.01, threads=1){
  set.seed(seed)
  child.seeds <- sample(x=n*10, size=n, replace=F)
  sri_boot <- mclapply(mc.cores=threads, 1:length(child.seeds), function(s) {
    seed <- child.seeds[s]
    boot_gr <- gr_boot_flipper(gr, seed=seed, flip=flip)
    sri <- strand_randomisation_index(boot_gr)
    sri
  }) |> unlist()
  sri_boot
}
#run_sri_flip_bootstraps(gbs$Oki_Osa, seed=1992, n=10, flip=0.01, threads=1)


run_sri_flip_bootstraps_reps <- function(gr, seed=1992, n=1000, flip=0.01, threads=1, replicates=3) {
  set.seed(seed)
  child.seeds <- sample(x=n*10, size=n, replace=F)
  reps <- lapply(1:replicates, function(r){
    run_sri_flip_bootstraps(gr, seed=child.seeds[r], n=n, flip=flip, threads=threads)
  })
  names(reps) <- paste0("rep", 1:replicates)
  reps
}
# run_sri_flip_bootstraps_reps(gbs$Oki_Osa, seed=1992, n=10, flip=0.01, threads=1, replicates=3)


run_flip_boots_across_arms <- function(gr, seed=1992, num_boots=100, threads=1, replicates=3) {
  rbind(
    run_sri_flip_bootstraps_reps(gr, seed=seed, n=num_boots, threads=threads, replicates=replicates, flip=0.01) |> as.data.frame() |> tidyr::pivot_longer(cols=paste0('rep', 1:3), names_to='rep', values_to='strand_randomisation_index') |> dplyr::mutate(flip_fraction="0.01", arm='all'),
    run_sri_flip_bootstraps_reps(gr, seed=seed, n=num_boots, threads=threads, replicates=replicates, flip=0.05) |> as.data.frame() |> tidyr::pivot_longer(cols=paste0('rep', 1:3), names_to='rep', values_to='strand_randomisation_index') |> dplyr::mutate(flip_fraction="0.05", arm='all'),
    run_sri_flip_bootstraps_reps(gr, seed=seed, n=num_boots, threads=threads, replicates=replicates, flip=0.10) |> as.data.frame() |> tidyr::pivot_longer(cols=paste0('rep', 1:3), names_to='rep', values_to='strand_randomisation_index') |> dplyr::mutate(flip_fraction="0.10", arm='all'),
    run_sri_flip_bootstraps_reps(gr, seed=seed, n=num_boots, threads=threads, replicates=replicates, flip=0.25) |> as.data.frame() |> tidyr::pivot_longer(cols=paste0('rep', 1:3), names_to='rep', values_to='strand_randomisation_index') |> dplyr::mutate(flip_fraction="0.25", arm='all'),
    run_sri_flip_bootstraps_reps(gr, seed=seed, n=num_boots, threads=threads, replicates=replicates, flip=0.50) |> as.data.frame() |> tidyr::pivot_longer(cols=paste0('rep', 1:3), names_to='rep', values_to='strand_randomisation_index') |> dplyr::mutate(flip_fraction="0.50", arm='all'),
    
    run_sri_flip_bootstraps_reps(gr |> plyranges::filter(Arm=="short"), seed=seed, n=num_boots, threads=threads, replicates=replicates, flip=0.01) |> as.data.frame() |> tidyr::pivot_longer(cols=paste0('rep', 1:3), names_to='rep', values_to='strand_randomisation_index') |> dplyr::mutate(flip_fraction="0.01", arm='short'),
    run_sri_flip_bootstraps_reps(gr |> plyranges::filter(Arm=="short"), seed=seed, n=num_boots, threads=threads, replicates=replicates, flip=0.05) |> as.data.frame() |> tidyr::pivot_longer(cols=paste0('rep', 1:3), names_to='rep', values_to='strand_randomisation_index') |> dplyr::mutate(flip_fraction="0.05", arm='short'),
    run_sri_flip_bootstraps_reps(gr |> plyranges::filter(Arm=="short"), seed=seed, n=num_boots, threads=threads, replicates=replicates, flip=0.10) |> as.data.frame() |> tidyr::pivot_longer(cols=paste0('rep', 1:3), names_to='rep', values_to='strand_randomisation_index') |> dplyr::mutate(flip_fraction="0.10", arm='short'),
    run_sri_flip_bootstraps_reps(gr |> plyranges::filter(Arm=="short"), seed=seed, n=num_boots, threads=threads, replicates=replicates, flip=0.25) |> as.data.frame() |> tidyr::pivot_longer(cols=paste0('rep', 1:3), names_to='rep', values_to='strand_randomisation_index') |> dplyr::mutate(flip_fraction="0.25", arm='short'),
    run_sri_flip_bootstraps_reps(gr |> plyranges::filter(Arm=="short"), seed=seed, n=num_boots, threads=threads, replicates=replicates, flip=0.50) |> as.data.frame() |> tidyr::pivot_longer(cols=paste0('rep', 1:3), names_to='rep', values_to='strand_randomisation_index') |> dplyr::mutate(flip_fraction="0.50", arm='short'),
    
    run_sri_flip_bootstraps_reps(gr |> plyranges::filter(Arm=="long"), seed=seed, n=num_boots, threads=threads, replicates=replicates, flip=0.01) |> as.data.frame() |> tidyr::pivot_longer(cols=paste0('rep', 1:3), names_to='rep', values_to='strand_randomisation_index') |> dplyr::mutate(flip_fraction="0.01", arm='long'),
    run_sri_flip_bootstraps_reps(gr |> plyranges::filter(Arm=="long"), seed=seed, n=num_boots, threads=threads, replicates=replicates, flip=0.05) |> as.data.frame() |> tidyr::pivot_longer(cols=paste0('rep', 1:3), names_to='rep', values_to='strand_randomisation_index') |> dplyr::mutate(flip_fraction="0.05", arm='long'),
    run_sri_flip_bootstraps_reps(gr |> plyranges::filter(Arm=="long"), seed=seed, n=num_boots, threads=threads, replicates=replicates, flip=0.10) |> as.data.frame() |> tidyr::pivot_longer(cols=paste0('rep', 1:3), names_to='rep', values_to='strand_randomisation_index') |> dplyr::mutate(flip_fraction="0.10", arm='long'),
    run_sri_flip_bootstraps_reps(gr |> plyranges::filter(Arm=="long"), seed=seed, n=num_boots, threads=threads, replicates=replicates, flip=0.25) |> as.data.frame() |> tidyr::pivot_longer(cols=paste0('rep', 1:3), names_to='rep', values_to='strand_randomisation_index') |> dplyr::mutate(flip_fraction="0.25", arm='long'),
    run_sri_flip_bootstraps_reps(gr |> plyranges::filter(Arm=="long"), seed=seed, n=num_boots, threads=threads, replicates=replicates, flip=0.50) |> as.data.frame() |> tidyr::pivot_longer(cols=paste0('rep', 1:3), names_to='rep', values_to='strand_randomisation_index') |> dplyr::mutate(flip_fraction="0.50", arm='long'),
    
    
    run_sri_flip_bootstraps_reps(gr |> plyranges::filter(Arm=="XSR"), seed=seed, n=num_boots, threads=threads, replicates=replicates, flip=0.01) |> as.data.frame() |> tidyr::pivot_longer(cols=paste0('rep', 1:3), names_to='rep', values_to='strand_randomisation_index') |> dplyr::mutate(flip_fraction="0.01", arm='XSR'),
    run_sri_flip_bootstraps_reps(gr |> plyranges::filter(Arm=="XSR"), seed=seed, n=num_boots, threads=threads, replicates=replicates, flip=0.05) |> as.data.frame() |> tidyr::pivot_longer(cols=paste0('rep', 1:3), names_to='rep', values_to='strand_randomisation_index') |> dplyr::mutate(flip_fraction="0.05", arm='XSR'),
    run_sri_flip_bootstraps_reps(gr |> plyranges::filter(Arm=="XSR"), seed=seed, n=num_boots, threads=threads, replicates=replicates, flip=0.10) |> as.data.frame() |> tidyr::pivot_longer(cols=paste0('rep', 1:3), names_to='rep', values_to='strand_randomisation_index') |> dplyr::mutate(flip_fraction="0.10", arm='XSR'),
    run_sri_flip_bootstraps_reps(gr |> plyranges::filter(Arm=="XSR"), seed=seed, n=num_boots, threads=threads, replicates=replicates, flip=0.25) |> as.data.frame() |> tidyr::pivot_longer(cols=paste0('rep', 1:3), names_to='rep', values_to='strand_randomisation_index') |> dplyr::mutate(flip_fraction="0.25", arm='XSR'),
    run_sri_flip_bootstraps_reps(gr |> plyranges::filter(Arm=="XSR"), seed=seed, n=num_boots, threads=threads, replicates=replicates, flip=0.50) |> as.data.frame() |> tidyr::pivot_longer(cols=paste0('rep', 1:3), names_to='rep', values_to='strand_randomisation_index') |> dplyr::mutate(flip_fraction="0.50", arm='XSR')
  )
}


# Oki-Osa
num_boots <- 100
flip_boots <- SimpleList()
flip_boots$Oki_Osa <- run_flip_boots_across_arms(gbs$Oki_Osa, seed=1234, num_boots = num_boots, replicates = 3, threads=6)
flip_boots$Oki_Osa |> ggplot() + aes(x=flip_fraction, y=strand_randomisation_index, fill=rep) + facet_wrap(~arm, nrow=1) + geom_boxplot() + ggtitle(paste0("Oki-Osa: Flip-bootstrap stability of strand randomisation index (n=", num_boots, ")"))

# Oki-Bar
flip_boots$Oki_Bar <- run_flip_boots_across_arms(gbs$Oki_Bar, seed=1234, num_boots = 100, replicates = 3, threads=6)
flip_boots$Oki_Bar |> ggplot() + aes(x=flip_fraction, y=strand_randomisation_index, fill=rep) + facet_wrap(~arm, nrow=1) + geom_boxplot() + ggtitle(paste0("Oki-Bar: Flip-bootstrap stability of strand randomisation index (n=", num_boots, ")"))

# Osa-Bar
flip_boots$Osa_Bar <- run_flip_boots_across_arms(gbs$Osa_Bar, seed=1234, num_boots = 100, replicates = 3, threads=6)
flip_boots$Osa_Bar |> ggplot() + aes(x=flip_fraction, y=strand_randomisation_index, fill=rep) + facet_wrap(~arm, nrow=1) + geom_boxplot() + ggtitle(paste0("Osa-Bar: Flip-bootstrap stability of strand randomisation index (n=", num_boots, ")"))

# Oki-Kum
flip_boots$Oki_Kum <- run_flip_boots_across_arms(gbs$Oki_Kum, seed=1234, num_boots = 100, replicates = 3, threads=6)
flip_boots$Oki_Kum |> ggplot() + aes(x=flip_fraction, y=strand_randomisation_index, fill=rep) + facet_wrap(~arm, nrow=1) + geom_boxplot() + ggtitle(paste0("Oki-Kum: Flip-bootstrap stability of strand randomisation index (n=", num_boots, ")"))



# Plots as above but with lines for the actual values
plot_sri_with_obs <- function(gr, flip_boots) {
  sri_lines <- data.frame(obs_sri=factor(c("overall", "long", "short"), levels=c('overall', 'long', 'short')),
                        start=c(0,0,0),
                        end=c(6,6,6),
                        lty=c(2,3,4),
                        col=c("#595959","#595959","#595959"),
                        y=c(strand_randomisation_index(gr),
                            strand_randomisation_index(gr |> plyranges::filter(Arm=="long")),
                            strand_randomisation_index(gr |> plyranges::filter(Arm=="short")))
                      )
  flip_boots |> ggplot() +
    aes(x=flip_fraction, y=strand_randomisation_index, fill=rep) +
    facet_wrap(~arm, nrow=1) +
    geom_blank() +
    geom_segment(data=sri_lines, inherit.aes=FALSE, aes(x=start, xend=end, y=y, yend=y, lty=obs_sri)) +
    geom_boxplot() +
    ylim(c(0, max(c(sri_lines$y, flip_boots$strand_randomisation_index))))

}
# Oki-Osa
plot_sri_with_obs(gbs$Oki_Osa, flip_boots$Oki_Osa) + ggtitle(paste0("Oki-Osa: Flip-bootstrap stability of strand randomisation index (n=", num_boots, ")"))
# Oki-Bar
plot_sri_with_obs(gbs$Oki_Bar, flip_boots$Oki_Bar) + ggtitle(paste0("Oki-Bar: Flip-bootstrap stability of strand randomisation index (n=", num_boots, ")"))
# Osa-Bar
plot_sri_with_obs(gbs$Osa_Bar, flip_boots$Osa_Bar) + ggtitle(paste0("Osa-Bar: Flip-bootstrap stability of strand randomisation index (n=", num_boots, ")"))
# Oki-Kum
plot_sri_with_obs(gbs$Oki_Kum, flip_boots$Oki_Kum) + ggtitle(paste0("Oki-Kum: Flip-bootstrap stability of strand randomisation index (n=", num_boots, ")"))
```

# Strand proportion index

Attempts to use pure proportions lead to scores drifting towards 0.5 when
comparing fragmented assemblies, as the fragments are not oriented.

```{r strand_proportion_index_def}
strand_proportion_index <- function(gb) {
  gbl <- split(gb, droplevels(seqnames(gb)))
  # Calculate an index for each sequence feature
  idx <- sapply(gbl, \(x) {
    onPlus  <- sum(width(x[strand(x) == '+']))
    onMinus <- sum(width(x[strand(x) == '-']))
    onPlus / (onPlus + onMinus)
  })
  # Average by the sum of all widths
  weighted.mean(idx, sum(width(gbl)))
}
```

```{r strand_proportion_index_run}
BiocParallel::bplapply(gbs,                 strand_proportion_index  ) |> pairs2Kable6x3()
BiocParallel::bplapply(gbs, \(g) swap(g) |> strand_proportion_index()) |> pairs2Kable6x3()
```

# Strand proportion majority index

One possible solution to the problem above could be to report the highest
proportion, so that the value returned is not sensitive to orientation.  But
it scales the index between 0.5 and 1, which may be counter-intuitive.

```{r strand_proportion_majority_index_def}
strand_proportion_majority_index <- function(gb) {
  gbl <- split(gb, droplevels(seqnames(gb)))
  # Calculate an index for each sequence feature
  idx <- sapply(gbl, \(x) {
    onPlus  <- sum(width(x[strand(x) == '+']))
    onMinus <- sum(width(x[strand(x) == '-']))
    p <- onPlus / (onPlus + onMinus)
    if(p < 0.5) p <- 1 - p
    p
  })
  # Average by the sum of all widths
  weighted.mean(idx, sum(width(gbl)))
}
```

```{r strand_proportion_majority_index_run}
BiocParallel::bplapply(gbs,                 strand_proportion_majority_index  ) |> pairs2Kable6x3()
BiocParallel::bplapply(gbs, \(g) swap(g) |> strand_proportion_majority_index()) |> pairs2Kable6x3()
```
