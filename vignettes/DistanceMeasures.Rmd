---
title: "Distance Measures"
author: 
 - "Charles Plessy"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEncoding{UTF-8}
  %\VignetteIndexEntry{Distance Measures}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

# Purpose

We want to put numbers on visual impressions such as:

 - There is a lot of scrambling.
 - Aligned regions stay on their chromosome arm.
 - Aligned regions are more "off the diagonal" on short arms than on long arms.
 - â€¦

# Load R pacakges and data

```{r load_packages_and_data}
library('OikScrambling') |> suppressPackageStartupMessages()
load("BreakPoints.Rdata")
```

See `vignette("LoadGenomicBreaks", package = "OikScrambling")` for how the
different GBreaks objects are prepared.

# Declare service functions

```{r pretty_print_functions}
pairs2table6x3 <- function (x) {
  x <- as.list(x)
  cbind(
    Oki = c(Oki = NA,        Osa = x$Osa_Oki, Bar = x$Bar_Oki),
    Kum = c(Oki = x$Oki_Kum, Osa = x$Osa_Kum, Bar = x$Bar_Kum),
    Osa = c(Oki = x$Oki_Osa, Osa = NA,        Bar = x$Bar_Osa),
    Aom = c(Oki = x$Oki_Aom, Osa = x$Osa_Aom, Bar = x$Bar_Aom),
    Bar = c(Oki = x$Oki_Bar, Osa = x$Osa_Bar, Bar = NA       ),
    Nor = c(Oki = x$Oki_Nor, Osa = x$Osa_Nor, Bar = x$Bar_Nor)
  )
}

pairs2Kable6x3 <- function (df) df |> pairs2table6x3() |> round(2) |> knitr::kable()
```

# Synteny index

Ad-hoc index measuring to what extent a scaffold of the _target_ genome is
mostly aligned to a single scaffold in the _query_ genome.   See
`?GenomicBreaks::synteny_index` for details.  One limitation to the use of this
index is that it requires that at least the _query_ genome is a complete
chromosome assembly.

```{r synteny_index_def}
synteny_index
```

```{r synteny_index_run}
BiocParallel::bplapply(gbs,                 synteny_index  ) |> pairs2Kable6x3()
BiocParallel::bplapply(gbs, \(g) swap(g) |> synteny_index()) |> pairs2Kable6x3()
```

# Correlation

Ad-hoc index measuring the correlation of the coordinates of the syntenic
alignments in scaffolds of a _target_ genome and their best match in the
_query_ genome.  See `?GenomicBreaks::correlation_index` for details.  It is
intended to be more robust to the presence of uncollapsed haplotypes in the
_query_ genome but probably needs further testing.

```{r correlation_index_def}
correlation_index
```

```{r correlation_index_run}
BiocParallel::bplapply(gbs,                 correlation_index  ) |> pairs2Kable6x3()
BiocParallel::bplapply(gbs, \(g) swap(g) |> correlation_index()) |> pairs2Kable6x3()
```

# Gene Order Conservation

See `?GenomicBreaks::GOC` for details.

```{r goc_index_def}
GOC
```

```{r goc_index_run}
BiocParallel::bplapply(gbs,                 GOC  ) |> pairs2Kable6x3()
BiocParallel::bplapply(gbs, \(g) swap(g) |> GOC()) |> pairs2Kable6x3()
```

# Strand randomisation index

See `?GenomicBreaks::strand_randomisation_index` for details.

```{r strand_randomisation_index_def}
strand_randomisation_index
```

```{r strand_randomisation_index_run}
BiocParallel::bplapply(gbs,                 strand_randomisation_index  ) |> pairs2Kable6x3()
BiocParallel::bplapply(gbs, \(g) swap(g) |> strand_randomisation_index()) |> pairs2Kable6x3()
```

In order to assess the extent to which the strand randomisation index may vary in a given pair of genomes, I do a simple permutation test. Given a `GBreaks` object, reverse the strand of a randomly-selected number of alignments drawn from a random distribution.

You can evaluate the relative frequency of "flips", i.e., a possible inversion, by counting the frequency of changes in the strand. I check this quickly below. Then I use the shape of this distribution to select a random number of flips to make, then make 10,000 permutations of the alignment with the randomly-selected number of flips, then calculate strand randomization indices on these randomly-flipped alignments. 

```{r strand_randomisation_permutation_test}
# Some libraries for fitting distributions...
library(fitdistrplus) |> suppressPackageStartupMessages()
library(stats4)       |> suppressPackageStartupMessages()
library(MASS)         |> suppressPackageStartupMessages()
library(survival)     |> suppressPackageStartupMessages()
library(actuar)       |> suppressPackageStartupMessages()
library(distrMod)     |> suppressPackageStartupMessages()
library(ggplotify)    |> suppressPackageStartupMessages()
library(patchwork)    |> suppressPackageStartupMessages()


# Each pair produces a slightly different graph. However, hopefully the distribution is similar.
plotdist(gbs$Oki_Osa |> strand() |> runLength() |> as.numeric())
plotdist(gbs$Oki_Bar |> strand() |> runLength() |> as.numeric())
plotdist(gbs$Osa_Bar |> strand() |> runLength() |> as.numeric())

# Fit a numeric vector (i.e., the strand run length) to a number of probability distributions
fit_distributions <- function(vec, distributions = c("nbinom", "pois", "lnorm", "norm", "exp", "gamma", "llogis"), method="mle") {
  lapply(distributions, function(d) {
    fitdist(vec, d, method=method)
  })
}
p_oki_osa <- gbs$Oki_Osa |> strand() |> runLength() |> as.numeric() |> fit_distributions(method="mle")

# You can evaluate the different models graphically. These plots are a little busy, though.
p1 <- as.ggplot(function() denscomp(p_oki_osa) )
p2 <- as.ggplot(function() qqcomp(p_oki_osa) )
p3 <- as.ggplot(function() cdfcomp(p_oki_osa) )
p4 <- as.ggplot(function() ppcomp(p_oki_osa) )
(p1 | p2) / (p3 | p4)

p_oki_bar <- gbs$Oki_Bar |> strand() |> runLength() |> as.numeric() |> fit_distributions(method="mle")
p1 <- as.ggplot(function() denscomp(p_oki_bar) )
p2 <- as.ggplot(function() qqcomp(p_oki_bar) )
p3 <- as.ggplot(function() cdfcomp(p_oki_bar) )
p4 <- as.ggplot(function() ppcomp(p_oki_bar) )
(p1 | p2) / (p3 | p4)


p_osa_bar <- gbs$Osa_Bar |> strand() |> runLength() |> as.numeric() |> fit_distributions(method="mle")
p1 <- as.ggplot(function() denscomp(p_osa_bar) )
p2 <- as.ggplot(function() qqcomp(p_osa_bar) )
p3 <- as.ggplot(function() cdfcomp(p_osa_bar) )
p4 <- as.ggplot(function() ppcomp(p_osa_bar) )
(p1 | p2) / (p3 | p4)

# We can evaluate them one at a time:
comp_plots <- function(gr, method="mle", distribution="nbinom") {
  srl <- gr |> strand() |> runLength() |> as.numeric()
  f <- fit_distributions(srl, distribution=distribution, method="mle")
  p1 <- as.ggplot(function() denscomp(f))
  p2 <- as.ggplot(function() qqcomp(f))
  p3 <- as.ggplot(function() cdfcomp(f))
  p4 <- as.ggplot(function() ppcomp(f))
  (p1 | p2 ) / ( p3 | p4)
}

all_distributions <- c("nbinom", "pois", "lnorm", "exp", "gamma")
lapply(all_distributions, function(d) comp_plots(gbs$Oki_Osa, distribution = d))
lapply(all_distributions, function(d) comp_plots(gbs$Oki_Bar, distribution = d))
lapply(all_distributions, function(d) comp_plots(gbs$Osa_Bar, distribution = d))

# Obtain goodness-of-fit statistics for each model to see which fits data best.
# Then we can use the best-fitting model as a probability distribution to randomly
# induce a realistic number of "flips", generating a randomly-flipped GBreaks object.
(gofstat(p_oki_osa))
(gofstat(p_oki_bar))
(gofstat(p_osa_bar))

gofstat(p_oki_osa  )$aic |> which.min() |> names()
gofstat(p_oki_bar  )$aic |> which.min() |> names()
gofstat(p_osa_bar  )$aic |> which.min() |> names()

# All 3 agree that a log-normal distribution best describes the size of 
# 
# randomly_flip_strand <- function(gr, seed=1992, flip_number_function=pois) {
#   str <- strand(gr)
#   indices <- length(gr)
#   # The number
#   number_of_flips <- 
#   which.flips <- 
#   
# }
# randomly_flip(gbs$Oki_Osa)

detach('package:fitdistrplus')
detach('package:survival')
detach('package:actuar')
detach('package:distrMod')
detach('package:ggplotify')
detach('package:patchwork')
```


# Strand proportion index

Attempts to use pure proportions lead to scores drifting towards 0.5 when
comparing fragmented assemblies, as the fragments are not oriented.

```{r strand_proportion_index_def}
strand_proportion_index <- function(gb) {
  gbl <- split(gb, droplevels(seqnames(gb)))
  # Calculate an index for each sequence feature
  idx <- sapply(gbl, \(x) {
    onPlus  <- sum(width(x[strand(x) == '+']))
    onMinus <- sum(width(x[strand(x) == '-']))
    onPlus / (onPlus + onMinus)
  })
  # Average by the sum of all widths
  weighted.mean(idx, sum(width(gbl)))
}
```

```{r strand_proportion_index_run}
BiocParallel::bplapply(gbs,                 strand_proportion_index  ) |> pairs2Kable6x3()
BiocParallel::bplapply(gbs, \(g) swap(g) |> strand_proportion_index()) |> pairs2Kable6x3()
```

# Strand proportion majority index

One possible solution to the problem above could be to report the highest
proportion, so that the value returned is not sensitive to orientation.  But
it scales the index between 0.5 and 1, which may be counter-intuitive.

```{r strand_proportion_majority_index_def}
strand_proportion_majority_index <- function(gb) {
  gbl <- split(gb, droplevels(seqnames(gb)))
  # Calculate an index for each sequence feature
  idx <- sapply(gbl, \(x) {
    onPlus  <- sum(width(x[strand(x) == '+']))
    onMinus <- sum(width(x[strand(x) == '-']))
    p <- onPlus / (onPlus + onMinus)
    if(p < 0.5) p <- 1 - p
    p
  })
  # Average by the sum of all widths
  weighted.mean(idx, sum(width(gbl)))
}
```

```{r strand_proportion_majority_index_run}
BiocParallel::bplapply(gbs,                 strand_proportion_majority_index  ) |> pairs2Kable6x3()
BiocParallel::bplapply(gbs, \(g) swap(g) |> strand_proportion_majority_index()) |> pairs2Kable6x3()
```
