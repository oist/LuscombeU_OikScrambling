---
title: "Distance Measures"
author: 
 - "Charles Plessy"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEncoding{UTF-8}
  %\VignetteIndexEntry{Distance Measures}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

# Purpose

We want to put numbers on visual impressions such as:

 - There is a lot of scrambling.
 - Aligned regions stay on their chromosome arm.
 - Aligned regions are more "off the diagonal" on short arms than on long arms.
 - â€¦
 
** Figure 1D's _scrambling index_ table is computed here under the name
_strand randomisation indexes_.**

# Load R pacakges and data

```{r load_packages_and_data}
library('OikScrambling') |> suppressPackageStartupMessages()
load("BreakPoints.Rdata")
```

See `vignette("LoadGenomicBreaks", package = "OikScrambling")` for how the
different GBreaks objects are prepared.

# Declare service functions

```{r pretty_print_functions}
pairs2table6x3 <- function (x) {
  x <- as.list(x)
  cbind(
    Oki = c(Oki = NA,        Osa = x$Osa_Oki, Bar = x$Bar_Oki),
    Kum = c(Oki = x$Oki_Kum, Osa = x$Osa_Kum, Bar = x$Bar_Kum),
    Osa = c(Oki = x$Oki_Osa, Osa = NA,        Bar = x$Bar_Osa),
    Aom = c(Oki = x$Oki_Aom, Osa = x$Osa_Aom, Bar = x$Bar_Aom),
    Bar = c(Oki = x$Oki_Bar, Osa = x$Osa_Bar, Bar = NA       ),
    Nor = c(Oki = x$Oki_Nor, Osa = x$Osa_Nor, Bar = x$Bar_Nor)
  )
}

pairs2Kable6x3 <- function (df) df |> pairs2table6x3() |> round(2) |> knitr::kable()
```

# Strand randomisation index

See `?GenomicBreaks::strand_randomisation_index` for details.

```{r strand_randomisation_index_def}
strand_randomisation_index
```

The computation of strand randomisation indices is not symmetric: the results
differ a bit when the roles of _target_ and _query_ genomes are swapped.

```{r strand_randomisation_index_run}
SRIs         <- BiocParallel::bplapply(gbs,                 strand_randomisation_index  )
SRIS_swapped <- BiocParallel::bplapply(gbs, \(g) swap(g) |> strand_randomisation_index())
```

## Table 1

We averaged the numbers computed with and without swapping _target_ and _query_
genomes.

```{r strand_randomisation_index_table_1}
as.list(1 / 2 * (unlist(SRIs) + unlist(SRIS_swapped))) |> pairs2Kable6x3()
```

## Unidirectional computation

The raw data is shown here to prove that the differences do not affect general
conclusions.

```{r strand_randomisation_index_run_unidir}
SRIs         |> pairs2Kable6x3()
SRIS_swapped |> pairs2Kable6x3()
```

# Synteny index

Ad-hoc index measuring to what extent a scaffold of the _target_ genome is
mostly aligned to a single scaffold in the _query_ genome.   See
`?GenomicBreaks::synteny_index` for details.  One limitation to the use of this
index is that it requires that at least the _query_ genome is a complete
chromosome assembly.

```{r synteny_index_def}
synteny_index
```

```{r synteny_index_run}
BiocParallel::bplapply(gbs,                 synteny_index  ) |> pairs2Kable6x3()
BiocParallel::bplapply(gbs, \(g) swap(g) |> synteny_index()) |> pairs2Kable6x3()
```

# Correlation

Ad-hoc index measuring the correlation of the coordinates of the syntenic
alignments in scaffolds of a _target_ genome and their best match in the
_query_ genome.  See `?GenomicBreaks::correlation_index` for details.  It is
intended to be more robust to the presence of uncollapsed haplotypes in the
_query_ genome but probably needs further testing.

```{r correlation_index_def}
correlation_index
```

```{r correlation_index_run}
BiocParallel::bplapply(gbs,                 correlation_index  ) |> pairs2Kable6x3()
BiocParallel::bplapply(gbs, \(g) swap(g) |> correlation_index()) |> pairs2Kable6x3()
```

# Gene Order Conservation

See `?GenomicBreaks::GOC` for details.

```{r goc_index_def}
GOC
```

```{r goc_index_run}
BiocParallel::bplapply(gbs,                 GOC  ) |> pairs2Kable6x3()
BiocParallel::bplapply(gbs, \(g) swap(g) |> GOC()) |> pairs2Kable6x3()
```

# Strand proportion index

Attempts to use pure proportions lead to scores drifting towards 0.5 when
comparing fragmented assemblies, as the fragments are not oriented.

```{r strand_proportion_index_def}
strand_proportion_index <- function(gb) {
  gbl <- split(gb, droplevels(seqnames(gb)))
  # Calculate an index for each sequence feature
  idx <- sapply(gbl, \(x) {
    onPlus  <- sum(width(x[strand(x) == '+']))
    onMinus <- sum(width(x[strand(x) == '-']))
    onPlus / (onPlus + onMinus)
  })
  # Average by the sum of all widths
  weighted.mean(idx, sum(width(gbl)))
}
```

```{r strand_proportion_index_run}
BiocParallel::bplapply(gbs,                 strand_proportion_index  ) |> pairs2Kable6x3()
BiocParallel::bplapply(gbs, \(g) swap(g) |> strand_proportion_index()) |> pairs2Kable6x3()
```

# Strand proportion majority index

One possible solution to the problem above could be to report the highest
proportion, so that the value returned is not sensitive to orientation.  But
it scales the index between 0.5 and 1, which may be counter-intuitive.

```{r strand_proportion_majority_index_def}
strand_proportion_majority_index <- function(gb) {
  gbl <- split(gb, droplevels(seqnames(gb)))
  # Calculate an index for each sequence feature
  idx <- sapply(gbl, \(x) {
    onPlus  <- sum(width(x[strand(x) == '+']))
    onMinus <- sum(width(x[strand(x) == '-']))
    p <- onPlus / (onPlus + onMinus)
    if(p < 0.5) p <- 1 - p
    p
  })
  # Average by the sum of all widths
  weighted.mean(idx, sum(width(gbl)))
}
```

```{r strand_proportion_majority_index_run}
BiocParallel::bplapply(gbs,                 strand_proportion_majority_index  ) |> pairs2Kable6x3()
BiocParallel::bplapply(gbs, \(g) swap(g) |> strand_proportion_majority_index()) |> pairs2Kable6x3()
```
