---
title: "Inversions"
author: 
 - "Charles Plessy"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEncoding{UTF-8}
  %\VignetteIndexEntry{Inversions}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup}
knitr::opts_chunk$set(cache = TRUE, cache.lazy = FALSE)
```

# Introduction

After coalescing colinear alignments, removing translocations of
repeat-containing sequences and re-coalescing, colinearity is still broken
hundreds of time.

Here we explore the role of inversions in scrambling _Oikopleura_ genomes.

# Load R pacakges and data

```{r load_packages_and_data}
library('OikScrambling') |> suppressPackageStartupMessages()
load("BreakPoints.Rdata")
```

See `vignette("LoadGenomicBreaks", package = "OikScrambling")` for how the
different GBreaks objects are prepared.

# Trivial inversions

## Documentation

Details can be found in `vignette("GenomicBreaks", package = "GenomicBreaks")`,
in `vignette("StructuralVariants", package = "GenomicBreaks")`,
and `?GenomicBreaks::flagInversions`

## Number of trivial inversions

More inversions are found after coalescing colinear blocks because of situations
where `+ - +` was `+ - - +` before collapsing.

The number of detected inversions is further increased after double-coalescing,
but not much.

```{r detect_trivial_invertions, fig.width=8, fig.height=6}
(invs_summary <- data.frame(
  align  = sapply(gbs,  function(gb) sum(flagInversions(gb)$inv)),
  mapped = sapply(coa,  function(gb) sum(flagInversions(gb)$inv)),
  map2   = sapply(coa2, function(gb) sum(flagInversions(gb)$inv))
))

sapply(invs_summary, \(x) tapply(x, row.names(invs_summary) |> OikScrambling:::compDistance(), mean))
sapply(invs_summary, \(x) tapply(x, row.names(invs_summary) |> OikScrambling:::compDistance(), median))
sapply(invs_summary, \(x) tapply(x, row.names(invs_summary) |> OikScrambling:::compDistance(), sd))

invs_summary$pairname   <- OikScrambling:::compDistance(rownames(invs_summary))
invs_summary$pairname_s <- OikScrambling:::compDistance(rownames(invs_summary), short = TRUE)
invs_summary$genus      <- OikScrambling:::compGenus(rownames(invs_summary))
invs_summary$class      <- OikScrambling:::compDistClass(rownames(invs_summary))
invs_summary$target     <- sub("_.*", "", rownames(invs_summary))
invs_summary <- invs_summary[invs_summary$class != "Int/Rob – Oki",]

ggplot(invs_summary |> tidyr::pivot_longer(c("align", "mapped", "map2"))) +
  aes(value, pairname_s) + geom_point(aes(col = target)) +
  ggtitle ("Number of inversions found after different post-processings") +
  facet_wrap(~name, ncol= 1)
```

```{r number_of_inversions, fig.width=7, dev='svg', fig.ext='svg'}
ggplot(invs_summary |> tidyr::pivot_longer(c("mapped"))) +
  aes(value, genus) + geom_point(aes(col = class)) +
  ggtitle ("Number of inversions found in mapped regions") 
```

## Motif search

Enrichment for motifs is being searched in
`vignette("PWM", package = "OikScrambling")`.

## Breakpoint regions flanking inversions in the same-population alignments.

### Large inversions

The comparison of `contig_90_1` to Okinawa's chromosome 1 shows a large
inversion.  Note that `contig_90_1` appears to be assembled in reverse
orientation compared with the _short to long_ arm orientation that we chose
in our chromosomal assemblies.

```{r Kum_chr1_large_inversion}
coa2$Oki_Kum |> swap() |> reverse () |> swap () |> plotApairOfChrs(chrQ = "contig_90_1")
```

```{r Kum_chr1_large_inversion_coordinates}
coa2$Oki_Kum |> plyranges::filter(seqnames == "chr1", seqnames(query) == "contig_90_1", width > 1e3) |> coalesce_contigs()
coa2$Oki_Kum |> plyranges::filter(seqnames == "chr1", seqnames(query) == "contig_90_1", width > 1e3) |> range()
```

### Small inversions.

Check `vignette("ColinearityInterruptors", package = "OikScrambling")`.

## Breakpoint regions flanking large inversions in the North–North alignments.

Let's try to isolate some inversions that are easy to spot on a whole-chromosome
alignment.

```{r}
plotApairOfChrs(coa2$Osa_Bar, "PAR")
(ROI1 <- coa2$Osa_Bar |> plyranges::filter(seqnames == "PAR", start > 9e6, end < 14e6, start(query) > 7e6, end(query) < 12e6))
plotApairOfChrs(ROI1)
# The contours of the main 4 blocks can be coalesced by applying a size threshold.
ROI1 |> coalesce_contigs(min = 1e4)
# The gaps flanking the first inverted region are quite large!
(ROI1_gaps <- ROI1 |> coalesce_contigs(min = 1e4) |> cleanGaps() |> plyranges::mutate(w = width))
# The left-side gap contains no alignment at all even before discarding the short ones.
subsetByOverlaps(gbs$Osa_Bar, ROI1_gaps)
# The same region aligns well to Aomori, suggesting that it is not missassembled
coa2$Osa_Aom |> plyranges::filter(seqnames == "PAR", start > 9e6, end < 14e6) |> plotApairOfChrs()
# The Osa–Bar unaligned regions appear to align well to Aom, but the first one is split
# and the second one contains a small inversion. Are there a hotspots ?
subsetByOverlaps(gbs$Osa_Aom, ROI1_gaps, type = "any") |> plotApairOfChrs()
subsetByOverlaps(gbs$Osa_Aom, ROI1_gaps[1], type = "within") |> plotApairOfChrs()
subsetByOverlaps(gbs$Osa_Aom, ROI1_gaps[2], type = "within") |> plotApairOfChrs()
subsetByOverlaps(gbs$Osa_Aom, ROI1_gaps[3], type = "within") |> plotApairOfChrs()
# In the alignment to Okinawa, it is scrambled.
coa2$Osa_Oki |> plyranges::filter(seqnames == "PAR", start > 9e6, end < 14e6) |> plotApairOfChrs()
```

# Export inversions to ZENBU

## Okinawa

```
invs <- sapply(coa[1:5], inv2UCSCData) |> SimpleList()
rtracklayer::export(invs$Oki_Osa, "inversions_v4.0.0_Oki_Osa.bed")
rtracklayer::export(invs$Oki_Bar, "inversions_v4.0.0_Oki_Bar.bed")
rtracklayer::export(invs$Oki_Kum, "inversions_v4.0.0_Oki_Kum.bed")
rtracklayer::export(invs$Oki_Aom, "inversions_v4.0.0_Oki_Aom.bed")
rtracklayer::export(invs$Oki_Nor, "inversions_v4.0.0_Oki_Nor.bed")
```

## Ōsaka

```
invsOska <- sapply(coa[6:10], inv2UCSCData) |> SimpleList()
rtracklayer::export(invsOska$Osa_Oki, "inversions_v4.0.0_Osa_Oki.bed")
rtracklayer::export(invsOska$Osa_Bar, "inversions_v4.0.0_Osa_Bar.bed")
rtracklayer::export(invsOska$Osa_Kum, "inversions_v4.0.0_Osa_Kum.bed")
rtracklayer::export(invsOska$Osa_Aom, "inversions_v4.0.0_Osa_Aom.bed")
rtracklayer::export(invsOska$Osa_Nor, "inversions_v4.0.0_Osa_Nor.bed")
```

# Breakpoint regions flanking inversions

Inversions break synteny.  Therefore, the unaligned regions flanking them are
classified as _breakpoint regions_.  This means that they are not paired with
the other genome.  Here, we will do the pairing by 1) flipping the inversions
and re-coalescing the alignments, and 2) isolating the new bridge regions
produced in that process.

```{r bridges_of_inversions}
flipInversions <- function(gb) {
  Invs <- which(flagInversions(gb)$inv) + 1
  strand(gb)[Invs] <- ifelse(strand(gb)[Invs] == "+", "-", "+")
  gb
}

flippedInvs <- sapply(coa, flipInversions) |> SimpleList()

# See https://github.com/oist/GenomicBreaks/issues/20
bridgeRegions_ <- function(gb) {
  if(sum(flagColinearAlignments(gb)$colinear) == 0) return(GBreaks())
  bridgeRegions(gb)
}

flippedInvs_bri <- sapply(flippedInvs, bridgeRegions_) |> SimpleList()

# Copied from the LoadGenomicBreaks vignette
flagLongShort_ <- function(gr, longShort) {
  genomeT <- gr |> genome() |> unique()
  if(genomeT %in% names(longShort))
    gr <- flagLongShort(gr, longShort[[genomeT]])
  if("GBreaks" %in% class(gr)) {
      genomeQ <- gr$query |> genome() |> unique()
      if(genomeQ %in% names(longShort)) {
        # sort, flag, unsort, extract flag
        grq <- gr$query
        grq$idx <- seq_along(grq)
        grq <- sort(grq, ignore.strand = TRUE)
        grq <- flagLongShort(grq, longShort[[genomeQ]])
        gr$query$Arm <- grq$Arm[order(grq$idx)]
      }
  }
  gr
}

flippedInvs_bri[1:15] <- BiocParallel::bplapply(flippedInvs_bri[1:15], flagLongShort_, longShort)


# Copied from the RegionWidths vignette
GBreaks2widthTibble <- function(gb, pair = NULL) {
  df <- as.data.frame(gb)
  if(is.null(df$Arm))       df$Arm        <- NA
  if(is.null(df$rep))       df$rep        <- NA
  if(is.null(df$query.rep)) df$query.rep  <- NA
  tibble::tibble(target     = df$width,        query     = df$query.width,
                 target.rep = ! is.na(df$rep), query.rep = ! is.na(df$query.rep),  # TRUE if overlaps a repeat
                 pair = pair, Arm = df$Arm,
                 dist = OikScrambling:::compDistance(pair))
}

ggPlotW2W <- function(tibble, plus1 = FALSE, alpha = 0.05) {
  if (plus1) {
    tibble$target <- tibble$target + 1
    tibble$query  <- tibble$query  + 1
  }
  ggplot(tibble) +
    aes(target, query) +
    geom_point(alpha = alpha) +
    geom_density_2d() +
    scale_x_log10() +
    scale_y_log10()
}

NULL -> flippedInvs_bri$Ply_Oki -> flippedInvs_bri$Rob_Oki

w2w <- do.call(rbind, lapply(names(flippedInvs_bri),  \(name) GBreaks2widthTibble(flippedInvs_bri[[name]],  pair = name)))

ggPlotW2W(w2w |> dplyr::filter(!is.na(Arm))) + facet_wrap(~Arm) +
  ggtitle("Width of the target and query regions flanking inversions")

ggPlotW2W(w2w)                              + facet_wrap(~dist) +
  ggtitle("Width of the target and query regions flanking inversions")
```

# Same-culture inversions

```{r I28}
# i28.gbs <- load_genomic_breaks("~/FromSango/I28-4.07.postmasked.gff.gz", type = "match",
#                                target = genomes$OKI2018.I69, query = BSgenome.Oidioi.OIST.I28) |> flagLongShort(longShort$OKI2018.I69)
# i28.coa <- coalesce_contigs(i28.gbs) |> flagLongShort(longShort$OKI2018.I69)
# i28.briInv <- i28.coa |> flipInversions() |> bridgeRegions()
# i28.briInv$wT <- width(i28.briInv)
# i28.briInv$wQ <- width(i28.briInv$query)
# i28.briInv <- dist2next(i28.briInv)
# i28.w2w <- GBreaks2widthTibble(i28.briInv, pair = "Oki_Oki")
# ggPlotW2W(i28.w2w)
# ggPlotW2W(i28.w2w, plus1 = TRUE, alpha = .5)
```

It looks like some aligned inversions with zero-width bridges on both sides are flanked by tandem inverted unmapped regions.

https://fantom.gsc.riken.jp/zenbu/gLyphs/#config=f863qz3iKBFqUgA75J9BBC;loc=OKI2018_I69_1.0::chr1:7668403..7668663+

A region in Oki that inverted but not in the other genomes, and maybe in only
one haplotype.  The unaligned regions are shorter in Oki, suggesting that the
lesion happened there.  They still contain repeats.

https://fantom.gsc.riken.jp/zenbu/gLyphs/#config=Px8xzKj9BdRgDGPSmcNT_;loc=OKI2018_I69_1.0::PAR:16104430..16107799+

```
coa$Oki_Kum |> plyranges::filter(start >= 16098309, end <= 16113733, seqnames == 'PAR') |> dist2next(ignore.strand = T)
```

A region in Oki inverted compared to I28 and Kum, and maybe also Osaka, flanked
by a pair of repeats of the same family that is inserted only in Oki (because
gap length is near-zero in I28 and Kum).

```{r ROI3_I28}
Add <- function(gb, n) {
  start(gb)       <- start(gb      ) - n
  end  (gb)       <- end  (gb      ) + n
  start(gb$query) <- start(gb$query) - n
  end  (gb$query) <- end  (gb$query) + n
  gb
}

# (ROI3_I28 <- i28.gbs     |> plyranges::filter(start >= 10262805, end <= 10277383, seqnames == 'PAR') |> dist2next(ignore.strand = T))
(ROI3_Kum <- coa$Oki_Kum |> plyranges::filter(start >= 10255040, end <= 10280531, seqnames == 'PAR') |> dist2next(ignore.strand = T))
# 
# # Sequence near the 
# # Need to shrink to avoid zero-length regions not yet supported by cleanGaps.
# # Add 10 to the gaps to see sequence
((ROI3_Kum$query -1)|> cleanGaps() +10) |> getSeq()
# ((ROI3_I28$query -1)|> cleanGaps() +10) |> getSeq()
# 
# ROI3_I28
# pairwiseAlignment(ROI3_I28[1] |> Add(6) )
# pairwiseAlignment(ROI3_I28[2] |> Add(8) )
# getSeq(ROI3_I28[2] |> Add(8) |> plyranges::mutate(strand = "+"))
# pairwiseAlignment(ROI3_I28[3] |> Add(6) )

pairwiseAlignment(ROI3_Kum[1] |> Add(6) )
pairwiseAlignment(ROI3_Kum[2] |> Add(8) )
getSeq(ROI3_Kum[2] |> Add(8) |> plyranges::mutate(strand = "+"))
pairwiseAlignment(ROI3_I28[3] |> Add(6) )
```

My hypothesis:

  a) Ancestral version with no repeats.
  b) One `i69_juicer_1_5_16917` repeat inserts next to `g11343.t3` gene
  c) A second copy of `i69_juicer_1_5_16917` inserts on the other side of the gene,
     in the opposite orientation.
  d) Later, because of the tandem inverted repeat, the gene was inverted.
  
The repeats have inverted tandem sites `cagtcgactctggcaattacgag`
