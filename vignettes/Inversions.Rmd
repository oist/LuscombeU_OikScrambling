---
title: "Inversions"
author: 
 - "Charles Plessy"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEncoding{UTF-8}
  %\VignetteIndexEntry{Inversions}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup}
knitr::opts_chunk$set(cache = TRUE, cache.lazy = FALSE)
```

# Introduction

After coalescing colinear alignments, removing translocations of
repeat-containing sequences and re-coalescing, colinearity is still broken
hundreds of time.

Here we explore the role of inversions in scrambling _Oikopleura_ genomes.

# Load R pacakges and data

```{r load_packages_and_data}
library('OikScrambling') |> suppressPackageStartupMessages()
load("BreakPoints.Rdata")
```

See `vignette("LoadGenomicBreaks", package = "OikScrambling")` for how the
different GBreaks objects are prepared.

# Trivial inversions

## Documentation

Details can be found in `vignette("GenomicBreaks", package = "GenomicBreaks")`,
in `vignette("StructuralVariants", package = "GenomicBreaks")`,
and `?GenomicBreaks::flagInversions`

## Number of trivial inversions

More inversions are found after coalescing colinear blocks because of situations
where `+ - +` was `+ - - +` before collapsing.

The number of detected inversions is further increased after double-coalescing,
but not much.

```{r detect_trivial_invertions, fig.width=8, fig.height=6}
(invs_summary <- data.frame(
  align  = sapply(gbs,  function(gb) sum(flagInversions(gb)$inv)),
  mapped = sapply(coa,  function(gb) sum(flagInversions(gb)$inv)),
  map2   = sapply(coa2, function(gb) sum(flagInversions(gb)$inv))
))

sapply(invs_summary, \(x) tapply(x, row.names(invs_summary) |> OikScrambling:::compDistance(), mean))
sapply(invs_summary, \(x) tapply(x, row.names(invs_summary) |> OikScrambling:::compDistance(), median))
sapply(invs_summary, \(x) tapply(x, row.names(invs_summary) |> OikScrambling:::compDistance(), sd))

invs_summary$pairname   <- OikScrambling:::compDistance(rownames(invs_summary))
invs_summary$pairname_s <- OikScrambling:::compDistance(rownames(invs_summary), short = TRUE)
invs_summary$genus      <- OikScrambling:::compGenus(rownames(invs_summary))
invs_summary$class      <- OikScrambling:::compDistClass(rownames(invs_summary))
invs_summary$target     <- sub("_.*", "", rownames(invs_summary))
invs_summary <- invs_summary[invs_summary$class != "Int/Rob – Oki",]

ggplot(invs_summary |> tidyr::pivot_longer(c("align", "mapped", "map2"))) +
  aes(value, pairname_s) + geom_point(aes(col = target)) +
  ggtitle ("Number of inversions found after different post-processings") +
  facet_wrap(~name, ncol= 1)
```

```{r number_of_inversions, fig.width=7, dev='svg', fig.ext='svg'}
ggplot(invs_summary |> tidyr::pivot_longer(c("mapped"))) +
  aes(value, genus) + geom_point(aes(col = class)) +
  ggtitle ("Number of inversions found in mapped regions") 
```

## Motif search

Enrichment for motifs is being searched in
`vignette("PWM", package = "OikScrambling")`.

## Breakpoint regions flanking inversions in the same-population alignments.

### Large inversions

The comparison of `contig_90_1` to Okinawa's chromosome 1 shows a large
inversion.  Note that `contig_90_1` appears to be assembled in reverse
orientation compared with the _short to long_ arm orientation that we chose
in our chromosomal assemblies.

```{r Kum_chr1_large_inversion}
coa2$Oki_Kum |> swap() |> reverse () |> swap () |> plotApairOfChrs(chrQ = "contig_90_1")
```

```{r Kum_chr1_large_inversion_coordinates}
coa2$Oki_Kum |> plyranges::filter(seqnames == "chr1", seqnames(query) == "contig_90_1", width > 1e3) |> coalesce_contigs()
coa2$Oki_Kum |> plyranges::filter(seqnames == "chr1", seqnames(query) == "contig_90_1", width > 1e3) |> range()
```

### Small inversions.

Check `vignette("ColinearityInterruptors", package = "OikScrambling")`.

## Breakpoint regions flanking large inversions in the North–North alignments.

Let's try to isolate some inversions that are easy to spot on a whole-chromosome
alignment.

```{r}
plotApairOfChrs(coa2$Osa_Bar, "PAR")
(ROI1 <- coa2$Osa_Bar |> plyranges::filter(seqnames == "PAR", start > 9e6, end < 14e6, start(query) > 7e6, end(query) < 12e6))
plotApairOfChrs(ROI1)
# The contours of the main 4 blocks can be coalesced by applying a size threshold.
ROI1 |> coalesce_contigs(min = 1e4)
# The gaps flanking the first inverted region are quite large!
(ROI1_gaps <- ROI1 |> coalesce_contigs(min = 1e4) |> cleanGaps() |> plyranges::mutate(w = width))
# The left-side gap contains no alignment at all even before discarding the short ones.
subsetByOverlaps(gbs$Osa_Bar, ROI1_gaps)
# The same region aligns well to Aomori, suggesting that it is not missassembled
coa2$Osa_Aom |> plyranges::filter(seqnames == "PAR", start > 9e6, end < 14e6) |> plotApairOfChrs()
# The Osa–Bar unaligned regions appear to align well to Aom, but the first one is split
# and the second one contains a small inversion. Are there a hotspots ?
subsetByOverlaps(gbs$Osa_Aom, ROI1_gaps, type = "any") |> plotApairOfChrs()
subsetByOverlaps(gbs$Osa_Aom, ROI1_gaps[1], type = "within") |> plotApairOfChrs()
subsetByOverlaps(gbs$Osa_Aom, ROI1_gaps[2], type = "within") |> plotApairOfChrs()
subsetByOverlaps(gbs$Osa_Aom, ROI1_gaps[3], type = "within") |> plotApairOfChrs()
# In the alignment to Okinawa, it is scrambled.
coa2$Osa_Oki |> plyranges::filter(seqnames == "PAR", start > 9e6, end < 14e6) |> plotApairOfChrs()
```

# Export inversions to ZENBU

## Okinawa

```
invs <- sapply(coa[1:5], inv2UCSCData) |> SimpleList()
rtracklayer::export(invs$Oki_Osa, "inversions_v4.0.0_Oki_Osa.bed")
rtracklayer::export(invs$Oki_Bar, "inversions_v4.0.0_Oki_Bar.bed")
rtracklayer::export(invs$Oki_Kum, "inversions_v4.0.0_Oki_Kum.bed")
rtracklayer::export(invs$Oki_Aom, "inversions_v4.0.0_Oki_Aom.bed")
rtracklayer::export(invs$Oki_Nor, "inversions_v4.0.0_Oki_Nor.bed")
```

## Ōsaka

```
invsOska <- sapply(coa[6:10], inv2UCSCData) |> SimpleList()
rtracklayer::export(invsOska$Osa_Oki, "inversions_v4.0.0_Osa_Oki.bed")
rtracklayer::export(invsOska$Osa_Bar, "inversions_v4.0.0_Osa_Bar.bed")
rtracklayer::export(invsOska$Osa_Kum, "inversions_v4.0.0_Osa_Kum.bed")
rtracklayer::export(invsOska$Osa_Aom, "inversions_v4.0.0_Osa_Aom.bed")
rtracklayer::export(invsOska$Osa_Nor, "inversions_v4.0.0_Osa_Nor.bed")
```

