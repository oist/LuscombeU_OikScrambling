---
title: "Width of the aligned and mapped regions."
author: 
 - "Charles Plessy"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEncoding{UTF-8}
  %\VignetteIndexEntry{Width of the aligned and mapped regions.}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup}
knitr::opts_chunk$set(cache = TRUE, cache.lazy = FALSE)
knitr::opts_knit$set(verbose = TRUE)
```

# Introduction

TBW

# Load R pacakges and data

```{r load_packages_and_data}
library('OikScrambling') |> suppressPackageStartupMessages()
(genomes <- OikScrambling:::loadAllGenomes())
(annots <- OikScrambling:::loadAllAnnotations() |> suppressWarnings())
(load("BreakPoints.Rdata"))
```

See `vignette("LoadGenomicBreaks", package = "OikSyntenies")` for how the
different GBreaks objects are prepared.

# Precompute widths

```{r pre_compute_widths_object}
widths <- SimpleList()
makeWidthsDF <- function (objList) {
  lapply(names(objList), \(name) {
    DF <- mcols(objList[[name]])
    DF$name  <- name
    DF$width <- width(objList[[name]])
    DF$chr   <- seqnames(objList[[name]]) |>  sub(pat = "Chr", rep = "chr")
    DF$query <- DF$score <- DF$rep <- NULL
    DF
  }) |> do.call(what=rbind)
}

widths$gbs     <- makeWidthsDF(gbs)     |> tibble::as_tibble()
widths$unal    <- makeWidthsDF(unal)    |> tibble::as_tibble()
widths$coa     <- makeWidthsDF(coa)     |> tibble::as_tibble()
widths$unmap   <- makeWidthsDF(unmap)   |> tibble::as_tibble()
widths$unalMap <- makeWidthsDF(unalMap) |> tibble::as_tibble()
widths$coa2    <- makeWidthsDF(coa2)    |> tibble::as_tibble()
```

# Width distribution of aligned and mapped regions

_Aligned_ means "before coalescing" and _mapped_ means "after coalescing".

The distribution of alignment widths takes a bimodal appearance after
collapsing.  Is the small peak made of artefacts ?  We will see shortly that the
answer is _no_.

```{r width_after_coalescing}
gg_freq_poly <- function(tibble) {
    ggplot(tibble) +
    aes(width) +
    geom_freqpoly() +
    scale_x_log10()
}

gg_freq_poly(rbind(widths$gbs     |> as.data.frame()|> dplyr::mutate(what = "aligned"),
                   widths$unal    |> as.data.frame()|> dplyr::mutate(what = "unaligned"),
                   widths$coa     |> as.data.frame()|> dplyr::mutate(what = "mapped"),
                   widths$unalMap |> as.data.frame()|> dplyr::mutate(what = "mapped unaligned"),
                   widths$unmap   |> as.data.frame()|> dplyr::mutate(what = "unmaped"),
                   widths$coa2    |> as.data.frame()|> dplyr::mutate(what = "doublecoalesced"))) +
  aes(col = what) +
  geom_freqpoly() +
  scale_x_log10() +
  facet_wrap(~name, scales = "free_y") +
  ggtitle("Distribution of alignment width before and after collapsing")
```

First, the distribution of widths is not the same on long and short arms.
For this reason, it would be unwise to filter by width on some operations such
as coalescing.

## Aligned regions

```{r widths_gbs}
gg_freq_poly(widths$gbs) +
  aes(col=Arm) +
  facet_wrap(~chr, scales = "free_y") +
  ggtitle("Distribution of alignment widths before collapsing, split by arm.")

gg_freq_poly(widths$gbs |> subset(chr == "chr1")) +
  aes(col=Arm) +
  facet_wrap(~name, scales = "free_y", ncol=5) +
  ggtitle("Distribution of alignment widths on chr1 before collapsing, split by genome pair")
```

## Unaligned regions

```{r widths_unaligned}
gg_freq_poly(widths$unal) +
  aes(col=Arm) +
  facet_wrap(~chr, scales = "free_y") +
  ggtitle("Distribution of unaligned regions width before collapsing, split by arm.")

gg_freq_poly(widths$unal |> subset(chr == "chr1")) +
  aes(col=Arm) +
  facet_wrap(~name, scales = "free_y", ncol=5) +
  ggtitle("Distribution of unaligned regions width on chr1 before collapsing, split by genome pair")
```

## Mapped (coalesced) regions

After coalescing, width distribution becomes clearly bimodal, when faceted by
chromosome and arm type.  There is a small peak under 500 bp, found on all arms
except YSR.  The second peak shows two different distributions for long and
short arms.

```{r width_of_coalesced_regions}
gg_freq_poly(widths$coa) +
  aes(col=Arm) +
  facet_wrap(~chr, scales = "free_y") +
  ggtitle("Distribution of alignment widths after collapsing, split by arm.")

gg_freq_poly(widths$coa |> subset(chr == "chr1")) +
  aes(col=Arm) +
  facet_wrap(~name, scales = "free_y", ncol=5) +
  ggtitle("Distribution of alignment widths on chr1 after collapsing, split by genome pair") +
  geom_vline(xintercept = 500)
```

Therefore, if the first peak represents events that we do not want to consider
breaking synteny (either alignment artefacts or insertion/transpositions of
short mobile elements), we can re-coalesce once after removing the shortest
intervals.

## Unmapped regions

```{r width_of_unmapped_regions}
gg_freq_poly(widths$unmap) +
  aes(col=Arm) +
  facet_wrap(~chr, scales = "free_y") +
  ggtitle("Distribution of widths of ummapped regions, split by arm.")

gg_freq_poly(widths$unmap |> subset(chr == "chr1")) +
  aes(col=Arm) +
  facet_wrap(~name, scales = "free_y", ncol=5) +
  ggtitle("Distribution of widths of unmapped regions on chr1 after collapsing, split by genome pair") +
  geom_vline(xintercept = 500)
```

## Mapped unaligned regions

Note the short peak when comparing pairs within the same population.

```{r width_of_unAlmapped_regions}
gg_freq_poly(widths$unalMap) +
  aes(col=Arm) +
  facet_wrap(~chr, scales = "free_y") +
  ggtitle("Distribution of widths of mapped unaligned regions, split by arm.")

gg_freq_poly(widths$unalMap |> subset(chr == "chr1")) +
  aes(col=Arm) +
  facet_wrap(~name, scales = "free_y", ncol=5) +
  ggtitle("Distribution of widths of unmapped regions on chr1 after collapsing, split by genome pair") +
  geom_vline(xintercept = 500)
```

## Double-coalesced regions

```{r re_coalesce}
gg_freq_poly(widths$coa2) +
  aes(col=Arm) +
  facet_wrap(~chr, scales = "free_y") +
  ggtitle("Distribution of alignment widths after double-collapsing, split by arm.")

gg_freq_poly(widths$coa2 |> subset(chr == "chr1")) +
  aes(col=Arm) +
  facet_wrap(~name, scales = "free_y", ncol=5) +
  ggtitle("Distribution of alignment widths on chr1 after double-collapsing, split by genome pair") 
```

# Paired comparison of widths in target and query genomes.

```{r paired_width_analysis}
GBreaks2widthTibble <- function(gb, pair = NULL) {
  df <- as.data.frame(gb)
  if(is.null(df$query.rep)) df$query.rep <- NA
  tb <- tibble::tibble(target     = df$width,        query     = df$query.width,
                       target.rep = ! is.na(df$rep), query.rep = ! is.na(df$query.rep),  # TRUE if overlaps a repeat
                       pair = pair, Arm = df$Arm)
}

gbs.w2w     <- do.call(rbind, lapply(names(gbs), \(name) GBreaks2widthTibble(gbs[[name]],     pair = name)))
unalMap.w2s <- do.call(rbind, lapply(names(gbs), \(name) GBreaks2widthTibble(unalMap[[name]], pair = name)))

table(paste(    gbs.w2w$target.rep,     gbs.w2w$query.rep))
table(paste(unalMap.w2s$target.rep, unalMap.w2s$query.rep))

ggPlotW2W <- function(tibble) {
  ggplot(tibble) +
    aes(target, query) +
    geom_point(alpha = 0.05) +
    geom_density_2d() +
    scale_x_log10() +
    scale_y_log10()
}

ggPlotW2W(gbs.w2w |> dplyr::filter(!is.na(Arm))) + facet_wrap(~Arm) +
  ggtitle("Width of the target and query aligned regions")

ggPlotW2W(unalMap.w2s |> dplyr::filter(!is.na(Arm))) + facet_wrap(~Arm) +
  ggtitle("Width of the target and query mapped unaligned regions")

ggPlotW2W(gbs.w2w) + facet_wrap(~pair) +
  ggtitle("Width of the target and query aligned regions")

ggPlotW2W(unalMap.w2s) + facet_wrap(~pair) +
  ggtitle("Width of the target and query mapped unaligned regions")

ggPlotW2W(gbs.w2w) +
  facet_wrap(~query.rep + target.rep) +
  ggtitle("Width of the target and query aligned regions, matching or not matching repeats")

ggPlotW2W(unalMap.w2s) +
  facet_wrap(~query.rep + target.rep) +
  ggtitle("Width of the target and query mapped unaligned regions, matching or not matching repeats")

ggplot(unalMap.w2s) +
  aes(target / query, col = paste(target.rep, query.rep) ) +
  scale_x_log10() +
  geom_freqpoly() +
  ggtitle("In presence of a repeat, target width tends to be longer than query") +
  geom_vline(xintercept = 1)
```

# Structural variants

## Width of inverted regions

Many inversions are shorter than 1Â kbp.

```{r width_of_inversions}
invs <- sapply(coa, function(gb) filterInversions(flagInversions(gb))) |> SimpleList()
sapply(invs, length)

# Sanity check that we detect inversions on both strands
sapply(invs, \(x) {summary(decode(strand(x)))})

widths$invs <- makeWidthsDF(invs)

gg_freq_poly(widths$invs) +
  aes(col=Arm) +
  facet_wrap(~chr, scales = "free_y") +
  ggtitle("Distribution of alignment widths for inverted regions, split by arm.") +
  geom_vline(xintercept = 1000)
```

## Width of gaps next to the inverted regions

```{r width_of_inversions}
inv.lgaps <- sapply(coa, leftInversionGaps) |> SimpleList()
inv.lgaps[ 1:5]  <- sapply(inv.lgaps[ 1:5],  flagLongShort, longShort$Oki)
inv.lgaps[ 6:10] <- sapply(inv.lgaps[ 6:10], flagLongShort, longShort$Osa)
inv.lgaps[11:15] <- sapply(inv.lgaps[11:15], flagLongShort, longShort$Bar)
sapply(inv.lgaps, length)

widths$invs.lgaps <- makeWidthsDF(inv.lgaps)

gg_freq_poly(widths$invs.lgaps) +
  aes(col=Arm) +
  facet_wrap(~chr, scales = "free_y") +
  ggtitle("Distribution widths of left gaps next to inverted regions, split by arm.") +
  geom_vline(xintercept = 1000)
```
