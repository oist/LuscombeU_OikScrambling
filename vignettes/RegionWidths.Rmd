---
title: "Width of the aligned and mapped regions."
author: 
 - "Charles Plessy"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEncoding{UTF-8}
  %\VignetteIndexEntry{Width of the aligned and mapped regions.}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup}
knitr::opts_chunk$set(cache = TRUE, cache.lazy = FALSE)
knitr::opts_knit$set(verbose = TRUE)
```

# Introduction

TBW

# Load R pacakges and data

```{r load_packages_and_data}
library('OikScrambling') |> suppressPackageStartupMessages()
(genomes <- OikScrambling:::loadAllGenomes())
(annots <- OikScrambling:::loadAllAnnotations() |> suppressWarnings())
(load("BreakPoints.Rdata"))
```

# Unaligned and unmapped regions

```{r unal_unmap}
unal  <- sapply(gbs, cleanGaps) |> SimpleList()
unal[ 1:5]  <- sapply(unal[ 1:5],  flagLongShort, longShort$Oki)
unal[ 6:10] <- sapply(unal[ 6:10], flagLongShort, longShort$Osa)
unal[11:15] <- sapply(unal[11:15], flagLongShort, longShort$Bar)

unmap <- sapply(coa, cleanGaps) |> SimpleList()
unmap[ 1:5]  <- sapply(unmap[ 1:5],  flagLongShort, longShort$Oki)
unmap[ 6:10] <- sapply(unmap[ 6:10], flagLongShort, longShort$Osa)
unmap[11:15] <- sapply(unmap[11:15], flagLongShort, longShort$Bar)
```

# Precompute widths

```{r pre_compute_widths_object}
widths <- SimpleList()
makeWidthsDF <- function (objList) {
  lapply(names(objList), \(name) {
    DF <- mcols(objList[[name]])
    DF$name  <- name
    DF$width <- width(objList[[name]])
    DF$chr   <- seqnames(objList[[name]]) |>  sub(pat = "Chr", rep = "chr")
    DF$query <- DF$score <- NULL
    DF
  }) |> do.call(what=rbind)
}

widths$gbs    <- makeWidthsDF(gbs)
widths$unal   <- makeWidthsDF(unal)
widths$coa    <- makeWidthsDF(coa)
widths$unmap  <- makeWidthsDF(unmap)
widths$coa2   <- makeWidthsDF(coa2)
```

# Width distribution of aligned and mapped regions

_Aligned_ means "before coalescing" and _mapped_ means "after coalescing".

The distribution of alignment widths takes a bimodal appearance after
collapsing.  Is the small peak made of artefacts ?  We will see shortly that the
answer is _no_.

```{r width_after_coalescing}
gg_freq_poly <- function(DF) {
    ggplot(DF |> as("data.frame")) +
    aes(width) +
    geom_freqpoly() +
    scale_x_log10()
}

gg_freq_poly(rbind(widths$gbs   |> as.data.frame()|> dplyr::mutate(what = "aligned"),
                   widths$unal  |> as.data.frame()|> dplyr::mutate(what = "unaligned"),
                   widths$coa   |> as.data.frame()|> dplyr::mutate(what = "mapped"),
                   widths$unmap |> as.data.frame()|> dplyr::mutate(what = "unmaped"),
                   widths$coa2  |> as.data.frame()|> dplyr::mutate(what = "doublecoalesced"))) +
  aes(col = what) +
  geom_freqpoly() +
  scale_x_log10() +
  facet_wrap(~name, scales = "free_y") +
  ggtitle("Distribution of alignment width before and after collapsing")
```

First, the distribution of widths is not the same on long and short arms.
For this reason, it would be unwise to filter by width on some operations such
as coalescing.

## Aligned regions

```{r widths_gbs}
gg_freq_poly(widths$gbs) +
  aes(col=Arm) +
  facet_wrap(~chr, scales = "free_y") +
  ggtitle("Distribution of alignment widths before collapsing, split by arm.")

gg_freq_poly(widths$gbs |> subset(chr == "chr1")) +
  aes(col=Arm) +
  facet_wrap(~name, scales = "free_y", ncol=5) +
  ggtitle("Distribution of alignment widths on chr1 before collapsing, split by genome pair")
```

## Unaligned regions

```{r widths_unaligned}
gg_freq_poly(widths$unal) +
  aes(col=Arm) +
  facet_wrap(~chr, scales = "free_y") +
  ggtitle("Distribution of unaligned regions width before collapsing, split by arm.")

gg_freq_poly(widths$unal |> subset(chr == "chr1")) +
  aes(col=Arm) +
  facet_wrap(~name, scales = "free_y", ncol=5) +
  ggtitle("Distribution of unaligned regions width on chr1 before collapsing, split by genome pair")
```

## Coalesced regions

After coalescing, width distribution becomes clearly bimodal, when faceted by
chromosome and arm type.  There is a small peak under 500 bp, found on all arms
except YSR.  The second peak shows two different distributions for long and
short arms.

```{r width_of_coalesced_regions}
gg_freq_poly(widths$coa) +
  aes(col=Arm) +
  facet_wrap(~chr, scales = "free_y") +
  ggtitle("Distribution of alignment widths after collapsing, split by arm.")

gg_freq_poly(widths$coa |> subset(chr == "chr1")) +
  aes(col=Arm) +
  facet_wrap(~name, scales = "free_y", ncol=5) +
  ggtitle("Distribution of alignment widths on chr1 after collapsing, split by genome pair") +
  geom_vline(xintercept = 500)
```

Therefore, if the first peak represents events that we do not want to consider
breaking synteny (either alignment artefacts or insertion/transpositions of
short mobile elements), we can re-coalesce once after removing the shortest
intervals.

The computation is done in `vignette("LoadGenomicBreaks", package = "OikSyntenies")`

```{r double_coalescing_algorithm}
sapply(gbs, length)
sapply(coa, length)
sapply(coa2, length)
```

## Double-coalesced regions

```{r re_coalesce}
gg_freq_poly(widths$coa2) +
  aes(col=Arm) +
  facet_wrap(~chr, scales = "free_y") +
  ggtitle("Distribution of alignment widths after double-collapsing, split by arm.")

gg_freq_poly(widths$coa2 |> subset(chr == "chr1")) +
  aes(col=Arm) +
  facet_wrap(~name, scales = "free_y", ncol=5) +
  ggtitle("Distribution of alignment widths on chr1 after double-collapsing, split by genome pair") 
```

# Paired comparison of widths in target and query genomes.

```{r paired_width_analysis}
GBreaks2widthTibble <- function(gb, pair = NULL) {
  df <- as.data.frame(gb)
  tb <- tibble::tibble(target = df$width, query = df$query.width, pair = pair)
}

tb <- gbs$Oki_Osa |> GBreaks2widthTibble(pair = "Oki_Osa")

ggplot(tb) +
  aes(target, query) +
  geom_point() +
  geom_density_2d() +
  scale_x_log10() +
  scale_y_log10() +
  ggtitle("Width of the target and query aligned regions")

x <- filterColinearRegions(flagColinearAlignments(gbs$Oki_Osa))
# Need to substract 1 because some ranges are adjascent (no gap)
z <- GBreaks(target = cleanGaps(x-1), query = cleanGaps(x$query -1))

z$reps <- FALSE
z$reps[unique(queryHits(findOverlaps(z, reps)))] <- TRUE

y <- sort(c(x,z), ignore.strand = TRUE)
names(y) <- NULL
as.data.frame(y) |> head(60)

tb2 <- z|> GBreaks2widthTibble(pair = "Oki_Osa")
tb2$reps <- z$reps

ggplot(tb2) +
  aes(target, query) +
  geom_point() +
  geom_density_2d() +
  scale_x_log10() +
  scale_y_log10() +
  ggtitle("Width of the target and query unaligned regions")

ggplot(tb2) +
  aes(target, query) +
  geom_point() +
  geom_density_2d(aes(col = reps)) +
  scale_x_log10() +
  scale_y_log10() +
  facet_wrap(~reps) +
  ggtitle("Width of the target and query unaligned regions, matching or not matching repeats")


ggplot(tb2) +
  aes(target / query, col = reps) +
  scale_x_log10() +
  geom_freqpoly() +
  ggtitle("In presence of a repeat, target width tends to be longer than query") +
  geom_vline(xintercept = 1)
```

# Analysis of the interval regions

Interval regions interrupt alignments or colinearity.  What do they contain ?

## Unaligned regions

```{r unaligned_regions}
reps <- rtracklayer::import(system.file("extdata/Annotations/OKI2018_I69.v2/OKI2018_I69.repeats.gff", package = "BreakpointsData"))
reps$Class <- reps$Target |>
  sub(pat = '".*', rep = "") |>
  sub(pat = "Motif:", rep = "") |>
  sub(pat = "\\(.+)n", rep = "tandem") |>
  sub(pat = "_family.*", rep = "") |>
  sub(pat = "SINE.*", rep = "SINE") |>
  sub(pat = "i69_juicer.*", rep = "unknown") |>
  sub(pat = ".*-rich", rep = "LowComplexity") |>
  sub(pat = "rnd.*", rep = "rnd") |>
  factor()

table(reps$Class)

reps.reduced <- reduce(reps, ignore.strand = TRUE)
# They are short.
summary(width(reps.reduced))

Oki_pairs <- c("Oki_Osa", "Oki_Bar", "Oki_Kum", "Oki_Aom", "Oki_Nor")

(reps_gbs <- tibble::tibble(
    pairname   = Oki_pairs,
    total      = length(reps.reduced),
    match_unal = sapply(unal[Oki_pairs], \(gb) length(subsetByOverlaps(reps.reduced, gb))),
    match_al   = sapply(gbs[Oki_pairs], \(gb) length(subsetByOverlaps(reps.reduced, gb))),
    aligned   = match_al   / total * 100,
    unaligned = match_unal / total * 100,
    sum = aligned + unaligned
))

ggplot(reps_gbs |> tidyr::pivot_longer(c("aligned", "unaligned"))) +
  aes(name, value) +
  ggtitle("Matches of repeats to aligned or unaligned regions") +
  scale_y_continuous(limits = c(0, 100)) +
  ylab("Percent of the repeat regions") +
  xlab("Matching to region:") +
  geom_boxplot() +
  geom_point(aes(col = pairname))
```

## Colinearity interruptors (unmapped regions ?)

```{r unaligned_regions2}
(reps_coa <- tibble::tibble(
    pairname    = Oki_pairs,
    total       = length(reps.reduced),
    match_unmap = sapply(unmap[Oki_pairs], \(gb) length(subsetByOverlaps(reps.reduced, gb))),
    match_map   = sapply(   coa[Oki_pairs], \(gb) length(subsetByOverlaps(reps.reduced, gb))),
    mapped      = match_map   / total * 100,
    unmapped    = match_unmap / total * 100,
    sum = mapped + unmapped
))

ggplot(reps_coa |> tidyr::pivot_longer(c("mapped", "unmapped"))) +
  aes(name, value) +
  ggtitle("Matches of repeats to mapped or unmaped regions") +
  scale_y_continuous(limits = c(0, 100)) +
  ylab("Percent of the repeat regions") +
  xlab("Matching to region:") +
  geom_boxplot() +
  geom_point(aes(col = pairname))
```

## Repeat annotations

```{r repeat_annotations}
reps_in <- list()
reps_in$total <- sapply(Oki_pairs, \(.) table(reps$Class)) 
reps_in$unal <- sapply(unal[Oki_pairs], \(gb) {
    ov <- subsetByOverlaps(reps, gb, ignore.strand = TRUE)
    table(ov$Class)
  })
reps_in$gbs <- sapply(gbs[Oki_pairs], \(gb) {
    ov <- subsetByOverlaps(reps, gb, ignore.strand = TRUE)
    table(ov$Class)
  })
reps_in$unmap <- sapply(unmap[Oki_pairs], \(gb) {
    ov <- subsetByOverlaps(reps, gb, ignore.strand = TRUE)
    table(ov$Class)
  })
reps_in$map <- sapply(coa[Oki_pairs], \(gb) {
    ov <- subsetByOverlaps(reps, gb, ignore.strand = TRUE)
    table(ov$Class)
  })

toLong <- function(m, Region = NULL) {
  m <- tibble::as_tibble(m, rownames = "Class") |>
    tidyr::pivot_longer(c("Oki_Osa", "Oki_Bar", "Oki_Aom", "Oki_Nor"))
  if (! is.null(Region))
    m <- dplyr::mutate(m, Region = Region)
  m
}

reps_in.norm <- lapply(reps_in, \(x) x / reps_in$total)


reps_in.long <- rbind(
  toLong(reps_in$unmap, "unmap"),
  toLong(reps_in$map,   "map"),
  toLong(reps_in$gbs,   "gbs"),
  toLong(reps_in$unal, "unal")
)

reps_in.norm.long <- rbind(
  toLong(reps_in.norm$unmap, "unmap"),
  toLong(reps_in.norm$map,   "map"),
  toLong(reps_in.norm$gbs,   "gbs"),
  toLong(reps_in.norm$unal, "unal")
)

ggplot(reps_in.long) +
  aes(Region, value) +
  geom_point(aes(col = name)) +
  facet_grid(~Class, scales = "free")

ggplot(reps_in.norm.long) +
  aes(Region, value) +
  geom_point(aes(col = name)) +
  facet_grid(~Class, scales = "free") +
  ylab("Fraction overlaping") +
  ggtitle("Repeats overlaping with (un)aligned/mapped regions")
```


# Structural variants

## Trivial inversions

### Documentation

Details can be found in `vignette("Introduction to GenomicBreaks", package = "GenomicBreaks")`,
in `vignette("Structural Variants", package = "GenomicBreaks")`,
and `?GenomicBreaks::flagInversions`

See also the [vignette](https://bioconductor.org/packages/release/bioc/vignettes/Gviz/inst/doc/Gviz.html)
of Gviz.

### Number of trivial inversions

More inversions are found after coalescing colinear blocks because of situations
where `+ - +` was `+ - - +` before collapsing. 

```{r detect_trivial_invertions}
sapply(gbs, function(gb) sum(flagInversions(gb)$inv))
sapply(coa, function(gb) sum(flagInversions(gb)$inv))
sapply(coa2, function(gb) sum(flagInversions(gb)$inv))
```

### Width of inverted regions

Many inversions are shorter than 1Â kbp.

```{r width_of_inversions}
invs <- sapply(coa, function(gb) filterInversions(flagInversions(gb))) |> SimpleList()
sapply(invs, length)

# Sanity check that we detect inversions on both strands
sapply(invs, \(x) {summary(decode(strand(x)))})

widths$invs <- makeWidthsDF(invs)

gg_freq_poly(widths$invs) +
  aes(col=Arm) +
  facet_wrap(~chr, scales = "free_y") +
  ggtitle("Distribution of alignment widths for inverted regions, split by arm.") +
  geom_vline(xintercept = 1000)
```

### Width of gaps next to the inverted regions

```{r width_of_inversions}
inv.lgaps <- sapply(coa, leftInversionGaps) |> SimpleList()
inv.lgaps[ 1:5]  <- sapply(inv.lgaps[ 1:5],  flagLongShort, longShort$Oki)
inv.lgaps[ 6:10] <- sapply(inv.lgaps[ 6:10], flagLongShort, longShort$Osa)
inv.lgaps[11:15] <- sapply(inv.lgaps[11:15], flagLongShort, longShort$Bar)
sapply(inv.lgaps, length)

widths$invs.lgaps <- makeWidthsDF(inv.lgaps)

gg_freq_poly(widths$invs.lgaps) +
  aes(col=Arm) +
  facet_wrap(~chr, scales = "free_y") +
  ggtitle("Distribution widths of left gaps next to inverted regions, split by arm.") +
  geom_vline(xintercept = 1000)
```
