---
title: "Width of the aligned and mapped regions."
author: 
 - "Charles Plessy"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEncoding{UTF-8}
  %\VignetteIndexEntry{Width of the aligned and mapped regions.}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup}
knitr::opts_chunk$set(cache = TRUE, cache.lazy = FALSE)
knitr::opts_knit$set(verbose = TRUE)
```

# Load R pacakges and data

```{r load_packages_and_data, dependson="setup"}
library('OikScrambling') |> suppressPackageStartupMessages()
library('ggplot2')
(genomes <- OikScrambling:::loadAllGenomes())
(load("BreakPoints.Rdata"))
```

See `vignette("LoadGenomicBreaks", package = "OikScrambling")` for how the
different GBreaks objects are prepared.

# Precompute widths

```{r pre_compute_widths_object, dependson="load_packages_and_data"}
widths <- SimpleList()
makeWidthsDF <- function (objList) {
  lapply(names(objList), \(name) {
    DF <- mcols(objList[[name]])
    if (nrow(DF) == 0) return(DataFrame())
    if (is.null(DF$Arm)) DF$Arm <- NA
    DF$name  <- name
    DF$width <- width(objList[[name]])
    DF$chr   <- seqnames(objList[[name]]) |>
      sub(pat = "Chr",    rep = "chr")    |>
      sub(pat = "BNJZ.*", rep = "Ply")    |>
      sub(pat = "BNKA.*", rep = "Ros")    |>
      sub(pat = "BJTB.*", rep = "Rob")    |>
      sub(pat = "^R.*",   rep = "Sav")    |>
      sub(pat = "^2L$",   rep = "Dro")    |>
      sub(pat = "^2R$",   rep = "Dro")    |>
      sub(pat = "^3L$",   rep = "Dro")    |>
      sub(pat = "^3R$",   rep = "Dro")    |>
      sub(pat = "^4$",    rep = "Dro")    |>
      sub(pat = "^X$",    rep = "Dro")    |>
      sub(pat = "^Y$",    rep = "Dro")   

    DF$query <- DF$score <- DF$rep <- DF$transcripts <- NULL
    DF$dist  <- OikScrambling:::compDistance(DF$name)
    DF
  }) |> do.call(what=rbind)
}

# Remove flags from objects so that dataframe conversion yields equal number of columns
unal  <- sapply(unal,  \(gb) {gb$flag <- NA; gb}) |> SimpleList()
unmap <- sapply(unmap, \(gb) {gb$flag <- NA; gb}) |> SimpleList()
unalMap<-sapply(unalMap,\(gb){gb$flag <- NA; gb}) |> SimpleList()

widths$gbs     <- makeWidthsDF(gbs)     |> tibble::as_tibble()
widths$unal    <- makeWidthsDF(unal)    |> tibble::as_tibble()
widths$coa     <- makeWidthsDF(coa)     |> tibble::as_tibble()
widths$unmap   <- makeWidthsDF(unmap)   |> tibble::as_tibble()
widths$unalMap <- makeWidthsDF(unalMap) |> tibble::as_tibble()
widths$tra     <- makeWidthsDF(tra)     |> tibble::as_tibble()
widths$tra2    <- makeWidthsDF(tra2)    |> tibble::as_tibble()
widths$coa2    <- makeWidthsDF(coa2)    |> tibble::as_tibble()
```

# Plot all width distributions

This is useful to verify by eye that collections of distributions in the same
distance group ressemble each other.

```{r width_after_processing_steps, dependson="pre_compute_widths_object", fig.width=12, fig.height=8}
gg_freq_poly <- function(tibble) {
    ggplot(tibble) +
    aes(width) +
    geom_freqpoly() +
    scale_x_log10()
}

p <-
gg_freq_poly(rbind(widths$gbs     |> as.data.frame()|> dplyr::mutate(what = "aligned"),
                   widths$unal    |> as.data.frame()|> dplyr::mutate(what = "unaligned"),
                   widths$coa     |> as.data.frame()|> dplyr::mutate(what = "mapped"),
                   widths$unalMap |> as.data.frame()|> dplyr::mutate(what = "mapped unaligned"),
                   widths$unmap   |> as.data.frame()|> dplyr::mutate(what = "unmaped"),
                   widths$coa2    |> as.data.frame()|> dplyr::mutate(what = "doublecoalesced"))) +
  aes(col = what) +
  ggtitle("Distribution of alignment width before and after collapsing")

# Showing all individual distributions, to demonstrate we can pool some.
p + facet_wrap(~dist + name, scales = "free_y")
```

```{r width_after_processing_steps2, dependson="width_after_processing_steps", fig.width=12}
# Aggregating by distance class
p + facet_wrap(~dist, scales = "free_y")
```

# Width distribution of aligned and mapped regions

## Aligned regions

_Aligned_ means "before coalescing" and _mapped_ means "after coalescing".

The distribution of alignment widths takes a bimodal appearance after
collapsing.  Is the small peak made of artefacts ?  We will see shortly that the
answer is _no_.

```{r width_before_coalescing, dependson="pre_compute_widths_object", fig.width=8}
gg_freq_poly(widths$gbs) +
  facet_wrap(~name, scales = "free_y") +
  ggtitle("Distribution of alignment widths before collapsing")

gg_freq_poly(widths$gbs |> dplyr::filter(dist %in% c("Oki – North", "North – North", "same_pop"))) +
  aes(col=name) +
  facet_wrap(~dist, scales = "free_y", ncol = 1) +
  ggtitle("Distribution of alignment widths before collapsing, collated by distance group")
```

```{r width_before_coalescing2, dependson="pre_compute_widths_object", fig.height=12, fig.width=8}

gg_freq_poly(widths$gbs |> dplyr::mutate(dist = dist |> sub(pat = "Int.*", rep = "Ciona") |>
                                                        sub(pat = "Dm.*", rep = "Drosophila"))) +
  aes(width, after_stat(density), col=name) +
  facet_wrap(~dist, scales = "free_y", ncol = 1) +
  ggtitle("Distribution of alignment widths before collapsing, collated by distance group")
```

First, the distribution of widths is not the same on long and short arms.
For this reason, it would be unwise to filter by width on some operations such
as coalescing.

```{r widths_gbs, dependson="pre_compute_widths_object"}
gg_freq_poly(widths$gbs) +
  aes(col=Arm) +
  facet_wrap(~chr, scales = "free_y") +
  ggtitle("Distribution of alignment widths before collapsing, split by arm.")

gg_freq_poly(widths$gbs |> subset(chr == "chr1")) +
  aes(col=Arm) +
  facet_wrap(~name, scales = "free_y", ncol=5) +
  ggtitle("Distribution of alignment widths on chr1 before collapsing, split by genome pair")

gg_freq_poly(widths$gbs |> subset(chr %in% c("chr1", "chr2", "PAR"))) +
  aes(col=Arm) +
  facet_wrap(~dist, scales = "free_y", nrow=1) +
  ggtitle("Distribution of alignment widths before collapsing, split by distance group")
```

## Unaligned regions

Unaligned regions show no difference of width between arms, except perhaps at
the “same population” level.

```{r widths_unaligned, dependson="pre_compute_widths_object"}
gg_freq_poly(widths$unal) +
  aes(col=Arm) +
  facet_wrap(~chr, scales = "free_y") +
  ggtitle("Distribution of unaligned regions width before collapsing, split by arm.")

gg_freq_poly(widths$unal |> subset(chr == "chr1")) +
  aes(col=Arm) +
  facet_wrap(~name, scales = "free_y", ncol=5) +
  ggtitle("Distribution of unaligned regions width on chr1 before collapsing, split by genome pair")

gg_freq_poly(widths$unal |> subset(chr %in% c("chr1", "chr2", "PAR"))) +
  aes(col=Arm) +
  facet_wrap(~dist, scales = "free_y", ncol=1) +
  ggtitle("Distribution of unaligned region widths before collapsing, split by distance group") +
  geom_vline(xintercept = 300) +
  scale_x_log10("Width (vertical bar at 300 bp)")
```

## Mapped (coalesced) regions

After coalescing, width distribution becomes clearly bimodal, when faceted by
chromosome and arm type.  There is a small peak under 500 bp, found on all arms
except YSR.  The second peak shows two different distributions for long and
short arms.

```{r width_after_coalescing, dependson="pre_compute_widths_object", fig.height=12, fig.width=8}
gg_freq_poly(widths$coa |> dplyr::mutate(dist = dist |> sub(pat = "Int.*", rep = "Ciona") |>
                                                        sub(pat = "Dm.*", rep = "Drosophila"))) +
  aes(width, after_stat(density), col=name) +
  facet_wrap(~dist, scales = "free_y", ncol = 1) +
  ggtitle("Distribution of alignment widths after collapsing, collated by distance group")
```

```{r width_after_coalescing2, dependson="pre_compute_widths_object"}
gg_freq_poly(widths$coa) +
  aes(col=Arm) +
  facet_wrap(~chr, scales = "free_y") +
  ggtitle("Distribution of alignment widths after collapsing, split by arm.")

gg_freq_poly(widths$coa ) +
  aes(col=Arm) +
  facet_wrap(~name, scales = "free_y", ncol=5) +
  ggtitle("Distribution of alignment widths on chr1 after collapsing, split by genome pair")+
  geom_vline(xintercept = 500)

gg_freq_poly(widths$coa |> subset(chr %in% c("chr1", "chr2", "PAR"))) +
  aes(col=Arm) +
  facet_wrap(~dist, scales = "free_y", ncol=1) +
  ggtitle("Distribution of alignment widths after collapsing, split by distance group")
```

Therefore, if the first peak represented events that we do not want to consider
breaking synteny (either alignment artefacts or insertion/transpositions of
short mobile elements), we could re-coalesce once after removing the shortest
intervals.  We tried some width cutoffs on the coalescing step, but at 500 bp,
the coverage of the genome by the resulting mapped regions is already decreasing
(`vignette("CoalescingCutoffs", package = "OikScrambling")`).

## Unmapped regions

Unmapped regions are a bit longer on the short arm in Oki – North comparisons…

```{r width_of_unmapped_regions}
gg_freq_poly(widths$unmap) +
  aes(col=Arm) +
  facet_wrap(~chr, scales = "free_y") +
  ggtitle("Distribution of unmapped regions width after collapsing, split by arm.")

gg_freq_poly(widths$unmap) +
  aes(col=Arm) +
  facet_wrap(~name, scales = "free_y", ncol=5) +
  ggtitle("Distribution of unmapped regions width after collapsing, split by genome pair")

gg_freq_poly(widths$unmap |> subset(chr %in% c("chr1", "chr2", "PAR"))) +
  aes(col=Arm) +
  facet_wrap(~dist, scales = "free_y", nrow=1) +
  ggtitle("Distribution of unmapped region widths after collapsing, split by distance group") +
  geom_vline(xintercept = 300) +
  scale_x_log10("Width (vertical bar at 300 bp)")
```

## Mapped unaligned regions

Note the short peak when comparing pairs within the same population.

```{r width_of_unAlmapped_regions, dependson="pre_compute_widths_object"}
gg_freq_poly(widths$unalMap) +
  aes(col=Arm) +
  facet_wrap(~chr, scales = "free_y") +
  ggtitle("Distribution of widths of mapped unaligned regions, split by arm.")

gg_freq_poly(widths$unalMap) +
  aes(col=Arm) +
  facet_wrap(~name, scales = "free_y", ncol=5) +
  ggtitle("Distribution of widths of mapped unaligned regions, split by genome pair")

gg_freq_poly(widths$unalMap |> subset(chr %in% c("chr1", "chr2", "PAR"))) +
  aes(col=Arm) +
  facet_wrap(~dist, scales = "free_y", nrow=1) +
  ggtitle("Distribution of widths of mapped unaligned regions, split by distance group") +
  geom_vline(xintercept = 300) +
  scale_x_log10("Width (vertical bar at 300 bp)")
```

## Translocated regions

### Whole region

Reminder: here we measure the distance between the two colinear pairs that are
separated by the translocated pair.

```{r width_of_translocated_regions, dependson="pre_compute_widths_object"}
gg_freq_poly(widths$tra) +
  aes(col=Arm) +
  facet_wrap(~chr, scales = "free_y") +
  ggtitle("Distribution of widths of translocated regions, split by arm.")

gg_freq_poly(widths$tra) +
  aes(col=Arm) +
  facet_wrap(~name, scales = "free_y", ncol=5) +
  ggtitle("Distribution of widths of translocated regions, split by genome pair")

gg_freq_poly(widths$tra |> subset(chr %in% c("chr1", "chr2", "PAR"))) +
  aes(col=Arm) +
  facet_wrap(~dist, scales = "free_y", nrow=1) +
  ggtitle("Distribution of widths of translocated regions, split by distance group") +
  geom_vline(xintercept = 300) +
  scale_x_log10("Width (vertical bar at 300 bp)")
```


### Whole region, after removal

Small peak in _“same pop”_ disapears by design.  Total number in the main peak
also decreases, because they may pass the size filter on the _query_ genome.


```{r width_of_translocated_regions, dependson="pre_compute_widths_object"}
gg_freq_poly(widths$tra2) +
  aes(col=Arm) +
  facet_wrap(~chr, scales = "free_y") +
  ggtitle("Distribution of widths of translocated regions (after removal), split by arm.")

gg_freq_poly(widths$tra2) +
  aes(col=Arm) +
  facet_wrap(~name, scales = "free_y", ncol=5) +
  ggtitle("Distribution of widths of translocated regions (after removal), split by genome pair")

gg_freq_poly(widths$tra2 |> subset(chr %in% c("chr1", "chr2", "PAR"))) +
  aes(col=Arm) +
  facet_wrap(~dist, scales = "free_y", nrow=1) +
  ggtitle("Distribution of widths of translocated regions (after removal), split by distance group") +
  geom_vline(xintercept = 300) +
  scale_x_log10("Width (vertical bar at 300 bp)")
```

### Aligned, before removal

```{r width_of_translocated_regions_coa_aligned, dependson="pre_compute_widths_object"}
widths$tra_coa_aln   <- makeWidthsDF(sapply(coa, \(gb) gb |> flagTranslocations() |> filterTranslocations())) |> tibble::as_tibble()

gg_freq_poly(widths$tra_coa_aln) +
  aes(col=Arm) +
  facet_wrap(~chr, scales = "free_y") +
  ggtitle("Distribution of widths of translocated regions (aligned), split by arm.")

gg_freq_poly(widths$tra_coa_aln) +
  aes(col=Arm) +
  facet_wrap(~name, scales = "free_y", ncol=5) +
  ggtitle("Distribution of widths of translocated regions (aligned), split by genome pair")

gg_freq_poly(widths$tra_coa_aln |> subset(chr %in% c("chr1", "chr2", "PAR"))) +
  aes(col=Arm) +
  facet_wrap(~dist, scales = "free_y", nrow=1) +
  ggtitle("Distribution of widths of translocated regions (aligned), split by distance group") +
  geom_vline(xintercept = 300) +
  scale_x_log10("Width (vertical bar at 300 bp)")
```

### Aligned, after removal

```{r width_of_translocated_regions_coa2_aligned, dependson="pre_compute_widths_object"}
widths$tra_coa2_aln   <- makeWidthsDF(sapply(coa2, \(gb) gb |> flagTranslocations() |> filterTranslocations())) |> tibble::as_tibble()

gg_freq_poly(widths$tra_coa2_aln) +
  aes(col=Arm) +
  facet_wrap(~chr, scales = "free_y") +
  ggtitle("Distribution of widths of translocated regions (aligned, after removal), split by arm.")

gg_freq_poly(widths$tra_coa2_aln) +
  aes(col=Arm) +
  facet_wrap(~name, scales = "free_y", ncol=5) +
  ggtitle("Distribution of widths of translocated regions (aligned, after removal), split by genome pair")

gg_freq_poly(widths$tra_coa2_aln |> subset(chr %in% c("chr1", "chr2", "PAR"))) +
  aes(col=Arm) +
  facet_wrap(~dist, scales = "free_y", nrow=1) +
  ggtitle("Distribution of widths of translocated regions (aligned, after removal), split by distance group") +
  geom_vline(xintercept = 300) +
  scale_x_log10("Width (vertical bar at 300 bp)")
```

## Double-coalesced regions

```{r re_coalesce, dependson="pre_compute_widths_object"}
gg_freq_poly(widths$coa2) +
  aes(col=Arm) +
  facet_wrap(~chr, scales = "free_y") +
  ggtitle("Distribution of alignment widths after double-collapsing, split by arm.")

gg_freq_poly(widths$coa2) +
  aes(col=Arm) +
  facet_wrap(~name, scales = "free_y", ncol=5) +
  ggtitle("Distribution of widthsof alignment widths after double-collapsing, split by genome pair")

gg_freq_poly(widths$coa2 |> subset(chr %in% c("chr1", "chr2", "PAR"))) +
  aes(col=Arm) +
  facet_wrap(~dist, scales = "free_y", nrow=1) +
  ggtitle("Distribution of alignment widths after double-collapsing, split by distance group") +
  geom_vline(xintercept = 500) +
  scale_x_log10("Width (vertical bar at 500 bp)")
```

# Paired comparison of widths in target and query genomes.

```{r paired_width_analysis}
GBreaks2widthTibble <- function(gb, pair = NULL) {
  df <- as.data.frame(gb)
  if(is.null(df$Arm))       df$Arm        <- NA
  if(is.null(df$rep))       df$rep        <- NA
  if(is.null(df$query.rep)) df$query.rep  <- NA
  tibble::tibble(target     = df$width,        query     = df$query.width,
                 target.rep = ! is.na(df$rep), query.rep = ! is.na(df$query.rep),  # TRUE if overlaps a repeat
                 pair = pair, Arm = df$Arm,
                 dist = OikScrambling:::compDistance(pair))
}

gbs.w2w     <- do.call(rbind, lapply(names(gbs),      \(name) GBreaks2widthTibble(gbs[[name]],      pair = name)))
unalMap.w2s <- do.call(rbind, lapply(names(unalMap),  \(name) GBreaks2widthTibble(unalMap[[name]],  pair = name)))
tra.w2s     <- do.call(rbind, lapply(names(tra),      \(name) GBreaks2widthTibble(tra[[name]],      pair = name)))
tra2.w2s    <- do.call(rbind, lapply(names(tra2),     \(name) GBreaks2widthTibble(tra2[[name]],     pair = name)))

rbind (
  aligned = table(paste(    gbs.w2w$target.rep,     gbs.w2w$query.rep)),
  unalMap = table(paste(unalMap.w2s$target.rep, unalMap.w2s$query.rep)),
  transpo = table(paste(    tra.w2s$target.rep,     tra.w2s$query.rep))
)

ggPlotW2W <- function(tibble) {
  ggplot(tibble) +
    aes(target, query) +
    geom_point(alpha = 0.05) +
    geom_density_2d() +
    scale_x_log10() +
    scale_y_log10()
}

ggPlotW2W(gbs.w2w |> dplyr::filter(!is.na(Arm))) + facet_wrap(~Arm) +
  ggtitle("Width of the target and query aligned regions")

ggPlotW2W(unalMap.w2s |> dplyr::filter(!is.na(Arm))) + facet_wrap(~Arm) +
  ggtitle("Width of the target and query mapped unaligned regions")

ggPlotW2W(gbs.w2w) + facet_wrap(~pair) +
  ggtitle("Width of the target and query aligned regions")

ggPlotW2W(gbs.w2w) + facet_wrap(~dist) +
  ggtitle("Width of the target and query aligned regions")

ggPlotW2W(unalMap.w2s) + facet_wrap(~pair) +
  ggtitle("Width of the target and query mapped unaligned regions")

ggPlotW2W(tra.w2s |> dplyr::filter(!is.na(Arm))) + facet_wrap(~pair) +
  ggtitle("Width of the target and query translocated regions")

ggPlotW2W(tra.w2s |> dplyr::filter(!is.na(Arm))) + facet_wrap(~dist) +
  ggtitle("Width of the target and query translocated regions")

ggPlotW2W(tra2.w2s |> dplyr::filter(!is.na(Arm))) + facet_wrap(~pair) +
  ggtitle("Width of the target and query translocated regions")

ggPlotW2W(tra2.w2s |> dplyr::filter(!is.na(Arm))) + facet_wrap(~dist) +
  ggtitle("Width of the target and query translocated regions")

ggPlotW2W(gbs.w2w) +
  facet_wrap(~query.rep + target.rep) +
  ggtitle("Width of the target and query aligned regions, matching or not matching repeats")

ggPlotW2W(unalMap.w2s) +
  facet_wrap(~query.rep + target.rep) +
  ggtitle("Width of the target and query mapped unaligned regions, matching or not matching repeats")

ggPlotW2W(tra.w2s) +
  facet_wrap(~dist + query.rep + target.rep, nrow = 3) +
  ggtitle("Width of the target and query translocated regions, matching or not matching repeats")

ggplot(unalMap.w2s) +
  aes(target / query, col = paste(target.rep, query.rep) ) +
  scale_x_log10() +
  geom_freqpoly() +
  ggtitle("In presence of a repeat, target width tends to be longer than query") +
  geom_vline(xintercept = 1)
```

# Structural variants

## Width of inverted regions

We know that we can detect more inversions after coalescing and removing
translocations (`vignette("Inversions", package = "OikScrambling")`).

Many inversions are shorter than 1 kbp.  Size may differ slightly between long
and short arms.

```{r width_of_inversions}
invs.gbs  <- sapply(gbs,  function(gb) filterInversions(flagInversions(gb))) |> SimpleList()
invs.coa  <- sapply(coa,  function(gb) filterInversions(flagInversions(gb))) |> SimpleList()
invs.coa2 <- sapply(coa2, function(gb) filterInversions(flagInversions(gb))) |> SimpleList()

sapply(invs.gbs,  length)
sapply(invs.coa,  length)
sapply(invs.coa2, length)

# Sanity check that we detect inversions on both strands
sapply(invs.coa2, \(x) {summary(decode(strand(x)))})

widths$invs.gbs  <- makeWidthsDF(invs.gbs)  |> tibble::as_tibble()
widths$invs.coa  <- makeWidthsDF(invs.coa)  |> tibble::as_tibble()
widths$invs.coa2 <- makeWidthsDF(invs.coa2) |> tibble::as_tibble()

gg_freq_poly(widths$invs.gbs) +
  aes(col=Arm) +
  ggtitle("Distribution of alignment widths for inverted regions, using aligned regions, split by arm.") +
  geom_vline(xintercept = 1000)

gg_freq_poly(widths$invs.coa) +
  aes(col=Arm) +
  ggtitle("Distribution of alignment widths for inverted regions, using mapped regions, split by arm.") +
  geom_vline(xintercept = 1000)

gg_freq_poly(widths$invs.coa2) +
  aes(col=Arm) +
  ggtitle("Distribution of alignment widths for inverted regions, using doublemapped regions, split by arm.") +
  geom_vline(xintercept = 1000)

gg_freq_poly(widths$invs.coa2) +
  facet_wrap(~dist, scale="free") + 
  ggtitle("Distribution of alignment widths for inverted regions, using doublemapped regions, split by comparison") +
  geom_vline(xintercept = 1000)
```

## Width of gaps next to the inverted regions

```{r width_of_inversions_gaps}
inv.lgaps <- sapply(coa, leftInversionGaps) |> SimpleList()
inv.lgaps[ 1:5]  <- sapply(inv.lgaps[ 1:5],  flagLongShort, longShort$Oki)
inv.lgaps[ 6:10] <- sapply(inv.lgaps[ 6:10], flagLongShort, longShort$Osa)
inv.lgaps[11:15] <- sapply(inv.lgaps[11:15], flagLongShort, longShort$Bar)
sapply(inv.lgaps, length)

widths$invs.lgaps <- makeWidthsDF(inv.lgaps) |> tibble::as_tibble()

gg_freq_poly(widths$invs.lgaps) +
  aes(col=Arm) +
  facet_wrap(~chr, scales = "free_y") +
  ggtitle("Distribution widths of left gaps next to inverted regions, split by arm.") +
  geom_vline(xintercept = 1000)
```
