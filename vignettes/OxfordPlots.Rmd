---
title: "Whole-genome dot-plots"
author: 
 - "Charles Plessy"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEncoding{UTF-8}
  %\VignetteIndexEntry{Whole-genome dot-plots}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup}
knitr::opts_knit$set(cache = TRUE)
```

# Introduction

This vignette produces alignment line plots of pairs of genomes to illustrate
differences in the extent of scrambling in _Oikopleura_ compared to equivalent
pairs in other genera.

The core functions used here are maintained in our _GenomicBreaks_ R package,
which is fully documented at: <https://oist.github.io/GenomicBreaks>.

See `vignette("ParallelPlots", package = "OikScrambling")` for parallel
comparisons of homologous chromosomes in more than one species.

## Load pacakges

# Load R pacakges and data

```{r load_packages_and_data}
library('OikScrambling') |> suppressPackageStartupMessages()
genomes <- OikScrambling:::loadAllGenomes()
load("BreakPoints.Rdata")
```

# Oikopleura

## Oki vs Bar

```{r Oki_Bar_all}
makeOxfordPlots(coa$Oki_Bar, diag = FALSE)
```

```{r mkOxPlotWindow_function}
# stringDist_GBreaks <- function(x, method = "levenshtein", ignoreCase = FALSE, diag = FALSE, upper = FALSE, ...) {
#   targetS <- getSeq(x)
#   queryS  <- getSeq(x$query)
#   seqs <- Pairs(targetS, queryS)
#   sapply(seqs, \(pair){
#     stringDist(c(first(pair), second(pair)))
#   })
# }

mkOxPlotWindow <- function(gb, win = 5e6, size = 2, centre = c('midpoint', 'maxwidth'), ...) {
  centre <- match.arg(centre)
  gb <- forceSeqLengths(gb)
  longest_target_seq <- seqlengths(gb) |> sort() |> tail(1) |> names()
  best_query_match   <- gb[seqnames(gb) == longest_target_seq]$query |> seqnames() |> table() |> sort() |> tail(1) |> names()
  if (centre == 'midpoint') {
    target_centre <- round(seqlengths(gb)[longest_target_seq]     / 2)
    query_centre  <- round(seqlengths(gb$query)[best_query_match] / 2)
  } else {
    gb_coa <- coalesce_contigs(gb)
    maxwidth <- which.max(width(gb_coa))
    target_centre <- gb_coa[maxwidth]       |> resize(1, fix = "center") |> start()
    query_centre  <- gb_coa$query[maxwidth] |> resize(1, fix = "center") |> start()
  }
  gb <- gb |> plyranges::filter(
    seqnames == longest_target_seq,
    seqnames(query) == best_query_match,
    start > target_centre - win,
    end < target_centre + win,
    start(query) > query_centre - win,
    end(query) < query_centre + win
  )
  # score(gb) <- stringDist_GBreaks(gb) / width(gb)
  makeOxfordPlots(gb, col = "strand", size = size, ...) +
    theme_bw() +
    theme(legend.position="none")
}
```

```{r Oki_Bar_win, dev='svg', fig.ext='svg'}
mkOxPlotWindow(gbs$Oki_Bar)
```

## Oki vs Osa

Dot plot intended for panel A of figure 1.

```{r Oki_Osa, dev=c('png', 'svg', 'pdf'), fig.ext=c('png', 'svg', 'pdf')}
makeOxfordPlots(coa$Oki_Osa, diag = FALSE) + theme_bw() + theme(legend.position="none")
```

The plot below is based on aligned regions (before coalescing).  It is displayed
to demonstrate that it is visually similar to the one above made on mapped
regions (object after coalescing).

```{r Oki_Osa_gbs, dev=c('png', 'svg', 'pdf'), fig.ext=c('png', 'svg', 'pdf')}
makeOxfordPlots(gbs$Oki_Osa, diag = FALSE) +
  scale_color_manual(values = c("#E78AC3", "#A6D854", "#FFD92F", "#8DA0CB", "#66C2A5")) +
  theme_bw() +
  theme(legend.position="none")
```

Oxford plot colored by strand.

```{r Oki_Osa_strand, dev=c('png', 'svg', 'pdf'), fig.ext=c('png', 'svg', 'pdf')}
makeOxfordPlots(coa$Oki_Osa, diag = FALSE, col = "strand") + theme_bw() + theme(legend.position="none")
```

10-Mb square window plot.

```{r Oki_Osa_win, dev=c('png', 'svg', 'pdf'), fig.ext=c('png', 'svg', 'pdf')}
mkOxPlotWindow(gbs$Oki_Osa)
```

## Osa vs Bar

```{r Osa_bar}
makeOxfordPlots(coa$Osa_Bar, diag = FALSE)
```

```{r Osa_Bar_win, dev='svg', fig.ext='svg'}
mkOxPlotWindow(gbs$Osa_Bar)
```

## Osa vs Oki

```{r Osa_Oki}
makeOxfordPlots(coa$Osa_Oki, diag = FALSE)
```

```{r Osa_Oki_win, dev=c('png', 'svg', 'pdf'), fig.ext=c('png', 'svg', 'pdf')}
mkOxPlotWindow(gbs$Osa_Oki)
```

## Osa vs Aom

```{r Osa_Aom}
makeOxfordPlots(coa$Osa_Aom, diag = FALSE)
```

```{r Osa_Aom_win_prepare}
Osa_Aom_PAR <- gbs$Osa_Aom |> plyranges::filter(seqnames == "PAR")
seqlevels(Osa_Aom_PAR)       <- seqlevelsInUse(Osa_Aom_PAR)
seqlevels(Osa_Aom_PAR$query) <- seqlevelsInUse(Osa_Aom_PAR$query)

makeOxfordPlots(Osa_Aom_PAR)

# Let's remove the contigs that have their main match elsewhere.
QTcoverage <- function(gb) {
  stopifnot (length(seqlevels(gb)) == 1) # Not ready for full objects
  stopifnot (!any(is.na(seqlengths(gb$query))))
  grl <- split(gb, seqnames(gb$query))
  lapply(grl, \(gb) sum(width(gb$query))) |> unlist() / seqlengths(gb$query)
}
Osa_Aom_PAR[seqnames(Osa_Aom_PAR$query) %in% seqlevels(Osa_Aom_PAR$query)[QTcoverage(Osa_Aom_PAR) < 0.5]] <- NULL
seqlevels(Osa_Aom_PAR$query) <- seqlevelsInUse(Osa_Aom_PAR$query)
makeOxfordPlots(Osa_Aom_PAR)

# Let's remove the smallest ones that barely display on one pixel
seqlengths(Osa_Aom_PAR$query)
Osa_Aom_PAR[seqnames(Osa_Aom_PAR$query) %in% seqlevels(Osa_Aom_PAR$query)[seqlengths(Osa_Aom_PAR$query) < 2e4]] <- NULL
seqlevels(Osa_Aom_PAR$query) <- seqlevelsInUse(Osa_Aom_PAR$query)
makeOxfordPlots(Osa_Aom_PAR, col = "strand")

# And now let's flip by hand the ones that need
grl <- split(Osa_Aom_PAR, seqnames(Osa_Aom_PAR$query))
grl[["contig_38_1"]] <- reverse(grl[["contig_38_1"]], query = TRUE)
grl[["contig_49_1"]] <- reverse(grl[["contig_49_1"]], query = TRUE)
Osa_Aom_PAR <- unlist(grl)
makeOxfordPlots(Osa_Aom_PAR, col = "strand")

# Finally, let's reorder and merge remaining seqlevels
seqlevels(Osa_Aom_PAR$query) <- seqlevels(Osa_Aom_PAR$query)[orderQuerySeqLevels(Osa_Aom_PAR)]
Osa_Aom_PAR$query <- mergeSeqLevels(Osa_Aom_PAR$query, seqlevels(Osa_Aom_PAR$query), "PAR")
```

```{r Osa_Aom_win, dev=c('png', 'svg', 'pdf'), fig.ext=c('png', 'svg', 'pdf')}
mkOxPlotWindow(Osa_Aom_PAR)
```

### Aom whole genome scaffolding using Oxford plots
Let's try to scaffold Aomori a little bit more. Hopefully, we can recover most of a chromosome-scale genome assembly using the Oxford plots alone.

```{r Osa_Aom_sc_helpers}
# Helper function to flip many contigs at once.
flipContigsForOxfordPlot <- function(gb, flip_which=NULL) {
  grl <- split(gb, seqnames(gb$query))
  grl <- endoapply(grl, function(s) {
    if( ! identical(unique(as.character(seqnames(s$query))), character(0)) ) {
      if(unique(seqnames(s$query)) %in% flip_which ) {
        s <- GenomicBreaks::reverse(s, query=TRUE)
        s
      }
    }
    s
  })
  ogb <- unlist(grl) |> unname()
  ogb
}

# This is what the function does, for visual confirmation.
gbs$Oki_Osa |> makeOxfordPlots()
flipContigsForOxfordPlot(gbs$Oki_Osa, flip_which=c('Chr1', 'Chr2')) |> makeOxfordPlots()
```

#### Chr1

```{r Osa_Aom_sc_chr1, dev=c('png', 'svg', 'pdf'), fig.ext=c('png', 'svg', 'pdf')}
# Let's dig in to each chromosome and try to flip Aomori appropriately.
# Chr1
Osa_Aom_Chr1 <- gbs$Osa_Aom |> plyranges::filter(seqnames == "Chr1")
seqlevels(Osa_Aom_Chr1)       <- seqlevelsInUse(Osa_Aom_Chr1)
seqlevels(Osa_Aom_Chr1$query) <- seqlevelsInUse(Osa_Aom_Chr1$query)

makeOxfordPlots(Osa_Aom_Chr1, col='strand')

# Let's remove the contigs that have their main match elsewhere.
Osa_Aom_Chr1[seqnames(Osa_Aom_Chr1$query) %in% seqlevels(Osa_Aom_Chr1$query)[QTcoverage(Osa_Aom_Chr1) < 0.5]] <- NULL
seqlevels(Osa_Aom_Chr1$query) <- seqlevelsInUse(Osa_Aom_Chr1$query)
# Some of the remaining bits are not very helpful either, so let's drop them.
Osa_Aom_Chr1 <- Osa_Aom_Chr1[seqnames(Osa_Aom_Chr1$query)!='contig_31_1']
seqlevels(Osa_Aom_Chr1$query) <- seqlevelsInUse(Osa_Aom_Chr1$query)
makeOxfordPlots(Osa_Aom_Chr1, col='strand')


# Let's flip things around a little to get things as linear as they can be:
makeOxfordPlots( flipContigsForOxfordPlot(Osa_Aom_Chr1, flip_which = c('contig_48_1', 'contig_1_1', 'contig_39_1', 'contig_32_1')), col='strand')

# So Chr1 is, I guess:
# c('contig_46_1', 'contig_2_1',      rev('contig_48_1'), 
#   'contig_5_1',  rev('contig_1_1'), 'contig_3_1',
#   rev('contig_39_1'), rev('contig_32_1'))

```


#### Chr2

```{r Osa_Aom_sc_chr2, dev=c('png', 'svg', 'pdf'), fig.ext=c('png', 'svg', 'pdf')}
Osa_Aom_Chr2 <- gbs$Osa_Aom |> plyranges::filter(seqnames == "Chr2")
seqlevels(Osa_Aom_Chr2)       <- seqlevelsInUse(Osa_Aom_Chr2)
seqlevels(Osa_Aom_Chr2$query) <- seqlevelsInUse(Osa_Aom_Chr2$query)

makeOxfordPlots(Osa_Aom_Chr2, col='strand')

# Let's remove the contigs that have their main match elsewhere.
Osa_Aom_Chr2[seqnames(Osa_Aom_Chr2$query) %in% seqlevels(Osa_Aom_Chr2$query)[QTcoverage(Osa_Aom_Chr2) < 0.5]] <- NULL
seqlevels(Osa_Aom_Chr2$query) <- seqlevelsInUse(Osa_Aom_Chr2$query)
makeOxfordPlots(Osa_Aom_Chr2, col='strand')

# Let's flip things around a little to get things as linear as they can be:
makeOxfordPlots( flipContigsForOxfordPlot(Osa_Aom_Chr2, flip_which = c('contig_44_1', 'contig_42_1', 'contig_23_1', 'contig_45_1')), col='strand')

# Chr2 is:
# c(rev('contig_44_1'), rev('contig_42_1'), rev('contig_23_1'), 'contig_22_1', rev('contig_45_1'))

```

#### PAR
This has been done above, but just to make it consistent with the approach for Chr1/Chr2, let's repeat it here:
```{r Osa_Aom_sc_PAR, dev=c('png', 'svg', 'pdf'), fig.ext=c('png', 'svg', 'pdf')}
Osa_Aom_PAR <- gbs$Osa_Aom |> plyranges::filter(seqnames == "PAR")
seqlevels(Osa_Aom_PAR)       <- seqlevelsInUse(Osa_Aom_PAR)
seqlevels(Osa_Aom_PAR$query) <- seqlevelsInUse(Osa_Aom_PAR$query)

makeOxfordPlots(Osa_Aom_PAR, col='strand')

# Let's remove the contigs that have their main match elsewhere.
Osa_Aom_PAR[seqnames(Osa_Aom_PAR$query) %in% seqlevels(Osa_Aom_PAR$query)[QTcoverage(Osa_Aom_PAR) < 0.5]] <- NULL
seqlevels(Osa_Aom_PAR$query) <- seqlevelsInUse(Osa_Aom_PAR$query)
makeOxfordPlots(Osa_Aom_PAR, col='strand')

# Let's flip things around a little to get things as linear as they can be:
makeOxfordPlots( flipContigsForOxfordPlot(Osa_Aom_PAR, flip_which = c('contig_49_1', 'contig_38_1')), col='strand')

# PAR is:
# c('contig_12_1', rev('contig_38_1'), rev('contig_49_1'), 'contig_15_1', 'contig_34_1'))

```

#### XSR

```{r Osa_Aom_sc_xsr, dev=c('png', 'svg', 'pdf'), fig.ext=c('png', 'svg', 'pdf')}
Osa_Aom_XSR <- gbs$Osa_Aom |> plyranges::filter(seqnames == "XSR")
seqlevels(Osa_Aom_XSR)       <- seqlevelsInUse(Osa_Aom_XSR)
seqlevels(Osa_Aom_XSR$query) <- seqlevelsInUse(Osa_Aom_XSR$query)

makeOxfordPlots(Osa_Aom_XSR, col='strand')

# Let's remove the contigs that have their main match elsewhere.
Osa_Aom_XSR[seqnames(Osa_Aom_XSR$query) %in% seqlevels(Osa_Aom_XSR$query)[QTcoverage(Osa_Aom_XSR) < 0.5]] <- NULL
seqlevels(Osa_Aom_XSR$query) <- seqlevelsInUse(Osa_Aom_XSR$query)
makeOxfordPlots(Osa_Aom_XSR, col='strand')

# Let's flip things around a little to get things as linear as they can be:
makeOxfordPlots( flipContigsForOxfordPlot(Osa_Aom_XSR, flip_which = c('contig_4_1')), col='strand')

# XSR is:
# c(rev('contig_4_1'))
```


#### YSR

```{r Osa_Aom_sc_ysr, dev=c('png', 'svg', 'pdf'), fig.ext=c('png', 'svg', 'pdf')}
Osa_Aom_YSR <- gbs$Osa_Aom |> plyranges::filter(seqnames == "YSR")
seqlevels(Osa_Aom_YSR)       <- seqlevelsInUse(Osa_Aom_YSR)
seqlevels(Osa_Aom_YSR$query) <- seqlevelsInUse(Osa_Aom_YSR$query)

makeOxfordPlots(Osa_Aom_YSR, col='strand')

# Let's remove the contigs that have their main match elsewhere.
Osa_Aom_YSR[seqnames(Osa_Aom_YSR$query) %in% seqlevels(Osa_Aom_YSR$query)[QTcoverage(Osa_Aom_YSR) < 0.30]] <- NULL
seqlevels(Osa_Aom_YSR$query) <- seqlevelsInUse(Osa_Aom_YSR$query)
makeOxfordPlots(Osa_Aom_YSR, col='strand')

# Let's flip things around a little to get things as linear as they can be:
makeOxfordPlots( flipContigsForOxfordPlot(Osa_Aom_YSR, flip_which = c('contig_27_1', 'contig_20_1')), col='strand')

# YSR is:
# c(rev('contig_27_1'), rev('contig_20_1'))

```

#### Bringing it together

```{r Osa_Aom_sc_all_1, dev=c('png', 'svg', 'pdf'), fig.ext=c('png', 'svg', 'pdf')}
# scaffolding function to return a chromosome-scale GRange based on a list of contigs and a set of orientations
#  inputs: a Gbreaks object, and a named list of chromosomes containing contigs to scaffold
#    The "chr" object should look like this:
#    list(Chr1=data.frame(contig=c('contig_1_1', 'contig_2_2'), orientation=c(1, -1)) )
scaffold_gbreaks_query <- function(gb, chr=NULL) {
  if(is.null(chr)){
    print("Error, no scaffolding information provided. Check inputs.")
  } else {
    # Some checks and balances.
    stopifnot(!all(names(chr) %in% seqnames(gb$query)))
    chr_df <- chr |> dplyr::bind_rows(.id='chromosome')
    which.flip <- chr_df$contig[chr_df$orientation=='-1']
    o_gb <- flipContigsForOxfordPlot(gb, which.flip)
    o_gb$query$scaffold <- NA
    o_gb$query$scaffold <- chr_df$chromosome[match(as.character(seqnames(o_gb$query)), chr_df$contig)]
    
    # Reorder the seqlevels to match the scaffolding.
    sql_orig <- as.character(seqlevels(gb$query))
    sql_new <- chr_df$contig
    sql_new <- c(sql_new, sql_orig[! sql_orig %in% sql_new])
    seqlevels(o_gb$query) <- sql_new

    o_gb
  }
}
# Chr1
# c('contig_46_1', 'contig_2_1',      rev('contig_48_1'), 'contig_5_1',  rev('contig_1_1'), 'contig_3_1', rev('contig_39_1'), rev('contig_32_1'))
# Chr2
# c(rev('contig_44_1'), rev('contig_42_1'), rev('contig_23_1'), 'contig_22_1', rev('contig_45_1'))
# PAR
# c('contig_12_1', rev('contig_38_1'), rev('contig_49_1'), 'contig_15_1', 'contig_34_1'))
# XSR
# c(rev('contig_4_1'))
# YSR is:
# c(rev('contig_27_1'), rev('contig_20_1'))

aom_scaffolds <- list(
  'Chr1'=data.frame(
    contig=c('contig_46_1', 'contig_2_1', 'contig_48_1',
             'contig_5_1',  'contig_1_1', 'contig_3_1',
             'contig_39_1', 'contig_32_1'),
    orientation=c(1, 1, -1,
                  1, -1, 1,
                  1, -1)),
  'Chr2'=data.frame(
    contig=c('contig_44_1', 'contig_42_1', 'contig_23_1',
             'contig_22_1', 'contig_45_1'),
    orientation=c(-1, -1, -1,
                  1, -1)),
  'PAR'=data.frame(
    contig=c('contig_12_1', 'contig_38_1', 'contig_49_1',
             'contig_15_1', 'contig_34_1'),
    orientation=c(1, -1, -1,
                  1, 1)),
  'XSR'=data.frame(
    contig='contig_4_1',
    orientation=-1),
  'YSR'=data.frame(
    contig=c('contig_27_1', 'contig_20_1'),
    orientation=c(-1, -1))
)

# Original plot for comparison
gbs$Osa_Aom |> makeOxfordPlots()
# Flipped about plot
scaffold_gbreaks_query(gbs$Osa_Aom, chr=aom_scaffolds) |> makeOxfordPlots()
# Flipped about plot with small skinny bits removed
scaffold_gbreaks_query(gbs$Osa_Aom, chr=aom_scaffolds) |> swap() |> plyranges::filter(!is.na(scaffold)) |> swap() |> makeOxfordPlots()
```

### Aom scaffolding of orthogroups
By identifying the contigs that need to flip, we can repeat this process for the orthogroup-based `GBreaks` objects (based on 1-to-1 orthologues).

Much of this code comes from the `OrthogroupSyntenies` vignette so please inspect this.

```{r Osa_Aom_sc_og}
annots      <- OikScrambling:::loadAllAnnotations()   |> suppressWarnings()
transcripts <- OikScrambling:::loadAllTranscriptsGR()

orthoGroupFileNames <- SimpleList(
  AOM.5.5f      = "AOM-5-5f.prot.longest.fa_1", 
  Bar2.p4       = "Bar2_p4.Flye.prot.longest.fa_1", 
  Ply           = "C_int_P.prot.longest.fa_1",
  Ros           = "C_int_R.prot.longest.fa_1",
  Int           = "Ciona_intestinalis.Uniprot.rn.fa_1",
  Sav           = "Ciona_savignyi.Uniprot.rn.fa_1",
  KUM.M3.7f     = "KUM-M3-7f.prot.longest.fa_1",
  OKI2018.I69   = "OKI2018_I69.v2.prot.longest.fa_1",
  OSKA2016v1.9  = "OSKA2016v1.9.prot.longest.fa_1",
  OdB3          = "OdB3.v1.0.prot.fa_1.nohaplo"
)
orthoPairToGBreaks <- function(genome1, genome2, transcripts, treeName="N19", HOGs=NULL) {
  if(is.null(HOGs))
    HOGs <- OikScrambling:::load_one_to_ones(
      system.file(paste0("extdata/OrthoFinder/",treeName,".tsv"), package = "BreakpointsData"),
      c(orthoGroupFileNames[[genome1]], orthoGroupFileNames[[genome2]]))
  IDs2GRanges <- function (IDs, annot) {
    prefix <- Biobase::lcPrefix(IDs)                  # Guess prefix in transcript IDs from HOG files
    not_prefix <- Biobase::lcPrefix(annot$tx_name)    # Remove trailing characters that are part of the name
    not_prefix <- paste0(not_prefix,"$")              # Anchor to end of the string
    prefix <- sub(not_prefix, "", prefix)             # Finalise prefix
    IDs <- sub(prefix, "", IDs)                       # Remove prefix from IDS
    names(annot) <- annot$tx_name                     # Store transcript name in names slot
    gr <- annot[IDs]                                  # Sort by ID
    strand(gr) <- "*"                                 # Make strandless
    gr                                                # Return the object
  }
  
  gb       <- IDs2GRanges(HOGs[,orthoGroupFileNames[[genome1]]], transcripts[[genome1]])
  if (!is.null(genomes[[genome1]]))
    seqinfo(gb) <- seqinfo(genomes[[genome1]])
  gb$query <- IDs2GRanges(HOGs[,orthoGroupFileNames[[genome2]]], transcripts[[genome2]])
  if (!is.null(genomes[[genome2]]))
   seqinfo(gb$query) <- seqinfo(genomes[[genome2]])
  gb <- GenomicBreaks:::GBreaks(gb)
  gb$HOG <- HOGs$HOG
  gb$OG  <- HOGs$OG
  sort(gb)
}
flagLongShort_ <- function(gr, transcripts) {
  genome <- unique(genome(gr))
  flagLongShort(gr, transcripts[[genome]])
}
orthoPairToGBreaks_all_Oiks <- function(treeName=NULL, HOGs=NULL) {
  orthoPairs <- SimpleList()
  orthoPairs$Oki_Osa <- orthoPairToGBreaks("OKI2018.I69", "OSKA2016v1.9",   transcripts, treeName, HOGs)
  orthoPairs$Oki_Bar <- orthoPairToGBreaks("OKI2018.I69", "Bar2.p4",        transcripts, treeName, HOGs)
  orthoPairs$Oki_Kum <- orthoPairToGBreaks("OKI2018.I69", "KUM.M3.7f",      transcripts, treeName, HOGs)
  orthoPairs$Oki_Aom <- orthoPairToGBreaks("OKI2018.I69", "AOM.5.5f",       transcripts, treeName, HOGs)
  orthoPairs$Oki_Nor <- orthoPairToGBreaks("OKI2018.I69", "OdB3",           transcripts, treeName, HOGs)
  
  orthoPairs$Osa_Bar <- orthoPairToGBreaks("OSKA2016v1.9",   "Bar2.p4",     transcripts, treeName, HOGs)
  orthoPairs$Osa_Oki <- orthoPairToGBreaks("OSKA2016v1.9",   "OKI2018.I69", transcripts, treeName, HOGs)
  orthoPairs$Osa_Kum <- orthoPairToGBreaks("OSKA2016v1.9",   "KUM.M3.7f",   transcripts, treeName, HOGs)
  orthoPairs$Osa_Aom <- orthoPairToGBreaks("OSKA2016v1.9",   "AOM.5.5f",    transcripts, treeName, HOGs)
  orthoPairs$Osa_Nor <- orthoPairToGBreaks("OSKA2016v1.9",   "OdB3",        transcripts, treeName, HOGs)
  
  orthoPairs$Bar_Osa <- orthoPairToGBreaks("Bar2.p4",   "OSKA2016v1.9",     transcripts, treeName, HOGs)
  orthoPairs$Bar_Oki <- orthoPairToGBreaks("Bar2.p4",   "OKI2018.I69",      transcripts, treeName, HOGs)
  orthoPairs$Bar_Kum <- orthoPairToGBreaks("Bar2.p4",   "KUM.M3.7f",        transcripts, treeName, HOGs)
  orthoPairs$Bar_Aom <- orthoPairToGBreaks("Bar2.p4",   "AOM.5.5f",         transcripts, treeName, HOGs)
  orthoPairs$Bar_Nor <- orthoPairToGBreaks("Bar2.p4",   "OdB3",             transcripts, treeName, HOGs)
  
  orthoPairs <- sapply(orthoPairs,  flagLongShort_, longShort)
  
  SimpleList(orthoPairs)
}
orthoPairs         <- orthoPairToGBreaks_all_Oiks("N19")
orthoPairs$Ply_Ros <- orthoPairToGBreaks("Ply", "Ros", transcripts, treeName="N20")
```

```{r Osa_Aom_sc_all_2}
orthoPairs$Osa_Aom |> makeOxfordPlots()
scaffold_gbreaks_query(orthoPairs$Osa_Aom, chr=aom_scaffolds) |> makeOxfordPlots()
scaffold_gbreaks_query(orthoPairs$Osa_Aom, chr=aom_scaffolds) |> swap() |> plyranges::filter(!is.na(scaffold)) |> swap() |> makeOxfordPlots()
# Still a bit ugly. Let's remove small Osaka contigs.
scaffold_gbreaks_query(orthoPairs$Osa_Aom, chr=aom_scaffolds) |> plyranges::filter(seqnames %in% c('Chr1', 'Chr2', 'PAR', 'XSR', 'YSR')) |> swap() |> plyranges::filter(!is.na(scaffold)) |> swap() |> makeOxfordPlots()
```


## Oki vs Kum

```{r Oki_Kum}
makeOxfordPlots(coa$Oki_Kum)
```

```{r Oki_Kum_win_prepare}
Oki_Kum_PAR <- gbs$Oki_Kum |> plyranges::filter(seqnames == "PAR")
seqlevels(Oki_Kum_PAR)       <- seqlevelsInUse(Oki_Kum_PAR)
seqlevels(Oki_Kum_PAR$query) <- seqlevelsInUse(Oki_Kum_PAR$query)

makeOxfordPlots(Oki_Kum_PAR)

# Let's remove the contigs that have their main match elsewhere.
QTcoverage <- function(gb) {
  stopifnot (length(seqlevels(gb)) == 1) # Not ready for full objects
  stopifnot (!any(is.na(seqlengths(gb$query))))
  grl <- split(gb, seqnames(gb$query))
  lapply(grl, \(gb) sum(width(gb$query))) |> unlist() / seqlengths(gb$query)
}
Oki_Kum_PAR[seqnames(Oki_Kum_PAR$query) %in% seqlevels(Oki_Kum_PAR$query)[QTcoverage(Oki_Kum_PAR) < 0.5]] <- NULL
seqlevels(Oki_Kum_PAR$query) <- seqlevelsInUse(Oki_Kum_PAR$query)
makeOxfordPlots(Oki_Kum_PAR)

# Let's remove the smallest ones that barely display on one pixel
seqlengths(Oki_Kum_PAR$query)
Oki_Kum_PAR[seqnames(Oki_Kum_PAR$query) %in% seqlevels(Oki_Kum_PAR$query)[seqlengths(Oki_Kum_PAR$query) < 2e4]] <- NULL
seqlevels(Oki_Kum_PAR$query) <- seqlevelsInUse(Oki_Kum_PAR$query)
makeOxfordPlots(Oki_Kum_PAR)

# And now let's flip by hand the ones that need
grl <- split(Oki_Kum_PAR, seqnames(Oki_Kum_PAR$query))
grl[["contig_12_1"]] <- reverse(grl[["contig_12_1"]], query = TRUE)
grl[["contig_43_1"]] <- reverse(grl[["contig_43_1"]], query = TRUE)
Oki_Kum_PAR <- unlist(grl)
makeOxfordPlots(Oki_Kum_PAR)

# Finally, let's reorder and merge remaining seqlevels
seqlevels(Oki_Kum_PAR$query) <- seqlevels(Oki_Kum_PAR$query)[orderQuerySeqLevels(Oki_Kum_PAR)]
Oki_Kum_PAR$query <- mergeSeqLevels(Oki_Kum_PAR$query, seqlevels(Oki_Kum_PAR$query), "PAR")
```

```{r Oki_Kum_win, dev='svg', fig.ext='svg'}
mkOxPlotWindow(Oki_Kum_PAR)
```

# Ciona

## _Ciona intestinalis_ (Plymouth vs Roscoff)

```{r Ply_Ros}
makeOxfordPlots(coa$Ply_Ros) + ggtitle("Ciona intestinalis Plymouth vs Roscoff")
```

```{r Ply_Ros_win, dev='svg', fig.ext='svg'}
mkOxPlotWindow(gbs$Ply_Ros) + ggtitle("Ciona intestinalis Plymouth vs Roscoff")
```

## _Ciona intestinalis_ (Plymouth) vs _Ciona robusta_

```{r Ply_Rob}
makeOxfordPlots(coa$Ply_Rob) + ggtitle("Ciona intestinalis Plymouth vs Ciona robusta")
```

```{r Ply_Rob_win, dev='svg', fig.ext='svg'}
mkOxPlotWindow(gbs$Ply_Rob) + ggtitle("Ciona intestinalis Plymouth vs Ciona robusta")
```

## Troubleshoot of grid pattern

We see horizontal patterns what are they?  I think they may be pericentromeric
regions.


```{r Ply_Rob_point_plot}
makeOxfordPlots(coa$Ply_Rob) + ggtitle("Ciona intestinalis Plymouth vs Ciona robusta")
```

```{r Ply_Rob_subset}
coa$Ply_Rob |>
  plyranges::filter(seqnames(query) %in% c("BJTB01000010.1", "BJTB01000011.1", "BJTB01000012.1", "BJTB01000013.1", "BJTB01000014.1")) |>
  plyranges::filter(seqnames        %in% c("BNJZ01000005.1", "BNJZ01000006.1", "BNJZ01000007.1", "BNJZ01000008.1", "BNJZ01000009.1")) |>
  makeOxfordPlots() + ggtitle("C. int. P vs C. rob., subset near BJTB01000012.1 and BNJZ01000007.1")
```

```{r Ply_Rob_subset2}
coa$Ply_Rob |>
  plyranges::filter(seqnames(query) %in% c("BJTB01000011.1", "BJTB01000012.1", "BJTB01000013.1")) |>
  plyranges::filter(seqnames        %in% c("BNJZ01000006.1", "BNJZ01000007.1", "BNJZ01000008.1")) |>
  makeOxfordPlots() + ggtitle("C. int. P vs C. rob., subset near (closer) BJTB01000012.1 and BNJZ01000007.1")
```

```{r Ply_Rob_subset3}
coa$Ply_Rob |>
  plyranges::filter(seqnames(query) %in% c("BJTB01000002.1", "BJTB01000003.1", "BJTB01000004.1", "BJTB01000005.1", "BJTB01000006.1")) |>
  plyranges::filter(seqnames        %in% c("BNJZ01000010.1", "BNJZ01000011.1", "BNJZ01000012.1", "BNJZ01000013.1", "BNJZ01000014.1")) |>
  makeOxfordPlots() + ggtitle("C. int. P vs C. rob., subset near BJTB01000004.1 and BNJZ01000012.1")
```

```{r Ply_Rob_subset4}
coa$Ply_Rob |>
  plyranges::filter(seqnames(query) %in% c("BJTB01000003.1", "BJTB01000004.1", "BJTB01000005.1")) |>
  plyranges::filter(seqnames        %in% c("BNJZ01000011.1", "BNJZ01000012.1", "BNJZ01000013.1")) |>
  makeOxfordPlots() + ggtitle("C. int. P vs C. rob., subset near (closer) BJTB01000004.1 and BNJZ01000012.1")
```

## _Ciona intestinalis_ (Plymouth) vs _Ciona savignyi_

```{r Ply_Sav}
makeOxfordPlots(coa$Ply_Sav) + ggtitle("Ciona intestinalis Plymouth vs Ciona savignyi")
```

```{r Ply_Sav_win_prepare}
Ply_Sav_chr1 <- gbs$Ply_Sav |> plyranges::filter(seqnames == "BNJZ01000001.1")
seqlevels(Ply_Sav_chr1)       <- seqlevelsInUse(Ply_Sav_chr1)
seqlevels(Ply_Sav_chr1$query) <- seqlevelsInUse(Ply_Sav_chr1$query)
Ply_Sav_chr1$query <- forceSeqLengths(Ply_Sav_chr1$query)

makeOxfordPlots(Ply_Sav_chr1)

# Let's remove the contigs that have their main match elsewhere.
QTcoverage <- function(gb) {
  stopifnot (length(seqlevels(gb)) == 1) # Not ready for full objects
  stopifnot (!any(is.na(seqlengths(gb$query))))
  grl <- split(gb, seqnames(gb$query))
  lapply(grl, \(gb) sum(width(gb$query))) |> unlist() / seqlengths(gb$query)
}
Ply_Sav_chr1[seqnames(Ply_Sav_chr1$query) %in% seqlevels(Ply_Sav_chr1$query)[QTcoverage(Ply_Sav_chr1) < 0.05]] <- NULL
seqlevels(Ply_Sav_chr1$query) <- seqlevelsInUse(Ply_Sav_chr1$query)
makeOxfordPlots(Ply_Sav_chr1)

# Let's remove the smallest ones that barely display on one pixel
seqlengths(Ply_Sav_chr1$query)
Ply_Sav_chr1[seqnames(Ply_Sav_chr1$query) %in% seqlevels(Ply_Sav_chr1$query)[seqlengths(Ply_Sav_chr1$query) < 2e4]] <- NULL
seqlevels(Ply_Sav_chr1$query) <- seqlevelsInUse(Ply_Sav_chr1$query)
makeOxfordPlots(Ply_Sav_chr1)

# Finally, let's reorder and merge remaining seqlevels
seqlevels(Ply_Sav_chr1$query) <- seqlevels(Ply_Sav_chr1$query)[orderQuerySeqLevels(Ply_Sav_chr1)]
Ply_Sav_chr1$query <- mergeSeqLevels(Ply_Sav_chr1$query, seqlevels(Ply_Sav_chr1$query), "Merged matching contigs")
makeOxfordPlots(Ply_Sav_chr1)
```

```{r Ply_Sav_win, dev='svg', fig.ext='svg'}
mkOxPlotWindow(Ply_Sav_chr1) + ggtitle("Ciona intestinalis Plymouth vs Ciona savignyi")
```

# Drosophila

## vs Drosophila mauritania

```{r Dmel_Dmau}
makeOxfordPlots(coa$Dme_Dma) + ggtitle("Dmel vs Dmau")
```

```{r Dmel_Dmau_win, dev='svg', fig.ext='svg'}
# Force strand flipping for aesthetic purpose
mkOxPlotWindow(gbs$Dme_Dma |> forceSeqLengths() |> reverse()) + ggtitle("Drosophila melanogaster vs Drosophila mauritania")
```

## vs Drosophila yakuba

```{r Dmel_Dyak}
makeOxfordPlots(coa$Dme_Dya) + ggtitle("Dmel vs Dyak")
```

```{r Dmel_Dyak_win, dev='svg', fig.ext='svg'}
mkOxPlotWindow(gbs$Dme_Dya) + ggtitle("Drosophila melanogaster vs Drosophila yakuba")
```

## vs Drosophila subpulchrella

```{r Dmel_Dsub}
makeOxfordPlots(coa$Dme_Dsu) + ggtitle("Dmel vs Dsub")
```

```{r Dmel_Dsub_win, dev='svg', fig.ext='svg'}
# Blacklist 3R as the algorithm does not find an nicely square window on it.
mkOxPlotWindow(gbs$Dme_Dsu |> plyranges::filter(seqnames != "3R")) + ggtitle("Drosophila melanogaster vs Drosophila subpulchrella")
```

## vs Drosophila buskii

```{r Dmel_Dbus}
makeOxfordPlots(coa$Dme_Dbu) + ggtitle("Dmel vs Dbus")
```


```{r Dmel_Dbus_win, dev='svg', fig.ext='svg'}
mkOxPlotWindow(gbs$Dme_Dbu) + ggtitle("Drosophila melanogaster vs Drosophila buskii")
```

# Mammals

## Human versus mouse

Chromosome 18 was chosen because it is small and it has the same name in both
species.  Region was centered on the alignment with the longest width, as
otherwise the window out of target.

Still, most of the region is not aligned.  The syntenic regions only look
contiguous because the dots need to be thick to be easy to see.

```{r hg38_mm10, dev='svg', fig.ext='svg'}
hgmm <- load_genomic_breaks(system.file(("extdata/hg38_mm10/hg38_chr18__mm10_chr18.gff3"), package = "BreakpointsData"))
mkOxPlotWindow(hgmm, centre = 'maxwidth') + ggtitle("Homo sapiens vs Mus musculus")
```
