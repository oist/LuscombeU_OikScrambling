---
title: "Translocations"
author: 
 - "Charles Plessy"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEncoding{UTF-8}
  %\VignetteIndexEntry{Translocations}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup}
knitr::opts_chunk$set(cache = TRUE, cache.lazy = FALSE)
knitr::opts_knit$set(verbose = TRUE)
```

# Introduction

After coalescing colinear alignments, removing translocations of
repeat-containing sequences and re-coalescing, colinearity is still broken
hundreds of time.

Here we explore the role of translocations in scrambling _Oikopleura_ genomes.

# Load R pacakges and data

```{r load_packages_and_data}
library('OikScrambling') |> suppressPackageStartupMessages()
load("BreakPoints.Rdata")
```

See `vignette("LoadGenomicBreaks", package = "OikScrambling")` for how the
different GBreaks objects are prepared.

# Documentation

Details can be found in `vignette("GenomicBreaks", package = "GenomicBreaks")`,
in `vignette("StructuralVariants", package = "GenomicBreaks")`,
and `?GenomicBreaks::flagTranslocations`

# A couple of examples

The block in blue sky color map on the same sequence as their neighbors, but
not colinearly.  The span of unaligned regions between them varies greatly.

```{r show_some_translocations}
showTranslocations(coa$Oki_Kum |> flagTranslocations()) -> x
plotApairOfChrs(x[1:3] |> swap() |> sort(i=T))
plotApairOfChrs(x[4:6])
plotApairOfChrs(x[7:9])
```

# Number of translocations

Notes:

 - Translocations in a genomic context ressembling insertion/deletion are removed
   in the `coa2` objects.
   
 - At the moment, the `flagTranslocations` function only searches the _target_
   genome.

```{r count_translocations}
trans_summary <- data.frame(
  align  = sapply(gbs,  function(gb) sum(flagTranslocations(gb)$tra)),
  mapped = sapply(coa,  function(gb) sum(flagTranslocations(gb)$tra)),
  tra_rm = sapply(coa2, function(gb) sum(flagTranslocations(gb)$tra))
)

trans_summary$pairname  <- OikScrambling:::compDistance(rownames(trans_summary))
trans_summary$class     <- OikScrambling:::compDistClass(rownames(trans_summary))
trans_summary$genus     <- OikScrambling:::compGenus(rownames(trans_summary))
trans_summary$target    <- sub("_.*", "", rownames(trans_summary))

ggplot(trans_summary |> tidyr::pivot_longer(c("align", "mapped", "tra_rm"))) +
  aes(value, name) + geom_point(aes(col = class, pch = target)) +
  ggtitle ("Number of translocations found after different post-processings",
           subtitle = "align: raw, mapped: collapsed, tra_rm: translocated repeats removed.") +
  facet_wrap(~genus)
```

<details>
<summary>Click here to see the raw data</summary>
```{r show_count_translocations}
trans_summary
```
</details>

The number of detected translocations increase after coalescing, because the
translocated region itself may have a double gap interrupting the alignment.
Then, it logically decreases when the repeat-associated translocations are
removed.

# Small translocations

Translocations are "small" when the flanking colinear regions are longer.

Small translocations are a majority.  Only in same-population comparison they
seem to associate strongly with repeats.

```{r translocation classes}
flagSmallTranslocations <- function (a) {
  a <- flagTranslocations(a)
  a$w0  <- width(a)
  a$w1 <- c(tail(a$w0, -1), NA)
  a$w2 <- c(tail(a$w0, -2), NA, NA)
  a$midSmaller <- (a$w0 + a$w2 > 2 * a$w1) & a$tra
  a
}

smallTransObjs <- SimpleList(
  align_s  = sapply(gbs, flagSmallTranslocations),
  mapped_s = sapply(coa, flagSmallTranslocations),
  tra_rm_s = sapply(coa2, flagSmallTranslocations)
)

cbind( trans_summary
     , smallTransObjs |> sapply(sapply, \(gb) sum(gb$midSmaller)))
```
