---
title: "Translocations"
author: 
 - "Charles Plessy"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEncoding{UTF-8}
  %\VignetteIndexEntry{Translocations}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup}
knitr::opts_chunk$set(cache = TRUE, cache.lazy = FALSE)
knitr::opts_knit$set(verbose = TRUE)
```

# Introduction

After coalescing colinear alignments, removing translocations of
repeat-containing sequences and re-coalescing, colinearity is still broken
hundreds of time.

Here we explore the role of translocations in scrambling _Oikopleura_ genomes.

# Load R pacakges and data

```{r load_packages_and_data}
library('OikScrambling') |> suppressPackageStartupMessages()
load("BreakPoints.Rdata")
```

See `vignette("LoadGenomicBreaks", package = "OikScrambling")` for how the
different GBreaks objects are prepared.

# Documentation

Details can be found in `vignette("GenomicBreaks", package = "GenomicBreaks")`,
in `vignette("StructuralVariants", package = "GenomicBreaks")`,
and `?GenomicBreaks::flagTranslocations`

# A couple of examples

The block in blue sky color map on the same sequence as their neighbors, but
not colinearly.  The span of unaligned regions between them varies greatly.

```{r show_some_translocations}
showTranslocations(coa$Oki_Kum |> flagTranslocations()) -> x
plotApairOfChrs(x[1:3] |> swap() |> sort(i=T))
plotApairOfChrs(x[4:6])
plotApairOfChrs(x[7:9])
```

# Number of translocations

Notes:

 - Translocations in a genomic context ressembling insertion/deletion are removed
   in the `coa2` objects.
   
 - At the moment, the `flagTranslocations` function only searches the _target_
   genome.

```{r count_translocations}
trans_summary <- data.frame(
  align  = sapply(gbs,  function(gb) sum(flagTranslocations(gb)$tra)),
  mapped = sapply(coa,  function(gb) sum(flagTranslocations(gb)$tra)),
  tra_rm = sapply(coa2, function(gb) sum(flagTranslocations(gb)$tra))
)

trans_summary$pairname  <- OikScrambling:::compDistance(rownames(trans_summary))
trans_summary$class     <- OikScrambling:::compDistClass(rownames(trans_summary))
trans_summary$genus     <- OikScrambling:::compGenus(rownames(trans_summary))
trans_summary$target    <- sub("_.*", "", rownames(trans_summary))

ggplot(trans_summary |> tidyr::pivot_longer(c("align", "mapped", "tra_rm"))) +
  aes(value, name) + geom_point(aes(col = class, pch = target)) +
  ggtitle ("Number of translocations found after different post-processings",
           subtitle = "align: raw, mapped: collapsed, tra_rm: translocated repeats removed.") +
  facet_wrap(~genus)
```

<details>
<summary>Click here to see the raw data</summary>
```{r show_count_translocations}
trans_summary
```
</details>

The number of detected translocations increase after coalescing, because the
translocated region itself may have a double gap interrupting the alignment.
Then, it logically decreases when the repeat-associated translocations are
removed.

# Small translocations

Translocations are "small" when the flanking colinear regions are longer.

Small translocations are a majority.  Only in same-population comparison they
seem to associate strongly with repeats.

```{r translocation classes}
flagSmallTranslocations <- function (a) {
  a <- flagTranslocations(a)
  a$w0  <- width(a)
  a$w1 <- c(tail(a$w0, -1), NA)
  a$w2 <- c(tail(a$w0, -2), NA, NA)
  a$midSmaller <- (a$w0 + a$w2 > 2 * a$w1) & a$tra
  a
}

smallTransObjs <- SimpleList(
  align_s  = sapply(gbs, flagSmallTranslocations),
  mapped_s = sapply(coa, flagSmallTranslocations),
  tra_rm_s = sapply(coa2, flagSmallTranslocations)
)

cbind( trans_summary
     , smallTransObjs |> sapply(sapply, \(gb) sum(gb$midSmaller)))
```

# Inter-arm translocations

```{r interArmTranslocations}
coa$Oki_Osa |> flagTranslocations(both = FALSE) |> showTranslocations()

addNormalisedArmNames <- function(gb) {
  # Better would be to flag query arms in the main objects, but I do not want
  # to push a rebuild now...
  genomeQ <- unique(genome(gb$query))
  gb   $   armNames       <- paste(seqnames(gb),       gb$Arm                                     ) |> tolower()
  gb$query$armNames <- paste(seqnames(gb$query), flagLongShort(gb$query, longShort[[genomeQ]])$Arm) |> tolower()
  gb
}

interArmTranslocations <- function(gb) {
  translocations <- gb |> addNormalisedArmNames() |> flagTranslocations(both = FALSE) |> showTranslocations()
  translocations[translocations$armNames != translocations$query$armNames]
}

interChrTranslocations <- function(gb) {
  translocations <- gb |> flagTranslocations(both = FALSE) |> showTranslocations()
  translocations[as.character(tolower(seqnames(translocations))) != as.character(tolower(seqnames(translocations$query)))]
}

interChrTra <- sapply(coa[1:15], interChrTranslocations) |> SimpleList()

# Need to improve subsetByOverlaps_GBreaks to allow ignoring queries when needed
(interChrTra$Oki_Osa)|> as("GRanges") |> subsetByOverlaps(coa$Oki_Bar, type = "within", ignore.strand = TRUE) |> as("GBreaks")
(interChrTra$Oki_Bar)|> as("GRanges") |> subsetByOverlaps(coa$Oki_Osa, type = "within") |> as("GBreaks")

(interChrTra$Oki_Bar)|> as("GRanges") |> subsetByOverlaps(coa$Oki_Nor, type = "within") |> as("GBreaks")

(interChrTra$Osa_Bar)|> as("GRanges") |> subsetByOverlaps(coa$Osa_Oki, type = "within") |> as("GBreaks")

(interChrTra$Oki_Osa)|> as("GRanges") |> subsetByOverlaps(cleanGaps(interChrTra$Oki_Bar), type = "within", ignore.strand = TRUE) |> as("GBreaks")

interChrTra$Oki_Osa |> as("GRanges") |> subsetByOverlaps(cleanGaps(interChrTra$Oki_Bar), type = "within", ignore.strand = TRUE) |> subsetByOverlaps(gbs$Oki_Bar, ignore.strand = T) |> as("GBreaks")

findSpecificTra <- function(pair1, pair2) {
  Tra1 <- interChrTra[[pair1]]
  Tra2 <- interChrTra[[pair2]]
  # First, Tra1 must not overlap with Tra1
  # Strand is ignored because it can vary locally due to inversions.
  Tra1_ov_Tra2 <- findOverlaps(Tra1, Tra2, ignore.strand = TRUE)
  Tra1_not_in_Tra2 <- Tra1[! seq_along(Tra1) %in% unique(queryHits(Tra1_ov_Tra2))]
  # Selected ranges must not overlap with unmapped ranges inpair2
  Tra1_ov_unmap_pair2 <- findOverlaps(Tra1, unmap[[pair2]], ignore.strand = TRUE)
  Tra1[! seq_along(Tra1) %in% queryHits(Tra1_ov_unmap_pair2)]
  
  # Tra1 is not in Tra2 if it is covered by a gap region of Tra2.
  # Strand is ignored because it can vary locally due to inversions.
  # Tra1_not_in_Tra2 <- findOverlaps(cleanGaps(Tra2), Tra1, type = "within", ignore.strand = TRUE)
  # Tra1[unique(subjectHits(Tra1_not_in_Tra2))]
}
# findSpecificTra <- function(pair1, pair2) {
#   Tra1 <- interChrTra[[pair1]]
#   Tra2 <- interChrTra[[pair2]]
#   Tra1_not_in_pair2 <- findOverlaps(coa[[pair2]], Tra1 + 1000, type = "within", ignore.strand = TRUE)
#   Tra1[unique(subjectHits(Tra1_not_in_pair2))]
# }
```
