---
title: "Regions interrupting colinearity"
author: 
 - "Charles Plessy"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEncoding{UTF-8}
  %\VignetteIndexEntry{Regions interrupting colinearity}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup, echo=FALSE}
knitr::opts_knit$set(verbose = TRUE)
```

# Load pacakges and data

See the `vignette("OikScrambling", package = "OikScrambling")` for general
details on package and data load.

See `vignette("LoadGenomicBreaks", package = "OikSyntenies")` for how the
different `GBreaks` objects are prepared.

```{r load_pacakges_and_data}
suppressPackageStartupMessages({
  library('GenomicBreaks')
  library('GenomicFeatures')
  library('ggplot2')
  library("BreakpointsData")
})
genomes <- OikScrambling:::loadAllGenomes()
load("BreakPoints.Rdata")
reps <- OikScrambling:::loadAllRepeats()
```

# The problem:

The plot below shows high colinearity between Oki and Kum, but the
`GenomicBreaks` objects are still scattered in small pieces.  What is
interrupting colinearity?

```{r parallel_chr_plots_Oki_Kum}
plotApairOfChrs(coa$Oki_Kum, "chr1", main = "Oki – Kum")
```

In this vignette, we look at a couple of example regions in details.  These
regions helped me to decide how to process the data in _Load Genomic Breaks_
(`vignette("LoadGenomicBreaks", package = "OikSyntenies")` and to decide
which analysis to prioritise elsewhere.

# Alignments are real (Region of Interest 1)

```{r ROI1}
# The best Kume contig matching ot chr1 is contig_3_1
bestMatch <- function(gb)
  tapply(width(gb$query), seqnames(gb$query), sum) |> sort() |> tail(1) |> names()

coa$Oki_Kum |> plyranges::filter(seqnames == "chr1") |> bestMatch()

# contig_3_1 appears to map roughly in the 8,000,000 – 13,000,000 region
coa$Oki_Kum |> flagAll() |> plyranges::filter(seqnames(query) == "contig_3_1") |>
  plyranges::arrange(start(query))
```

How about the second alignment pair, mapping 226 bases of `contig_3_1` to the
short arm?

```{r re_align_a_clolinearity_breaker}
ROI1 <- coa$Oki_Kum |>
  plyranges::filter(seqnames(query) == "contig_3_1", end(query) <= 21079) |>
  plyranges::arrange(start(query))
ROI1
coa$Oki_Kum |> plotApairOfChrs("chr1", "contig_3_1", xlim = gb2xlim(ROI1[-2]), main = "chr1 vs contig_3_1 at ROI 1")
coa$Oki_Kum |> plotApairOfChrs("chr1", "contig_3_1", xlim = list(c(3838658, 3881203), c(1, 21079)), main = "chr1 matching contig_3_1 in the short arm")
```

Is the alignment convincing ?

```{r pairwise_seq_alignments}
# Good match where reported
pairwiseAlignment(getSeq(genomes$Kum, GRanges("contig_3_1:16561-16812:-")), genomes$Oki$chr1[3870099:3870324], type="local")
pairwiseAlignment(getSeq(genomes$Kum, GRanges("contig_3_1:16561-16812:-") + 50), genomes$Oki$chr1[(3870099 -50):(3870324 + 50)], type="global") |> writePairwiseAlignments()

# No good match between the flanking pairs.
pairwiseAlignment(getSeq(genomes$Kum, GRanges("contig_3_1:16561-16812:+")), genomes$Oki$chr1[8086429:8104950], type="local")
pairwiseAlignment(getSeq(genomes$Kum, GRanges("contig_3_1:16561-16812:-")), genomes$Oki$chr1[8086429:8104950], type="local")
```

Yes, the alignment looks real!

# Colinearity interrupted by inversions and translocations (Region of Interest 2)

Let's look at the area `chr1:8080000-12900000` covered by `contig_3_1`.  Can
we coalesce it once we only keep the paired matches?  The answer is no…

```{r ROI2}
coa$Oki_Kum |> flagAll() |> plyranges::filter(seqnames == "chr1", start > 8080000, end < 12900000)

# Even removing all but the best match on the query is not enough to collapse all
coa$Oki_Kum |>
  plyranges::filter(seqnames == "chr1", start > 8080000, end < 12900000) |>
  plyranges::filter(seqnames(query) == "contig_3_1") |>
  coalesce_contigs() |> flagAll() |> head(10)

coa$Oki_Kum |>
  plyranges::filter(seqnames == "chr1", start > 8080000, end < 12900000) |>
  plyranges::filter(seqnames(query) == "contig_3_1")|>
  plotApairOfChrs()
```

Colinearity appears to be interrupted by many inversions and translocations.

# Well-aligned repeats are kept in the one-to-one graph (Region of interest 3)

```{r ROI3}
gbs$Oki_Kum[1] |> as.data.frame()
pairwiseAlignment(genomes$Kum$contig_10_1[52244:60120], genomes$Oki$chr1[7785:15657], type="global")
subsetByOverlaps(reps$Oki, gbs$Oki_Kum[1])
```

# Unaligned mapped region: ROI4

Let's check examples of unaligned mapped regions in function of presence of repeats.

## FALSE/TRUE

```{r ROI4_1}
unalMap$Oki_Osa -> x
x$Class <- paste(!sapply(x$rep, anyNA), !sapply(x$query$rep, anyNA))
x |> head() |> as.data.frame()
ROI4_1 <- x[1]

# Let's recover the flanking regions
# (it works because the unalMap regions are expanded of 1 base on each side to avoid zero-length ranges)
gbs$Oki_Osa |> subsetByOverlaps(ROI4_1) |> as.data.frame()
gbs$Oki_Osa |> subsetByOverlaps(ROI4_1) |> range()
# We confirm that unalmap regions can not be mapped
pairwiseAlignment(genomes$Oki$chr1[552335:552383], genomes$Osa$Chr1[1730795:1731145], type="global") |> writePairwiseAlignments()
pairwiseAlignment(genomes$Oki$chr1[552335:552383], genomes$Osa$Chr1[1730795:1731145] |> reverseComplement(), type="global") |> writePairwiseAlignments()
# We confirm that flanking regions map well
pairwiseAlignment(genomes$Oki$chr1[551988:552647], genomes$Osa$Chr1[1730510:1731548] |> reverseComplement(), type="global") |> writePairwiseAlignments()
# Only one hit
#vmatchPattern(genomes$Osa$Chr1[1730795:1731145], genomes$Osa, with.indels = TRUE, max.mismatch = 10)
```

## FALSE/FALSE

```{r ROI4_2}
ROI4_2 <- x[5]
# As character for convenience of BLAST searching.
genomes$Oki$chr1[554365:554546]   |> as.character()  # Only one perfect BLAST hit at the NCBI, to the Oki genome.
genomes$Osa$Chr1[1727927:1728109] |> as.character()  # No relevant BLAST hit at the NCBI (evalues >= 1e-4)

vmatchPattern(genomes$Oki$chr1[554365:554546], genomes$Oki)

# unaligned mapped region (+ / -)
pairwiseAlignment(genomes$Oki$chr1[554365:554546], genomes$Osa$Chr1[1727927:1728109]                       , type="global") |> writePairwiseAlignments()
pairwiseAlignment(genomes$Oki$chr1[554365:554546], genomes$Osa$Chr1[1727927:1728109] |> reverseComplement(), type="global") |> writePairwiseAlignments()
# Identity of ~50% but no striking difference between strands

# unaligned mapped region with flanking colinear alignments.
gbs$Oki_Osa |> subsetByOverlaps(ROI4_2)
pairwiseAlignment(genomes$Oki$chr1[554168:554692], genomes$Osa$Chr1[1727781:1728321] |> reverseComplement(), type="global") |> writePairwiseAlignments()
```

## TRUE/TRUE

```{r ROI4_3}
ROI4_3 <- x[12]
ROI4_3 |> data.frame()

# As character for convenience of BLAST searching.
genomes$Oki$chr1[561646:562124]   |> as.character()  # Only one perfect BLAST hit at the NCBI, to the Oki genome.
genomes$Osa$Chr1[1722712:1723220] |> as.character()  # No relevant BLAST hit at the NCBI (evalues >= 1e-4)

# unaligned mapped region (+ / -)
pairwiseAlignment(genomes$Oki$chr1[561646:562124], genomes$Osa$Chr1[1722712:1723220]                       , type="global") |> writePairwiseAlignments()
pairwiseAlignment(genomes$Oki$chr1[561646:562124], genomes$Osa$Chr1[1722712:1723220] |> reverseComplement(), type="global") |> writePairwiseAlignments()

# unaligned mapped region with flanking colinear alignments.
gbs$Oki_Osa |> subsetByOverlaps(ROI4_3)
pairwiseAlignment(genomes$Oki$chr1[561142:563743], genomes$Osa$Chr1[1720807:1723727] |> reverseComplement(), type="global") |> writePairwiseAlignments()
```

# What still interrupts colinearity once repeats are ruled out ? (ROI5)

```{r ROI5}
# We start with a random region
coa$Oki_Kum[200:210] |> flagAll() |> as.data.frame()

# Let's focus on alignments between chr1 and contig_27_1:
ROI5.range <- coa$Oki_Kum[200:210] |> dplyr::filter(seqnames == "chr1", seqnames(query) == "contig_27_1") |> range()
ROI5.range

ROI5 <- subsetByOverlaps(coa$Oki_Kum, ROI5.range) |> sort(ignore.strand=T)

# Let's capture all the pairs that overlap that range:
ROI5 |> sort(ignore.strand=T) |> as.data.frame()
ROI5 |> dplyr::arrange(query) |> as.data.frame()
ROI5 |> plotApairOfChrs(xlim = list(c(1436544, 1481440), c(1409471, 1458038)), dna_seg_scale=TRUE)

# Very short gaps between successive ranges in ROI5
cleanGaps(ROI5) |> as.data.frame()

ROI5 |> flagTranslocations()|> flagInversions() |> dist2next( ignore.strand = TRUE) |> as.data.frame()
ROI5 |> swap() |> sort(ignore.strand = TRUE) |> flagTranslocations()|> dist2next( ignore.strand = TRUE, step =2)  |> as.data.frame()

removeTranslocations <- function(gb) {
  gb <- flagTranslocations(gb)
  if(any(gb$tra))
    gb <- gb[-(which(gb$tra) + 1)]
  gb
}

ROI5 |> removeTranslocations() |> coalesce_contigs()  |> swap() |> sort (i=T) |> removeTranslocations() |> coalesce_contigs() |> swap() |> sort(i=T) |> plotApairOfChrs(dna_seg_scale=TRUE)
```

# What still interrupts colinearity once translocations are removed ? (ROI6)

```{r ROI6}
# We start with a broader random region
ROI6 <- coa$Oki_Kum[200:500]
ROI6 |> plotApairOfChrs()
ROI6 |> removeTranslocations() |> coalesce_contigs() |> swap() |> sort(i=T) |>
        removeTranslocations() |> coalesce_contigs() |> swap() |> sort(i=T) |>
  plotApairOfChrs(dna_seg_scale=TRUE)

# Removes too much
ROI6 |>                        removeTranslocations() |> coalesce_contigs() |>
        swap() |> sort(i=T) |> removeTranslocations() |> coalesce_contigs() |> swap() |> sort(i=T) |>
                               removeTranslocations() |> coalesce_contigs() |>
        swap() |> sort(i=T) |> removeTranslocations() |> coalesce_contigs() |> swap() |> sort(i=T) -> x

plotApairOfChrs(x, dna_seg_scale=TRUE)

# Let's find an example where a piece of contig_27_1 is on the small arm.
x  |> dplyr::filter(seqnames == "chr1", seqnames(query) == "contig_27_1") |> swap() |> sort(i=T) |> flagAll() 
x |> flagAll()  |> dplyr::filter(start > 1650000, end <- 1820000) |> as.data.frame()

```

