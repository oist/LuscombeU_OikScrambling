---
title: "GenomicBreaks Vignette"
author: "Charlotte West"
date: "3/27/2020"
output: rmarkdown::html_vignette
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.align = "center", out.width = '70%')
```

## Introduction

The GenomicBreaks R package contains tools for visualising and analysing characteristics associated with 'breakpoints' between pairwise genome alignments. We will clarify the definition of 'breakpoint' shortly. For now, let us start by loading the libraries of the necessary packages.

```{r loadlib, echo=T, results='hide'}
suppressPackageStartupMessages({
library(GenomicRanges)
library(IRanges)
library(GenomeInfoDb)
library(BSgenome)
library(Biostrings)
library(graphics)
library(heatmaps)
library(stats)
library(magrittr)
library(ggplot2)
})

# These will need to be installed by the user
library("BSgenome.Odioica.local.OKI2018.I69")
library("BSgenome.Odioica.local.OSKA2016")
library("BSgenome.Odioica.local.Odioica.reference.v3.0")

library(GenomicBreaks)

```

### GenomicBreaks object

Let's load data from genome alignments.

```{r GRanges object}
gr_O_Oki <- load_genomic_breaks('inst/extdata/OSKA2016__I69-5.gff3.gz',  bsgenome_ref = OSKA2016,    bsgenome_query = OKI2018_I69)
gr_Oki_O <- load_genomic_breaks('inst/extdata/I69-5__OSKA2016.gff3.gz',  bsgenome_ref = OKI2018_I69, bsgenome_query = OSKA2016)
gr_Oki_N <- load_genomic_breaks('inst/extdata/I69-5__Norway.gff3.gz',    bsgenome_ref = OKI2018_I69, bsgenome_query = OdB3)
gr_O_N   <- load_genomic_breaks('inst/extdata/OSKA2016__Norway.gff3.gz', bsgenome_ref = OSKA2016,    bsgenome_query = OdB3)

gr_O_Oki
gr_O_Oki$query
```

Pairwise genome alignments are loaded in `GRanges` object.  By convention, we
write that query genome (the one that was provided as a FASTA file) is aligned
t the reference genome (the one that was indexed by the aligner). The reference
genome (left) is the main part of the object, and the query genome information
(right) is contained in the metadata of the structure.  Information on contig
or scaffold length is loaded a `BSgenome` objects, from which `seqinfo` data
is extracted and passed to the `GRanges`.  By convention, strand information
of the alignment is held by the reference `GRanges`, and the query `GRanges`
are strandless.  The objects are sorted by `seqname` first.

Although we are not using object-oriented classes for the moment, we will refer
to the `GRanges` objects returned by `load_genomic_breaks` as `GenomicBreaks`
objects.

In the example displayed above, the object contains the pairwise alignment
between genomes of two _Oikopleura dioica_ individuals; one from Osaka assembly
_OSKA2016_ (reference) and one from Okinawa assembly _OKI2018_I69_ (query).

The process of pairwise genome alignment first requires the construction of two sequenced genomes, necessitating many steps; seqencing, basecalling, assembly, etc. In this process, errors inevitably arise - from incorrect base calls to misassemblies. These errors can be exacerbated in the alignment process, and coupled with difficult repeated regions, can cause failure to align homologous regions, or misalignments.

### Breakpoints and alignment stops

Let us define an **alignment stop** to be a position defined in either the reference or query genome, where an alignment begins or ends. Looking at the first line in `gr_O_Oki` above, S1 positions 162 and 550 of the reference would be defined as alignment stops. Correspondingly, we have positions 909374 and 909853 in XSR of the query genome as alignment stops. 

The function `get_bps` takes in a GRanges pairwise alignment, and produces a GRanges object of it's associated alignment stops. 

```{r get bps}
gr_O_Oki
get_bps(gr_O_Oki)
get_bps(gr_O_Oki, direction = "left")
get_bps(gr_O_Oki,                      stranded = TRUE)
get_bps(gr_O_Oki,                      stranded = TRUE, sorted = FALSE)
get_bps(gr_O_Oki, direction = "right", stranded = TRUE)
get_bps(gr_O_Oki$query, sorted = FALSE)
get_bps(gr_O_Oki$query)
```

Now, let us define a **genomic breakpoint** (or simply breakpoint) to be a genomic structural mutation, arising from breakage and repair of the chromosome. Such structural events include insertion, deletion, inversion and translocation, and often arise during recombination. 

This package seeks to determine, of the group of alignment stops, which are likely genomic breakpoints and analyse them. Thus, filtering out alignment stops that are a result of bioinformatic errors. 

## Visualising alignments

We can use the function `scaf_align_plot` to see the alignment of query scaffolds/chromosomes onto a specific reference scaffold/chromosome of interest.

```{r echo=T, message=F, warning=F}

scaf_align_plot(gr_ob = gr_O_Oki, scaf = "S2")

```

Here we have plotted the alignments on the Okinawa genome (y-axis) onto the Osaka genome, scaffold 2 (x-axis). The coverage of the alignment is the bar along the top. 

We can plot alignments for two of the reference scaffolds side-by-side, using `align_scaf_plot-2`. This can be used in aid of superscaffolding. 

```{r echo=T, message=F, warning=F}

align_scaf_plot_2(gr_ob = gr_O_Oki, scaf = c("S7","S5"))

```

As you can see, scaffold 2 of the query genome aligns to the majority of both reference scaffolds. This could be used as evidence to support the superscaffolding of these two scaffolds - in an effort toward chromosomal assembly. 

## Coalescing alignments

Large alignments can often appear cluttered with alignment breaks, spanning just a few basepairs. When the alignments skips this short distance, it is likely an artefact of the aligner and not a true breakpoint. Furthermore, we do not consider SNPs here to be breakpoints. Therefore, the algorithm in `coalesce_contigs` is used to produce a new GRanges object with fewer alignment breaks by coalescing alignments separated by short (user specified) distances. This distance need be agreeable in both the reference and query genome in order for the coalscion to happen. 

For example, coalescing gaps of less than 500 basepairs in the `gr_O_Oki` alignment:

```{r coalescing algorithm}
gr_O_Oki
reduced_gr_O_Oki <- coalesce_contigs(gr_O_Oki, tol = 1e7)
reduced_gr_O_Oki

gr_Oki_O
reduced_gr_Oki_O <- coalesce_contigs(gr_Oki_O, tol = 1e7)
reduced_gr_Oki_O

rbind(
  data.frame(
    width  = width(gr_O_Oki),
    object = "gr_O_Oki"
  ),
  data.frame(
    width  = width(reduced_gr_O_Oki),
    object= "reduced_gr_O_Oki"
  )
) %>% ggplot(aes(width)) + geom_histogram() + facet_wrap(~object)
```

The resulting GRanges object has far fewer alignments and therefore far fewer alignment stops. The algorithm is an initial step in alignment stop filtering, with the goal of a reduced number of alignment stops that have a high probability of being breakpoints.

## Trivial inversions

### Representation

The inversion below:

```
┌───────────────┬───────────────┬───────────────┐
│ XSR:101-200:+ │ XSR:201-300:- │ XSR:301-400:+ │  (OKI2018_I69)
└───────────────┴───────────────┴───────────────┘
┌───────────────┬───────────────┬───────────────┐
│  S1:101-200:+ │  S1:201-300:+ │  S1:301-400:+ │  (OSKA2016)
└───────────────┴───────────────┴───────────────┘
```

Is represented as:

```{r ideal_breakpoints}
inv       <- GRanges(c("XSR:101-200:+", "XSR:201-300:-",  "XSR:301-400:+"))
inv$query <- GRanges(c( "S1:101-200",    "S1:201-300",     "S1:301-400"))
inv

library("Gviz")
options(ucscChromosomeNames=FALSE)
gen <- GenomeAxisTrack(name = "genome")
trk <- AnnotationTrack(inv, name = "inv")
plotTracks(list(gen, trk))
```

*Without an outgroup it is not possible to know in which genome the break happened.*

Nevertheless, the outward regions are syntenic in both genomes.

### Detection

```{r detect_trivial_insertions}
plusMinPlus <- function (gr) {
  gr$oneNext <- precede(gr$query, tail(gr$query, -1), ignore.strand = T) - seq_along(gr) == 0
  gr$twoNext <- c(gr$oneNext[-1], NA)
  gr$oneDiffStrand <- strand(gr) != c(strand(tail(gr, -1)), factor("*"))
  gr$twoSameStrand <- strand(gr) == c(strand(tail(gr, -2)), factor(c("*", "*")))
  gr$plusMinPlus <- gr$oneNext & gr$twoNext & gr$oneDiffStrand & gr$twoSameStrand
  if (any(is.na(gr$plusMinPlus)))
    gr[is.na(gr$plusMinPlus)]$plusMinPlus <- FALSE
  gr
}

plusMinPlus(inv)
plusMinPlus(reduced_gr_O_Oki)$plusMinPlus == TRUE
plusMinPlus(gr_O_Oki)$plusMinPlus == TRUE

coalesce_contigs(gr_Oki_O, 500000) -> a
coalesce_contigs(sort(gr_Oki_O, i=T), 500000) -> b
identical(a,b)
plusMinPlus(a) -> x
x

r <- 1:3
seqinfo2gieStain <- function(si) {
  data.frame(
    chrom      = seqlevels(si),
    chromStart = 0,
    chromEnd   = seqlengths(si),
    name       = seqlevels(si),
    gieStain   = "gneg"
  )
}

gen <- GenomeAxisTrack(name="OKI2018_I69")
ide <- IdeogramTrack(chromosome = seqlevelsInUse(x[r]), genome = "OKI2018_I69", bands = seqinfo2gieStain(OKI2018_I69))
trk <- AnnotationTrack(x[r], name = "OKI2018_I69", id=LETTERS[seq_along(r)])
plotTracks(list(ide, gen, trk), featureAnnotation = "id")

gen <- GenomeAxisTrack(name="OSKA2016")
ide <- IdeogramTrack(chromosome = seqlevelsInUse(x$query[r]), genome = "OSKA2016", bands = seqinfo2gieStain(OSKA2016))

trk <- AnnotationTrack(x[r]$query, name = "OSKA2016", id=LETTERS[seq_along(r)])
plotTracks(list(ide,gen,trk), featureAnnotation = "id")
```

All `FALSE` ?  Shock !

## Tandem repeats

Repeated regions of genomes are notoriously difficult to assemble and align. Thus, information about an alignment stop's proximity to a tandem repeat is useful information in breakpoint classification. Given a user-defined tolerance, the function `tan_bp` will classify alignment stops as either far from, close to, or within tandem repeats (elements 1,2 and 3 of the produced list, respectively). The function requires the tandem repeat coverage of one of the genomes. By default, the function will expect the reference genome tandem coverage. Setting `query_tf = TRUE` will switch the outcome to be query genome oriented.

```{r echo=T, message=F, warning=F}

tan_O <- rtracklayer::import.gff3("inst/extdata/OSKA2016.tantanf4w100.gff3.gz")
tan_O <- GRanges(tan_O, seqinfo = seqinfo(OSKA2016))
tan_gr_O <- tan_bp(gr_ob = gr_O_Oki, tan = tan_O, tol = 50)
tan_gr_O

tan_Oki <- rtracklayer::import.gff3("inst/extdata/I69-5.tantanf4w100.gff3.gz")
tan_Oki <- GRanges(tan_Oki, seqinfo = seqinfo(OKI2018_I69))
tan_gr_Oki <- tan_bp(gr_ob = gr_O_Oki, tan = tan_Oki, tol = 50, query_tf = TRUE)
tan_gr_Oki

```

We can use another script to plot the density of tandem repeats around alignment stops (and breakpoints). In the following plots, breakpoints are aligned at the centre of the plots. Intuitively, this function can be generalised to see the density of any binary coverage characteristic around breakpoints, given a GRanges object with per-base coverage of a given characteristic. Here we stick with tandem repeat info:

```{r echo=T, message=F, warning=F}
hm_tan_O <- gr_O_Oki %>%
  tandem_coverage(tan_O, win = 1000, lab = "Osaka ~ Okinawa", direction = "left") %>%
  smoothHeatmap(output.size = c(2000,500), algorithm = "kernel") %T>%
  plotHeatmap

hm_red_tan_O <- reduced_gr_O_Oki %>%
  tandem_coverage(tan_O, win = 1000, lab = "Osaka ~ Okinawa", direction = "left") %>%
  smoothHeatmap(output.size = c(2000,500), algorithm = "kernel") %T>%
  plotHeatmap

hm_tan_Oki <- gr_Oki_O %>%
  tandem_coverage(tan_ref = tan_Oki, win = 1000, lab = "Osaka ~ Okinawa", direction = "left") %>%
  smoothHeatmap(output.size = c(2000,500), algorithm = "kernel") %T>%
  plotHeatmapList
```
## Coverage

Another characteristic of alignment stops that we can examine is the coverage depth over said alignment stops. By aligning raw reads to assembled genomes, we can obtain per-base coverage depth for reference or query genome. Low coverage directly on and surrounding an alignment stop may suggest unreliability in it being a true breakpoint. The function `bp_coverage` returns a GRanges object of the bps, with associated averaged and point converage in the metadatacolumns. 

```{r echo=T, message=F, warning=F}

cov_gr_O_Oki <- bp_coverage(gr_ob = q_Oki, cov_gr = Oki_cov_pb, win = 50)
cov_gr_O_Oki

```


## Breakpoint classification - master script

The function `master_bp_analysis` brings together the information about tandem repeats and coverage, as well as coalescing the alignment. It can perform the analyses for both the reference and the query genome, depending on the available input data. The output is split into two GRanges objects; one for the reference genome and one for the query, with associated information in the metadata columns. 

```{r echo=T, message=F, warning=F}

fin_gr_O_Oki <- master_bp_analysis(pair_gr = gr_O_Oki, co_tol = 500, ref_tan = tan_O, ref_tan_tol = 50, q_tan = tan_Oki,
                                   q_tan_tol = 50, q_cov = Oki_cov_pb, q_cov_tol = 50)
fin_gr_O_Oki

```


# Examples

## Nucleaic acid content heatmaps

We can use the GenomicBreaks function `bp_heatmap` to plot the desired nucleic acid content, with the alignment stops centred on the graph. Lets look at GC content before and after coalescing: 

```{r echo=T, message=F, warning=F}
hm_GC1 <- bp_heatmap(gr_O_Oki,         basep_range = 1000, pat = "GC", direction = "left")
hm_GC2 <- bp_heatmap(reduced_gr_O_Oki, basep_range = 1000, pat = "GC", direction = "left")

maxHeight <- 2000
sm_GC2_Height <- round(maxHeight * length(hm_GC2) / length(hm_GC1))

sm_GC1 <- smoothHeatmap(hm_GC1, output.size = c(maxHeight,     500), algorithm = "kernel")
sm_GC2 <- smoothHeatmap(hm_GC2, output.size = c(sm_GC2_Height, 500), algorithm = "kernel")

# Trying to plot the two heatmaps with different height according to their conntent,
# but without success...
plotHeatmapList(list(sm_GC1, sm_GC2), groups = 1:2)
```

The alignment stops are ordered in such a way that start (or left breaks) are centred on the top half of the plot, and end alignment stops are centred on the bottom. This is why we see different directionality in the plots. At the alignment stops, the GC content seems to be lower, but higher once within the aligned region. 

Now looking at TATA content:

```{r TATA}
hm_tata1 <- bp_heatmap(gr_O_Oki, basep_range = 1000, pat = "TATA", direction = "left")
sm_tata1 <- smoothHeatmap(hm_tata1, output.size = c(2000,500), algorithm = "kernel")

hm_tata2 <- bp_heatmap(reduced_gr_O_Oki, basep_range = 1000, pat = "TATA", direction = "left")
sm_tata2 <- smoothHeatmap(hm_tata2, output.size = c(2000,500), algorithm = "kernel")

plotHeatmapList(list(sm_tata1, sm_tata2))
plotHeatmapList(list(sm_GC2, sm_tata2))
```

The directionaility here is consistent with the GC content analysis. Furthermore; "TATA box sequence can act as a basal promoter element not only for RNA polymerase II (RNAP II) transcription, but also for transcription by RNA polymerase III (RNAP III)" - Wang Y, Jensen RC, Stumph WE. Role of TATA box sequence and orientation in determining RNA polymerase II/III transcription specificity. Nucleic Acids Res. 1996;24(15):3100–3106. doi:10.1093/nar/24.15.3100. However, the areas are not particularly enriched for TATA boxes, so it does not necessarily show that breakpoints are occuring directly after promotor regions. 

## Cluster analysis


```{r cluster_analysis}
# Accessory functions
clusterHeatmap <- function(hm, k = 2) kmeans(image(hm), k)

orderHeatmap <- function(hm, cl) {
  image(hm) <- image(hm)[order(cl$cluster),]
  hm
}

subsetHeatmap <- function(hm, bool) {
  image(hm) <- image(hm)[bool,]
  hm
}

# DAta
hm_GC   <- bp_heatmap(     gr_Oki_O, basep_range  = 1000, pat = "GC",     direction = "left")
hm_TATA <- bp_heatmap(     gr_Oki_O, basep_range  = 1000, pat = "TATA",   direction = "left")
hm_tan  <- tandem_coverage(gr_Oki_O, tan_Oki, win = 1000, lab = "Tandem", direction = "left")

# Define 3 K-mean clusters
clusterHeatmap(hm_GC, 3) -> hm_cl_k4

# Order and smooth
shm_GC <- orderHeatmap(hm_GC, hm_cl_k4) %>%
  smoothHeatmap(output.size = c(2000,500), algorithm = "kernel")

shm_TATA <- orderHeatmap(hm_TATA, hm_cl_k4) %>%
  smoothHeatmap(output.size = c(2000,500), algorithm = "kernel")

shm_tan <- orderHeatmap(hm_tan, hm_cl_k4) %>%
  smoothHeatmap(output.size = c(2000,500), algorithm = "kernel")

# Plot the ordered data
plotHeatmapList(list(shm_GC, shm_TATA, shm_tan))
par(mfrow = c(1,1)) # plotHeatmapList messes with mrfrow...
plotHeatmapMeta(list(hm_GC, hm_TATA, hm_tan))

plotHeatmapMeta(list(subsetHeatmap(hm_GC, hm_cl_k4$cluster == 1),
                     subsetHeatmap(hm_GC, hm_cl_k4$cluster == 2),
                     subsetHeatmap(hm_GC, hm_cl_k4$cluster == 3)))

kmeanOrderedPlot <- function (hm, k=3, seed = 1) {
  set.seed(seed)
  
  cl <- kmeans(image(hm), k)
  mat <- image(hm)[order(cl$cluster),]
  
  kmhm = Heatmap(
    mat,
    coords=c(-500,500),
    label="kmeans",
    scale=range(mat))
  
  plotHeatmapList(kmhm,
                  cex.label=1.5,
                  partition=as.vector(table(cl$cluster)),
                  partition.legend=TRUE,
                  partition.lines=TRUE,
                  legend=TRUE,
                  legend.pos="r",
                  legend.width=0.3)
}

kmeanOrderedPlot(shm_GC)
```

## Evidence for breakpoint hotspots

The function `bp_pair_analysis` takes two pairwise alignments with the same reference genome, and plots the alignment stops on to the centred alignment stops of the other. In the plot below, Osaka is there consistent reference genome, and as such acts as a coordinate system to relate alignment stops across genomes. Lets produce two of these 3-way analyses; one between Osaka-Okinawa-Norway, and one between Osaka-Okinawa-Aomori

```{r echo=T, message=F, warning=F}

hm1 <- bp_pair_analysis(gr_ref_q1 = gr_O_Oki, gr_ref_q2 = gr_O_N, win = 1000, lab = "Oki~Nor")
plotHeatmapMeta(hm1)

hm2 <- bp_pair_analysis(gr_ref_q1 = gr_O_Oki, gr_ref_q2 = gr_O_A, win = 1000, lab = "Oki~Aom")
plotHeatmapMeta(hm2)

```

The accumulation of alignment breaks of one pairwise alignment onto another suggests the existence of breakpoint hotspots; regions where breaks are far more likely to occur. Intuitively, this would lead to the presumption of synteny blocks, also. The pattern is consistent after coalescing, too;

```{r echo=T, message=F, warning=F}

reduced_gr_O_N <- coalesce_contigs(gr_ob = gr_O_N, tol = 500)

hm3 <- bp_pair_analysis(gr_ref_q1 = reduced_gr_O_Oki, gr_ref_q2 = reduced_gr_O_N, win = 1000, lab = "Oki~Nor")
plotHeatmapMeta(hm3)

```

## Tandem repeat coverage around alignment stops (breakpoints)

The function `tandem_coverage` will plot the coverage of tandem repeats around centred alignment stops. 

```{r echo=T, message=F, warning=F}

hm_tan1 <- tandem_coverage(gr_ob = gr_O_Oki, tan_ref = tan_O, win = 2000, lab = "Osk ~ Oki")
plotHeatmapMeta(hm_tan1)

hm_tan2 <- tandem_coverage(gr_ob = reduced_gr_O_Oki, tan_ref = tan_O, win = 2000, lab = "OSK~Oki (coalesced)")
plotHeatmapMeta(hm_tan2)

# should I also add comparison of proportions of tandem proximities before and after coalescion?

```

There appears to be less tandem repeats around alignment stops after coalescion, inferring that perhaps that some are artefacts of difficult alignment near to tandem repeats. 


## Okinawa genome coverage

As previously discussed, low coverage over an alignment stop could lower the likelihood of it being considered as a breakpoint. We have per-base coverage depth information for the Okinawan genome (`Oki_cov_pb`). However, the coverage of this particular assembly is quite good. In fact, we can investigate the coverge over alignment stops from the information obtained using `master_bp_analysis`. 

```{r echo=T, message=F, warning=F}
fin_Oki <- fin_gr_O_Oki[[2]]
min_cov <- min(min(fin_Oki$left_cov_pb), min(fin_Oki$right_cov_pb)) # minimum coverage over an alignment stop
min_cov
length(fin_Oki[fin_Oki$left_cov_pb == min_cov]) + length(fin_Oki[fin_Oki$right_cov_pb == min_cov]) # how many of the minimum coverage is observed
length(fin_Oki[fin_Oki$left_cov_pb <= 50]) + length(fin_Oki[fin_Oki$right_cov_pb <= 50]) # how many alignment stops have a coverage of less than or euqal to 50

```

We may choose to kick out the one alignment stop for which there is no coverage. However, only 15 out of 34572 alignment stops have a coverage of less than or equal to 50, meaning that it would be hard to exclude more than just a few alignment stops using coverage information for breakpoint analysis. 



