---
title: "GenomicBreaks Vignette"
author: 
 - "Charlotte West"
 - "Charles Plessy"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEncoding[utf8]{inputenc}
  %\VignetteEncoding{UTF-8}
  %\VignetteIndexEntry{GenomicBreaks}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup}
knitr::opts_chunk$set(cache = TRUE)
knitr::opts_knit$set(verbose = TRUE)
```

# Introduction

The GenomicBreaks R package contains tools for visualising and analysing
characteristics associated with 'breakpoints' between pairs of genomes.

## Load pacakges

Core packages that provide functions we use a lot.

```{r loadlib, echo=T, results='hide'}
suppressPackageStartupMessages({
library(GenomicRanges)
library(ggplot2)
})
```

### BSgenome packages

The Oikopleura BSgenome packages are distributed in a drat directory hosted on GitHub
((oist/plessy_oikgenomes_drat)[https://oist.github.io/plessy_oikgenomes_drat/]).

To install them:

```{r install_drat_BSgenome_packages, eval=FALSE}
install.packages("BSgenome.Odioica.local.Odioica.reference.v3.0", repos="https://oist.github.io/plessy_oikgenomes_drat/")
install.packages("BSgenome.Odioica.local.OKI2018.I69", repos="https://oist.github.io/plessy_oikgenomes_drat/")
install.packages("BSgenome.Odioica.local.OSKA2016v1.9", repos="https://oist.github.io/plessy_oikgenomes_drat/")
install.packages("BSgenome.Odioica.local.OSKA2016", repos="https://oist.github.io/plessy_oikgenomes_drat/")
```

Other BSgenome packages are distributed by Bioconductor

```{r install_Bioc_BSgenome_pacakges, eval=FALSE}
BiocManager::install("BSgenome.Hsapiens.UCSC.hg38")
BiocManager::install("BSgenome.Ptroglodytes.UCSC.panTro6")
```

```{r load_BSgenome_packages}
# These will need to be installed by the user
library("BSgenome.Odioica.local.OKI2018.I69")
library("BSgenome.Odioica.local.OSKA2016v1.9")
library("BSgenome.Odioica.local.Odioica.reference.v3.0")
```

### The GenomicBreaks package itself

```{r load_GenomicBreaks}
library(GenomicBreaks)
```

## Load data

### Genome annotations.

```{r load_genomic_features}
tx_OKI <- rtracklayer::import.gff3(system.file("extdata/OKI2018_I69_1.0.gene_models.gff3.gz", package = "GenomicBreaks"))
tx_OKI <- GRanges(tx_OKI, seqinfo = seqinfo(OKI2018_I69))
tx_OKI <- GenomicFeatures::makeTxDbFromGRanges(tx_OKI)

OKI_longShort <- rtracklayer::import.gff3(system.file("extdata/OKI2018_I69.arms.gff3", package = "GenomicBreaks"))
OKI_longShort <- GRanges(OKI_longShort, seqinfo = seqinfo(OKI2018_I69), strand = "*")
```

### GenomicBreaks object

Let's load data from genome alignments, copied in the `Oidioi_pairwise_v3`
directory.

```{r GRanges object}
gbs <- SimpleList()
gbs$Osa_Oki <- load_genomic_breaks("Oidioi_pairwise_v3/OSKA2016v1.9__OKI2018_I69_1.0.gff.gz", OSKA2016v1.9, OKI2018_I69)
gbs$Oki_Osa <- load_genomic_breaks("Oidioi_pairwise_v3/OKI2018_I69_1.0__OSKA2016v1.9.gff.gz", OKI2018_I69,  OSKA2016v1.9)
gbs$Oki_Nor <- load_genomic_breaks("Oidioi_pairwise_v3/OKI2018_I69_1.0__OdB3.gff.gz",         OKI2018_I69,  OdB3)
gbs$Osa_Nor <- load_genomic_breaks("Oidioi_pairwise_v3/OSKA2016v1.9__OdB3.gff.gz",            OSKA2016v1.9, OdB3)

gbs$Osa_Oki
gbs$Osa_Oki$query
```

Pairwise genome alignments are loaded in `GBreaks` objects that wrap the
`GRanges` class.  By convention, we
write that _query_ genome (the one that was provided as a FASTA file) is aligned
to the _target_ genome (the one that was indexed by the aligner).  The target
genome (left) is the main part of the object, and the query genome information
(right) is contained in the metadata of the structure.  Information on contig
or scaffold length is loaded from `BSgenome` objects, from which `seqinfo` data
is extracted and passed to the `GRanges`.  By convention, strand information
of the alignment is held by the target `GRanges`, and the query `GRanges`
are strandless.  The objects are sorted by `seqname` first.

In the example displayed above, the object contains the pairwise alignment
between genomes of two dioceous Oikopleura individuals; one from Osaka assembly
_OSKA2016_ (target) and one from Okinawa assembly _OKI2018_I69_ (query).

The process of pairwise genome alignment first requires the construction of two sequenced genomes, necessitating many steps; seqencing, basecalling, assembly, etc. In this process, errors inevitably arise - from incorrect base calls to misassemblies. These errors can be exacerbated in the alignment process, and coupled with difficult repeated regions, can cause failure to align homologous regions, or misalignments.

### Breakpoints and alignment stops

Let us define an **alignment stop** to be a position defined in either the target or query genome, where an alignment begins or ends. Looking at the first line in `gr_O_Oki` above, S1 positions 162 and 550 of the target would be defined as alignment stops. Correspondingly, we have positions 909374 and 909853 in XSR of the query genome as alignment stops. 

The function `get_bps` takes in a GRanges pairwise alignment, and produces a GRanges object of it's associated alignment stops. 

```{r get bps}
gbs$Osa_Oki
get_bps(gbs$Osa_Oki)
get_bps(gbs$Osa_Oki, direction = "left")
get_bps(gbs$Osa_Oki,                      stranded = TRUE)
get_bps(gbs$Osa_Oki,                      stranded = TRUE, sorted = FALSE)
get_bps(gbs$Osa_Oki, direction = "right", stranded = TRUE)
get_bps(gbs$Osa_Oki$query, sorted = FALSE)
get_bps(gbs$Osa_Oki$query)
```

Now, let us define a **genomic breakpoint** (or simply breakpoint) to be a genomic structural mutation, arising from breakage and repair of the chromosome. Such structural events include insertion, deletion, inversion and translocation, and often arise during recombination. 

This package seeks to determine, of the group of alignment stops, which are likely genomic breakpoints and analyse them. Thus, filtering out alignment stops that are a result of bioinformatic errors.

## Measures of distance

### Synteny index

Ad-hoc index measuring to what extent a scaffold of the _target_ genome is mostly
aligned to a single scaffold in the _query_ genome.   See
`?GenomicBreaks::synteny_index` for details.

```{r}
sapply(gbs, synteny_index)
synteny_index(gbs$Oki_Nor)
synteny_index(swap(gbs$Oki_Nor))
```

The problem with this index is that it requires that at least the query
genome is a complete chromosome assembly.

### Correlation

Ad-hoc index measuring the correlation of the coordinates of the syntenic
alignments in scaffolds of a _target_ genome and their best match in the
_query_ genome.  See `?GenomicBreaks::correlation_index` for details.

```{r}
sapply(gbs, correlation_index)
correlation_index(gbs$Oki_Nor)
correlation_index(swap(gbs$Oki_Nor))
```

This index is more robust to the presence of uncollapsed haplotypes in the
_query_ genome.

## Phylogenetic tree

We assume that the _North Pacific_ and the _Atlantic_ species are more related
to each other than to the _Okinawa_ species.

The purpose of the `mkTree` function is to make new trees with the same topology
and scaffold names instead of species names.  If there is a way to simple relabel
leaves in existing tree, please let me know.

```{r phylogenetic_tree, fig.height=4, fig.width=6, dev="svg"}
requireNamespace("ade4")
mkTree <- function (Oki, Osaka, Norway) {
  ade4::newick2phylog(
    paste0(
      "(", Oki, ":2,",
        "(", Osaka, ":1, ",
             Norway, ":1",
        "):1",
      ");"
    )
  )
}
tree <- mkTree("Okinawa", "North Pacific", "Norway")
plot(tree)
```

## Visualising alignments

We can use the function `scaf_align_plot` to see the alignment of query
scaffolds/chromosomes onto a specific target scaffold/chromosome of interest.

```{r echo=T, message=F, warning=F}
scaf_align_plot(gbs$Osa_Oki, scaf = "Chr1")
scaf_align_plot(gbs$Oki_Osa, scaf = "chr1")
```

Here we have plotted the alignments on the Okinawa genome (y-axis) onto the Osaka genome, scaffold 2 (x-axis). The coverage of the alignment is the bar along the top. 

We can plot alignments for two of the target scaffolds side-by-side, using `align_scaf_plot-2`. This can be used in aid of superscaffolding. 

```{r echo=T, message=F, warning=F}
align_scaf_plot_2(gbs$Osa_Oki, scaf = c("Chr1","Chr2"))
```

As you can see, scaffold 2 of the query genome aligns to the majority of both target scaffolds. This could be used as evidence to support the superscaffolding of these two scaffolds - in an effort toward chromosomal assembly. 

## Coalescing alignments

Large syntenic regions can often appear cluttered with alignment breaks,
spanning just a few basepairs.  They are either an artefact (for instance in
case of incomplete purge of haplotypes) and or true breakpoint.  The algorithm
in `coalesce_contigs` is used to produce a new GRanges object with fewer
alignment breaks by coalescing alignments separated by short (user specified)
distances.  This distance need be agreeable in both the target and query genome
in order for the coalscion to happen. 

For example, coalescing gaps of less than 500 basepairs in the `gbs$Osa_Oki` alignment:

```{r coalescing algorithm}
coa <- sapply(gbs, coalesce_contigs) |> SimpleList()
sapply(gbs, head)
sapply(coa, head)
```

The resulting GRanges object has far fewer alignments and therefore far fewer
alignment stops. The algorithm is an initial step in alignment stop filtering,
with the goal of a reduced number of alignment stops that have a high
probability of being breakpoints.

### Narrow-width alignments

 - What do they represent ?
 - Keep or discard ?

```{r}
coaW1000 <- sapply(gbs, coalesce_contigs, minwidth = 1000) |> SimpleList()
sapply(coaW1000, head)
```

### Summary plot

```{r width_after_coalescing}
widthPlot <- function(gb_parts, gb_col, gb_colW1000) {
  # Need to wrap in a function to handle empty GRanges objects...
  width2df <- function(what, gb) {
    if (length(gb) == 0) return (NULL)
    data.frame(what = what, width = width(gb))
  }
  df <- rbind(
    width2df(what = "aligned",     gb = gb_parts),
    width2df(what = "collapsed",   gb = gb_col),
    width2df(what = "collapsed minW1000", gb = gb_colW1000)
  )
  ggplot(df) +
    aes(width) +
    geom_histogram() +
    scale_x_log10() +
    facet_wrap(~what, ncol = 1, scales = "free_y")
}

widthPlot(gbs$Osa_Oki, coa$Osa_Oki, coaW1000$Osa_Oki)
```

## Genome plots with genoPlotR

```{r test_genoPlotR}
library("genoPlotR")

example("dna_seg")

gr2dna_seg <- function (gr) {
  if (is.null(names(gr))) names(gr) <- as.character(gr)
  strand(gr[strand(gr) == "*"]) <- "+"
  df <- data.frame(
    name   = names(gr),
    start  = start(gr),
    end    = end(gr),
    strand = strand(gr),
    col    = "grey"
  )
  dna_seg(df)
}

gbRef2dna_seq <- function (gb) {
  if (is.null(names(gb))) names(gb) <- as.character(gb)
  strand(gb) <- "+"
  gr2dna_seg(gb)
}

gbQuery2dna_seq <- function (gb) {
  if (is.null(names(gb$query))) names(gb$query) <- as.character(gb)
  strand(gb$query) <- strand(gb)
  gr2dna_seg(gb$query)
}

ds <- gr2dna_seg(reduced_gr_Oki_O[seqnames(reduced_gr_Oki_O) == "chr1"])
head(ds) ; tail(ds)
plot_gene_map(list(ds))
plot_gene_map(list(ds[2000:2100,]))

gb2comp <- function(gb) {
  ref <- gr2dna_seg(gb)
  strand(gb$query) <- "+"
  que <- gr2dna_seg(gb$query)
  df <- data.frame(
    start1 = ref$start,
    end1   = ref$end,
    start2 = que$start,
    end2   = que$end
  )
  as.comparison(df)
}

roi <- reduced_gr_Oki_O[2044:2050]
roiNameA <- seqlevelsInUse(roi$query)[3]
roiNameB <- seqlevelsInUse(roi)[]
roiNameC <- seqlevelsInUse(roi$query)[2]
dsList <-   list(
    roi[seqnames(roi$query) == roiNameA] %>% gbQuery2dna_seq,
    roi                                  %>% gbRef2dna_seq,
    roi[seqnames(roi$query) == roiNameC] %>% gbQuery2dna_seq
    )
names(dsList) <- c(roiNameA, roiNameB, roiNameC)


compList <- list(
    roi[seqnames(roi$query) == roiNameA] %>% swap %>% gb2comp,
    roi[seqnames(roi$query) == roiNameC] %>% gb2comp
  )
plot_gene_map(dsList, compList)
```

## Extract ranges from the same reference region in two GenomicBreaks objects

```{r intersect_GBs}
#roi <- GRanges("chr1:1222000-1240000")
#roi <- GRanges("chr1:1023578-1032430")
#roi <- GRanges("chr1:2668866-2692347")
roi <- GRanges("chr1:6379932-6505436")
#roi <- GRanges("chr1:6683567-6744168")
roi <- GRanges("chr1:7711018-7734330")
#roi <- GRanges("chr1:7711018-7734330") + 10000

roi_Oki_O <- subsetByOverlaps(doubleReduced_gr_Oki_O, roi)
roi_Oki_N <- subsetByOverlaps(doubleReduced_gr_Oki_N, roi)
roi2 <- range(subsetByOverlaps(doubleReduced_gr_Oki_O, roi)$query)
roi_O_N <- subsetByOverlaps(doubleReduced_gr_O_N, roi2)
```

### Plot a simple region.

This region can be plotted because there is a one-to-one correspondence
between alignments to Osaka and alignments to Norway.

```{r plot_intersect_GBs}
roiNameO <- seqlevelsInUse(roi_Oki_O$query)[1]
roiNameOki <- seqlevelsInUse(roi)[1]
roiNameN <- seqlevelsInUse(roi_Oki_N$query)[1]

dsList <-   list(
    roi_Oki_O[seqnames(roi_Oki_O$query) == roiNameO] %>% gbQuery2dna_seq,
    roi_Oki_O[seqnames(roi_Oki_O$query) == roiNameO] %>% gbRef2dna_seq,
    roi_Oki_N[seqnames(roi_Oki_N$query) == roiNameN] %>% gbRef2dna_seq,
    roi_Oki_N[seqnames(roi_Oki_N$query) == roiNameN] %>% gbQuery2dna_seq
    )
names(dsList) <- c(roiNameO, roiNameOki, roiNameOki, roiNameN)

tmpgb <- roi_Oki_O
tmpgb$query <- granges(roi_Oki_N)

compList <- list(
    roi_Oki_O[seqnames(roi_Oki_O$query) == roiNameO] %>% swap %>% gb2comp,
    tmpgb %>% gb2comp,
    roi_Oki_N[seqnames(roi_Oki_N$query) == roiNameN] %>% gb2comp
  )

plot_gene_map(dsList, compList, dna_seg_scale=TRUE)
```

```{r plot_intersect_GBs_with_tree}
dsList <-   list(
    roi_Oki_N[seqnames(roi_Oki_N$query) == roiNameN] %>% gbRef2dna_seq,
    roi_Oki_O[seqnames(roi_Oki_O$query) == roiNameO] %>% gbQuery2dna_seq,
    roi_Oki_N[seqnames(roi_Oki_N$query) == roiNameN] %>% gbQuery2dna_seq
    )
names(dsList) <- c(roiNameOki, roiNameO, roiNameN)

compList <- list(
    roi_Oki_O[seqnames(roi_Oki_O$query) == roiNameO] %>% gb2comp,
    roi_O_N[seqnames(roi_O_N$query) == roiNameN] %>% gb2comp
  )

plot_gene_map(dsList, compList, dna_seg_scale=TRUE, tree=mkTree(roiNameOki, roiNameO, roiNameN))
```

## Trivial inversions

### Representation

In the triplet of alignments below below, the middle block is on a different
strand than its neighbors, and they would be colinear otherwise.  This represents
an inversion.  *Without an outgroup it is not possible to know in which of the
target or query genome the break happened.*

Let's call "gaps" the unaligned regions between the blocks.

```
┌───────────────┬───────────────┬───────────────┐
│ XSR:101-200:+ │ XSR:201-300:- │ XSR:301-400:+ │  (OKI2018_I69)
└───────────────┴───────────────┴───────────────┘
┌───────────────┬───────────────┬───────────────┐
│  S1:101-200:+ │  S1:201-300:+ │  S1:301-400:+ │  (OSKA2016)
└───────────────┴───────────────┴───────────────┘
```

It is represented as:

```{r ideal_breakpoints}
example("flagInversions")

library("Gviz")
options(ucscChromosomeNames=FALSE)
gen <- GenomeAxisTrack(name = "genome")
trk <- AnnotationTrack(inv, name = "inv")
plotTracks(list(gen, trk))
```


### Number of trivial inversions

```{r detect_trivial_invertions}
sapply(gbs, function(gb) sum(flagInversions(coalesce_contigs(gb))$inv))
```

Approximately 1/4 less inversions are detected in Osaka–Norway comparisons.

### Isolate the left-side gaps in inversions

```{r search_for_inversions}

lgaps <- function(reduced_gr) {
  # Flag inversions.
  #  WHAT FOLLOWS ASSUMES THAT THE FLAG IS ON THE LEFT-SIDE BLOCK OF THE TRIPLE
  lgaps <- flagInversions(reduced_gr)
  # Extract inversions
  invs <- lgaps[lgaps$inv]
  # Extend inversion of 1 bp so that they overlap with their neighbor gap
  invs <- shift(invs, 1)
  # Remove strand information
  strand(lgaps) <- "*"
  # Then extract gap positions ignoring strand
  lgaps <- gaps(lgaps)
  # Remove bogus gaps on + and - strands
  lgaps <- lgaps[strand(lgaps) == "*"] 
  # Return the gaps overlapping with the flagged inversions
  subsetByOverlaps(lgaps, invs)
}


#filterInv3(reduced_gr_Oki_O) %>% Head(20)
#filterInv3(reduced_gr_Oki_N) %>% Head(20)

data.frame(width=width(lgaps_Oki_O)) |>
  ggplot(aes(width)) + geom_histogram() +  scale_x_log10()

rbind(
  data.frame(
    width  = x[x$inv]$rdist,
    object = "Target"
  ),
  data.frame(
    width  = x[x$inv]$qdist,
    object= "Query"
  )
) |> ggplot(aes(width)) + geom_histogram() + facet_wrap(~object) +scale_x_log10() +
  ggtitle("Width of the left-side unaligned region in inversions detected in reduced_gr_Oki_O")

lgaps_Oki_O <- lgaps(coa$Oki_Osa)
# Note that lgaps(gr_Oki_O) returns less inversions because
# of situations where + - + is + - - + before collapsing. 
lgapsSeq_Oki_O <- BSgenome::getSeq(OKI2018_I69, lgaps_Oki_O)
```

### AT richness

```{r at_richness}
## Genome average
ATcontent <- function(g)
  weighted.mean(letterFrequency(getSeq(g), "AT", as.prob = TRUE), seqlengths(g))

sapply(c(Oki=OKI2018_I69, Osa=OSKA2016v1.9, Nor=OdB3), ATcontent)

## Inverted regions are AT-rich as usual.
invSeq_Oki_O <- BSgenome::getSeq(OKI2018_I69,  filterInv(flagInversions(coa$Oki_Osa)))
letterFrequency(invSeq_Oki_O, "AT", as.prob = TRUE) |> summary()

## But gaps are a bit more AT-rich.
letterFrequency(lgapsSeq_Oki_O, "AT", as.prob = TRUE) |> summary()

## This difference is significant.
t.test(letterFrequency(invSeq_Oki_O, "AT", as.prob = TRUE), letterFrequency(lgapsSeq_Oki_O, "AT", as.prob = TRUE))
```

I was tempted to explain this difference with A/T homopolymer stetches.  But
de novo motif prediction with rGADEM finds AT-rich motifs in any set of Oik
sequences that I have tried.

```{r search_for_motifs_in_inversions}
library("rGADEM")
# Slow !
# Note that GADEM crashes on sequences longer than 50 kbp.
# gadem <- GADEM(invSeq_Oki_O[width(invSeq_Oki_O) < 50000], verbose=1, genome=OKI2018_I69)
# consensus(gadem)
# [1] "nAAAAwwnnnrAAAAn"

# gadem <- GADEM(lgapsSeq_Oki_O, verbose=1, genome=OKI2018_I69)
# consensus(gadem)
# [1] "rAAGCsGCwwmkCGrCTTyn" "nAAAAwwnnwnAAAAAn"    "nTTTsAAAAw"           "nCCTGAsTCAGGkTTTn"    "nTTTTTnnnnrAAAn"      "wTAAGGGTrTCm"

#saveRDS(gadem, file = "lgapsSeq_Oki_O_gadem.rds")
gadem <- readRDS("lgapsSeq_Oki_O_gadem.rds")

pwm <- rGADEM::getPWM(gadem)[[1]]
seqLogo::seqLogo(pwm)
slPWM <- seqLogo::makePWM(pwm)

#RGadem positive control: check introns ?
# set.seed(1664)
# intr <- sample(intronicParts(tx_OKI), 1000)
# intr <- BSgenome::getSeq(OKI2018_I69, intr)
# gadem <- GADEM(intr, verbose=1, genome=OKI2018_I69)
# > consensus(gadem)
# [1] "nAAAAwnnwnAAAwn"
# Also found motifs like rryCAATTbwTkCGmAkyT


#RGadem positive control: check promoters ?
# set.seed(1664)
# prom <- sample(promoters(tx_OKI), 1000)
# prom <- BSgenome::getSeq(OKI2018_I69, prom)
# gadem <- GADEM(prom, verbose=1, genome=OKI2018_I69)
# consensus(gadem)
# [1] "nAAAAwwnwnnAAAAwn" "nTTTTCTTyn"       
# Also found motifs like TTTmAAAA
```

A palindromic (rAAGCsGCwwmkCGrCTTyn) motif is found in the left gaps.

```{r screenJaspar}
checkJaspar <- function (pwm) {
  #---- see https://compgenomr.github.io/book/motif-discovery.html
  pwmLib <- getMatrixSet(
    JASPAR2018::JASPAR2018,
    opts = list(
      collection = 'CORE',
   #   species    = 'Homo sapiens',
      matrixtype = 'PWM'))
  
  pwm_sim <- PWMSimilarity( pwmLib, PWMat,  method = 'Pearson')

  pwmLibDf <- data.frame(
    ID        = sapply(pwmLib, ID),
    name      = sapply(pwmLib, name),
    row.names = seq_along(pwmLib)
  )
  pwmLibDf$similarity <- pwm_sim[pwmLibDf$ID]
  pwmLibDf[order(-pwmLibDf$similarity),]
}

PWMat <- PWMatrix(ID="rAAGCsGCwwmkCGrCTTyn", profileMatrix = pwm)
pwm_res <- checkJaspar(PWMat)
head(pwm_res)

pwmhalf <- pwm[,2:8]
pwmhalf_res <- checkJaspar(PWMatrix(ID="AAGCnGC", profileMatrix = pwmhalf))
head(pwmhalf_res)
```

But a search in Jaspar with either the full motif or its halof did not reveal
strong hits.  Visual inspection of PRDM9 sequence logos via Google did not show
similarity either.

### Export rAAGCsGCwwmkCGrCTTyn alignments to a file

```{r pwmHitSequenceExportForGLAM2}
gademHitsToBS <- function(gadem, n) {
  alignList <- gadem[[n]]@alignList
  pwmSeqs <- sapply(alignList, function(align) align@seq)
  Biostrings::DNAStringSet(pwmSeqs)
}

pwmSeqs <- gademHitsToBS(gadem, 1)
writeXStringSet(pwmBS, file="firstGapsGADEMpwm.fasta")

# writeXStringSet(lgapsSeq_Oki_O, file="firstGaps.fasta")
# I used this FASTA export to search for motifs with GLAM2, and it also
# returned A/T polymers.
```

The GLAM2 motif finder was run on this file, and then to screen the genome.
Hits coordinates were encoded in a BED file uploaded to the ZENBU genome browser.
Visual inspection gave me the impression that the motif might be related to
repeats.

GLAM2 search of the gap sequences did not return a motif similar to "AAGCsGCwwmkCGrCTTyn".

### Whole-genome search of the motif

Disappointingly, the motif is found equally in gaps and inversions when searched
with its PWM.

```{r }
# No exact match
vmatchPattern("AAGCsGCwwmkCGrCTTyn", OKI2018_I69)

pwmHits <- matchPWM(pwm, OKI2018_I69)
length(pwmHits)
hist(score(pwmHits))

# Less hits, with lower scores, in the mm10 genome.
pwmHitsmm10 <- matchPWM(pwm, BSgenome.Mmusculus.UCSC.mm10::BSgenome.Mmusculus.UCSC.mm10)

hist(score(subsetByOverlaps(pwmHits, lgaps_Oki_O)))
hist(score(subsetByOverlaps(pwmHits, invs)))

# Scores in gaps are higher than average.
t.test(score(pwmHits), score(subsetByOverlaps(pwmHits, lgaps_Oki_O)))

# Scores in gaps and inversions are not different 
t.test(score(subsetByOverlaps(pwmHits, invs)), score(subsetByOverlaps(pwmHits, lgaps_Oki_O)))

rtracklayer::export.bed(pwmHits, "AAGCsGCwwmkCGrCTTyn.bed")

# PWM hits seem to be more abundant on short arms.
OKI_longShort$pwmHitsPerMb <- countOverlaps(OKI_longShort, pwmHits) / width(OKI_longShort) * 1e6
# But with a naive approach the difference is not satistically significant.
t.test(c(159, 185, 188), c(77, 142, 160))
```

### Representation of some inversions

```{r}
x <- reduced_gr_Oki_O %>% flagInversions() %>% dist2next(ignore.strand = TRUE)

pmpcoord <- which(x$inv == TRUE)
pmpcoord <- c(pmpcoord, pmpcoord + 1, pmpcoord + 2)
pmpcoord <- sort(unique(pmpcoord))
x[pmpcoord]

seqinfo2gieStain <- function(si) {
  data.frame(
    chrom      = seqlevels(si),
    chromStart = 0,
    chromEnd   = seqlengths(si),
    name       = seqlevels(si),
    gieStain   = "gneg"
  )
}

#r <- 63:70
r <- 94:98
#r <- 316:319
options(ucscChromosomeNames=FALSE)
gen <- GenomeAxisTrack(name="OKI2018_I69")
ide <- IdeogramTrack(chromosome = seqlevelsInUse(x[r]), genome = "OKI2018_I69", bands = seqinfo2gieStain(OKI2018_I69))
trk <- AnnotationTrack(x[r], name = "OKI2018_I69", id=LETTERS[seq_along(r)])
p1 <- grid::grid.grabExpr(plotTracks(list(ide, gen, trk), featureAnnotation = "id"))

gen2 <- GenomeAxisTrack(name="OSKA2016")
ide2 <- IdeogramTrack(chromosome = seqlevelsInUse(x$query[r]), genome = "OSKA2016", bands = seqinfo2gieStain(OSKA2016))
trk2 <- AnnotationTrack(x[r]$query, name = "OSKA2016", id=LETTERS[seq_along(r)])
p2 <- grid::grid.grabExpr(plotTracks(list(ide2,gen2,trk2), featureAnnotation = "id"))

gridExtra::grid.arrange(p1, p2, nrow=2)
```

## Trivial insersions

### Representation

The in<b>s</b>ersion below:

```
┌───────────────┬───────────────┬───────────────┐
│ XSR:101-200:+ │ XSR:201-300:+ │ XSR:301-400:+ │  (OKI2018_I69)
└───────────────┴───────────────┴───────────────┘
┌───────────────┬───────────────┬───────────────┐
│  S1:101-200:+ │  S2:801-900:+ │  S1:201-300:+ │  (OSKA2016)
└───────────────┴───────────────┴───────────────┘
```

Is represented as:

```{r ideal_insertions}
example("flagInsersions")

library("Gviz")
options(ucscChromosomeNames=FALSE)
gen <- GenomeAxisTrack(name = "genome")
trk <- AnnotationTrack(ins, name = "ins")
plotTracks(list(gen, trk))
```

*Without an outgroup it is not possible to know in which genome the break happened.*

### Detection

```{r detect_trivial_insertions}
sapply(gbs, function(gb) sum(flagInsersions(coalesce_contigs(gb))$ins))

y <- flagInsersions(reduced_gr_Oki_O)

#r <- 63:70
r <- 23:30
#r <- 316:319
options(ucscChromosomeNames=FALSE)
gen <- GenomeAxisTrack(name="OKI2018_I69")
ide <- IdeogramTrack(chromosome = seqlevelsInUse(x[r]), genome = "OKI2018_I69", bands = seqinfo2gieStain(OKI2018_I69))
trk <- AnnotationTrack(x[r], name = "OKI2018_I69", id=LETTERS[seq_along(r)])
p1 <- grid::grid.grabExpr(plotTracks(list(ide, gen, trk), featureAnnotation = "id"))

gen2 <- GenomeAxisTrack(name="OSKA2016")
ide2 <- IdeogramTrack(chromosome = seqlevelsInUse(x$query[r])[1], genome = "OSKA2016", bands = seqinfo2gieStain(OSKA2016))
trk2 <- AnnotationTrack(x[r]$query, name = "OSKA2016", id=LETTERS[seq_along(r)])
p2 <- grid::grid.grabExpr(plotTracks(list(ide2,gen2,trk2), featureAnnotation = "id"))


gen3 <- GenomeAxisTrack(name="OSKA2016")
ide3 <- IdeogramTrack(chromosome = seqlevelsInUse(x$query[r])[2], genome = "OSKA2016", bands = seqinfo2gieStain(OSKA2016))
trk3 <- AnnotationTrack(x[r]$query, name = "OSKA2016", id=LETTERS[seq_along(r)])
p3 <- grid::grid.grabExpr(plotTracks(list(ide3,gen3,trk3), featureAnnotation = "id"))

gridExtra::grid.arrange(p1, p2, p3, nrow=3)
```

## Tandem repeats

Repeated regions of genomes are notoriously difficult to assemble and align. Thus, information about an alignment stop's proximity to a tandem repeat is useful information in breakpoint classification. Given a user-defined tolerance, the function `tan_bp` will classify alignment stops as either far from, close to, or within tandem repeats (elements 1,2 and 3 of the produced list, respectively). The function requires the tandem repeat coverage of one of the genomes. By default, the function will expect the target genome tandem coverage. Setting `query_tf = TRUE` will switch the outcome to be query genome oriented.

```{r echo=T, message=F, warning=F}

tan_O <- rtracklayer::import.gff3(system.file("extdata/OSKA2016.tantanf4w100.gff3.gz",  package="GenomicBreaks"))
tan_O <- GRanges(tan_O, seqinfo = seqinfo(OSKA2016))
tan_gr_O <- tan_bp(gr_ob = gr_O_Oki, tan = tan_O, tol = 50)
tan_gr_O

tan_Oki <- rtracklayer::import.gff3(system.file("extdata/I69-5.tantanf4w100.gff3.gz",  package="GenomicBreaks"))
tan_Oki <- GRanges(tan_Oki, seqinfo = seqinfo(OKI2018_I69))
tan_gr_Oki <- tan_bp(gr_ob = gr_O_Oki, tan = tan_Oki, tol = 50, query_tf = TRUE)
tan_gr_Oki

```

We can use another script to plot the density of tandem repeats around alignment stops (and breakpoints). In the following plots, breakpoints are aligned at the centre of the plots. Intuitively, this function can be generalised to see the density of any binary coverage characteristic around breakpoints, given a GRanges object with per-base coverage of a given characteristic. Here we stick with tandem repeat info:

```{r echo=T, message=F, warning=F}
hm_tan_O <- gr_O_Oki %>%
  feature_coverage(tan_O, win = 1000, lab = "Osaka ~ Okinawa", direction = "left") %>%
  smoothHeatmap(output.size = c(2000,500), algorithm = "kernel") %T>%
  plotHeatmap

hm_red_tan_O <- reduced_gr_O_Oki %>%
  feature_coverage(tan_O, win = 1000, lab = "Osaka ~ Okinawa", direction = "left") %>%
  smoothHeatmap(output.size = c(2000,500), algorithm = "kernel") %T>%
  plotHeatmap

hm_tan_Oki <- gr_Oki_O %>%
  feature_coverage(tan_Oki, win = 1000, lab = "Osaka ~ Okinawa", direction = "left") %>%
  smoothHeatmap(output.size = c(2000,500), algorithm = "kernel") %T>%
  plotHeatmapList
```
## Coverage

Another characteristic of alignment stops that we can examine is the coverage depth over said alignment stops. By aligning raw reads to assembled genomes, we can obtain per-base coverage depth for target or query genome. Low coverage directly on and surrounding an alignment stop may suggest unreliability in it being a true breakpoint. The function `bp_coverage` returns a GRanges object of the bps, with associated averaged and point converage in the metadatacolumns. 

```{r echo=T, message=F, warning=F}

# cov_gr_O_Oki <- bp_coverage(gr_ob = q_Oki, cov_gr = Oki_cov_pb, win = 50)
# cov_gr_O_Oki

```


## Breakpoint classification - master script

The function `master_bp_analysis` brings together the information about tandem repeats and coverage, as well as coalescing the alignment. It can perform the analyses for both the target and the query genome, depending on the available input data. The output is split into two GRanges objects; one for the target genome and one for the query, with associated information in the metadata columns. 

```{r echo=T, message=F, warning=F}

# fin_gr_O_Oki <- master_bp_analysis(pair_gr = gr_O_Oki, co_tol = 500, ref_tan = tan_O, ref_tan_tol = 50, q_tan = tan_Oki,
#                                    q_tan_tol = 50, q_cov = Oki_cov_pb, q_cov_tol = 50)
# fin_gr_O_Oki

```


# Examples

## Nucleaic acid content heatmaps

We can use the GenomicBreaks function `bp_heatmap` to plot the desired nucleic acid content, with the alignment stops centred on the graph. Lets look at GC content before and after coalescing: 

```{r echo=T, message=F, warning=F}
hm_GC1 <- bp_heatmap(gr_O_Oki,         basep_range = 1000, pat = "GC", direction = "left")
hm_GC2 <- bp_heatmap(reduced_gr_O_Oki, basep_range = 1000, pat = "GC", direction = "left")

maxHeight <- 2000
sm_GC2_Height <- round(maxHeight * length(hm_GC2) / length(hm_GC1))

sm_GC1 <- smoothHeatmap(hm_GC1, output.size = c(maxHeight,     500), algorithm = "kernel")
sm_GC2 <- smoothHeatmap(hm_GC2, output.size = c(sm_GC2_Height, 500), algorithm = "kernel")

# Trying to plot the two heatmaps with different height according to their conntent,
# but without success...
plotHeatmapList(list(sm_GC1, sm_GC2), groups = 1:2)
```

The alignment stops are ordered in such a way that start (or left breaks) are centred on the top half of the plot, and end alignment stops are centred on the bottom. This is why we see different directionality in the plots. At the alignment stops, the GC content seems to be lower, but higher once within the aligned region. 

Now looking at TATA content:

```{r TATA}
hm_tata1 <- bp_heatmap(gr_O_Oki, basep_range = 1000, pat = "TATA", direction = "left")
sm_tata1 <- smoothHeatmap(hm_tata1, output.size = c(2000,500), algorithm = "kernel")

hm_tata2 <- bp_heatmap(reduced_gr_O_Oki, basep_range = 1000, pat = "TATA", direction = "left")
sm_tata2 <- smoothHeatmap(hm_tata2, output.size = c(2000,500), algorithm = "kernel")

plotHeatmapList(list(sm_tata1, sm_tata2))
plotHeatmapList(list(sm_GC2, sm_tata2))
```

The directionaility here is consistent with the GC content analysis. Furthermore; "TATA box sequence can act as a basal promoter element not only for RNA polymerase II (RNAP II) transcription, but also for transcription by RNA polymerase III (RNAP III)" - Wang Y, Jensen RC, Stumph WE. Role of TATA box sequence and orientation in determining RNA polymerase II/III transcription specificity. Nucleic Acids Res. 1996;24(15):3100–3106. doi:10.1093/nar/24.15.3100. However, the areas are not particularly enriched for TATA boxes, so it does not necessarily show that breakpoints are occuring directly after promotor regions. 

## Cluster analysis


```{r cluster_analysis, fig.height=20, fig.width=20}
# Accessory functions
clusterHeatmap <- function(hm, k = 2) kmeans(image(hm), k)

orderHeatmap <- function(hm, cl) {
  image(hm) <- image(hm)[order(cl$cluster),]
  hm
}

subsetHeatmap <- function(hm, bool) {
  image(hm) <- image(hm)[bool,]
  hm
}

# DAta
hm_GC   <- bp_heatmap(      gr_Oki_O, basep_range  = 1000, pat = "GC",     direction = "left")
hm_TATA <- bp_heatmap(      gr_Oki_O, basep_range  = 1000, pat = "TATA",   direction = "left")
hm_tan  <- feature_coverage(gr_Oki_O, tan_Oki, win = 1000, lab = "Tandem", direction = "left")

# Define 3 K-mean clusters
clusterHeatmap(hm_GC, 3) -> hm_cl_k4

# Order and smooth
shm_GC <- orderHeatmap(hm_GC, hm_cl_k4) %>%
  smoothHeatmap(output.size = c(2000,500), algorithm = "kernel")

shm_TATA <- orderHeatmap(hm_TATA, hm_cl_k4) %>%
  smoothHeatmap(output.size = c(2000,500), algorithm = "kernel")

shm_tan <- orderHeatmap(hm_tan, hm_cl_k4) %>%
  smoothHeatmap(output.size = c(2000,500), algorithm = "kernel")

# Plot the ordered data
plotHeatmapList(list(shm_GC, shm_TATA, shm_tan))
par(mfrow = c(1,1)) # plotHeatmapList messes with mrfrow...
plotHeatmapMeta(list(hm_GC, hm_TATA, hm_tan))

plotHeatmapMeta(list(subsetHeatmap(hm_GC, hm_cl_k4$cluster == 1),
                     subsetHeatmap(hm_GC, hm_cl_k4$cluster == 2),
                     subsetHeatmap(hm_GC, hm_cl_k4$cluster == 3)))

kmeanOrderedPlot <- function (hm, k=3, seed = 1) {
  set.seed(seed)
  
  cl <- kmeans(image(hm), k)
  mat <- image(hm)[order(cl$cluster),]
  
  kmhm = Heatmap(
    mat,
    coords=c(-500,500),
    label="kmeans",
    scale=range(mat))
  
  plotHeatmapList(kmhm,
                  cex.label=1.5,
                  partition=as.vector(table(cl$cluster)),
                  partition.legend=TRUE,
                  partition.lines=TRUE,
                  legend=TRUE,
                  legend.pos="r",
                  legend.width=0.3)
}

kmeanOrderedPlot(shm_GC)
```

## Evidence for breakpoint hotspots

The function `bp_pair_analysis` takes two pairwise alignments with the same target genome, and plots the alignment stops on to the centred alignment stops of the other. In the plot below, Osaka is there consistent target genome, and as such acts as a coordinate system to relate alignment stops across genomes. Lets produce two of these 3-way analyses; one between Osaka-Okinawa-Norway, and one between Osaka-Okinawa-Aomori

```{r echo=T, message=F, warning=F}

# hm1 <- bp_pair_analysis(gr_ref_q1 = gr_O_Oki, gr_ref_q2 = gr_O_N, win = 1000, lab = "Oki~Nor")
# plotHeatmapMeta(hm1)
# 
# hm2 <- bp_pair_analysis(gr_ref_q1 = gr_O_Oki, gr_ref_q2 = gr_O_A, win = 1000, lab = "Oki~Aom")
# plotHeatmapMeta(hm2)

```

The accumulation of alignment breaks of one pairwise alignment onto another suggests the existence of breakpoint hotspots; regions where breaks are far more likely to occur. Intuitively, this would lead to the presumption of synteny blocks, also. The pattern is consistent after coalescing, too;

```{r echo=T, message=F, warning=F}

# reduced_gr_O_N <- coalesce_contigs(gr_ob = gr_O_N, tol = 500)
# 
# hm3 <- bp_pair_analysis(gr_ref_q1 = reduced_gr_O_Oki, gr_ref_q2 = reduced_gr_O_N, win = 1000, lab = "Oki~Nor")
# plotHeatmapMeta(hm3)

```

## Tandem repeat coverage around alignment stops (breakpoints)

The function `feature_coverage` will plot the coverage of tandem repeats around
centred alignment stops. 

```{r echo=T, message=F, warning=F}

hm_tan1 <- feature_coverage(gr_ob = gr_O_Oki, feat = tan_O, win = 4000, lab = "Osk ~ Oki", direction = "left")
plotHeatmapMeta(hm_tan1)
 
hm_tan2 <- feature_coverage(gr_ob = reduced_gr_O_Oki, feat = tan_O, win = 4000, lab = "OSK~Oki (coalesced)", direction = "left")
plotHeatmapMeta(hm_tan2)

# should I also add comparison of proportions of tandem proximities before and after coalescion?
```

There appears to be less tandem repeats around alignment stops after coalescion,
inferring that perhaps that some are artefacts of difficult alignment near to
tandem repeats. 


## Gene feature coverage around alignment stops (breakpoints)

The function `feature_coverage` will plot the coverage of tandem repeats around
centred alignment stops. 

```{r genomic_features}
#current_GB <- gr_Oki_O # To ease recomputing with another object
current_GB <- reduced_gr_Oki_O
hmList_OKI <- list()

hmList_OKI$genes      <- feature_coverage(current_GB, genes(tx_OKI),                         win = 2000, lab = "Oki genes", direction = "left")
hmList_OKI$promoters  <- feature_coverage(current_GB, promoters(tx_OKI),                     win = 2000, lab = "Oki promoters", direction = "left")
hmList_OKI$exons      <- feature_coverage(current_GB, exonicParts(tx_OKI),                   win = 2000, lab = "Oki exons", direction = "left")
hmList_OKI$introns    <- feature_coverage(current_GB, intronicParts(tx_OKI),                 win = 2000, lab = "Oki introns", direction = "left")
hmList_OKI$cds        <- feature_coverage(current_GB, cds(tx_OKI),                           win = 2000, lab = "Oki cds", direction = "left")
hmList_OKI$utrs5      <- feature_coverage(current_GB, unlist(fiveUTRsByTranscript(tx_OKI)),  win = 2000, lab = "Oki 5′ UTRs", direction = "left")
hmList_OKI$utrs3      <- feature_coverage(current_GB, unlist(threeUTRsByTranscript(tx_OKI)), win = 2000, lab = "Oki 3′ UTRs", direction = "left")
hmList_OKI$pwm        <- feature_coverage(current_GB, pwmHits                              , win = 2000, lab = "PWM", direction = "left")

plotHeatmapMeta(hmList_OKI)
plotHeatmapMeta(hmList_OKI$genes)
plotHeatmapMeta(hmList_OKI[c("exons", "cds")])
plotHeatmapMeta(hmList_OKI[c("exons", "introns", "utrs5", "utrs3", "pwm")])
plotHeatmapMeta(hmList_OKI[c("introns", "utrs5", "utrs3", "pwm")])
plotHeatmapMeta(hmList_OKI[c("utrs5", "utrs3", "pwm")])
```

Aligned regions are enriched in exons and depleted in introns.  Is it because
exons are more alignable or is it because it is deleterous to break genes
in exons ?

## Gene feature coverage around PWM hits

Let's look at coverage around PWM hits of the AAGCsGCwwmkCGrCTTyn motif

```{r genomic_features_pwmHits}
current_GB <- pwmHits

hmList_PWM_OKI <- list()
hmList_PWM_OKI$genes     <- feature_coverage(current_GB, genes(tx_OKI),                         win = 2000, lab = "Oki genes", direction = "left")
hmList_PWM_OKI$promoters <- feature_coverage(current_GB, promoters(tx_OKI),                     win = 2000, lab = "Oki promoters", direction = "left")
hmList_PWM_OKI$exons     <- feature_coverage(current_GB, exonicParts(tx_OKI),                   win = 2000, lab = "Oki exons", direction = "left")
hmList_PWM_OKI$introns   <- feature_coverage(current_GB, intronicParts(tx_OKI),                 win = 2000, lab = "Oki introns", direction = "left")
hmList_PWM_OKI$cds       <- feature_coverage(current_GB, cds(tx_OKI),                           win = 2000, lab = "Oki cds", direction = "left")
hmList_PWM_OKI$utrs5     <- feature_coverage(current_GB, unlist(fiveUTRsByTranscript(tx_OKI)),  win = 2000, lab = "Oki 5′ UTRs", direction = "left")
hmList_PWM_OKI$utrs3     <- feature_coverage(current_GB, unlist(threeUTRsByTranscript(tx_OKI)), win = 2000, lab = "Oki 3′ UTRs", direction = "left")

plotHeatmapMeta(hmList_PWM_OKI)
plotHeatmapMeta(hmList_PWM_OKI[c("exons", "introns")])
plotHeatmapMeta(hmList_PWM_OKI[c("exons", "utrs5", "utrs3")])
plotHeatmapMeta(hmList_PWM_OKI[c("utrs5", "utrs3")])
```

They are enriched in introns...

```{r genomic_features3}

# Sandbox to make sanity checks.

a <- reduced_gr_Oki_O
b <- unlist(fiveUTRsByTranscript(tx_OKI))

hm_a <- feature_coverage(a, b, win = 2000, lab = "All ranges", direction = "left")
hm_b <- feature_coverage(subsetByOverlaps(a,  b), b, win = 2000, lab = "Subsetted ranges", direction = "left")

plotHeatmapMeta(list(hm_a))
plotHeatmapMeta(list(hm_b))
```


## Okinawa genome coverage

As previously discussed, low coverage over an alignment stop could lower the likelihood of it being considered as a breakpoint. We have per-base coverage depth information for the Okinawan genome (`Oki_cov_pb`). However, the coverage of this particular assembly is quite good. In fact, we can investigate the coverge over alignment stops from the information obtained using `master_bp_analysis`. 

```{r echo=T, message=F, warning=F}
# fin_Oki <- fin_gr_O_Oki[[2]]
# min_cov <- min(min(fin_Oki$left_cov_pb), min(fin_Oki$right_cov_pb)) # minimum coverage over an alignment stop
# min_cov
# length(fin_Oki[fin_Oki$left_cov_pb == min_cov]) + length(fin_Oki[fin_Oki$right_cov_pb == min_cov]) # how many of the minimum coverage is observed
# length(fin_Oki[fin_Oki$left_cov_pb <= 50]) + length(fin_Oki[fin_Oki$right_cov_pb <= 50]) # how many alignment stops have a coverage of less than or euqal to 50

```

We may choose to kick out the one alignment stop for which there is no coverage. However, only 15 out of 34572 alignment stops have a coverage of less than or equal to 50, meaning that it would be hard to exclude more than just a few alignment stops using coverage information for breakpoint analysis. 



