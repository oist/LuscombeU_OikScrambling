---
title: "Modifying coalescent cutoffs"
author: 
 - "Michael Mansfield"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEncoding{UTF-8}
  %\VignetteIndexEntry{Modifying coalescent cutoffs}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup}
knitr::opts_chunk$set(cache = TRUE, cache.lazy = FALSE)
knitr::opts_knit$set(verbose = TRUE)
```

# Introduction

In this vignette, we examine the behaviour of the coalescing algorithm under varying
thresholds of minimum alignment width. In doing so we attempt to fully describe the
contiguiuty of the pairwise alignments. 

The brunt of this vignette is the product of Charles' hard work. 

The core functions used here are maintained in our _GenomicBreaks_ R package,
which is fully documented at: <https://oist.github.io/GenomicBreaks>.

## Load packages

# Load R packages and data

```{r load_packages_and_data}
library('OikScrambling') |> suppressPackageStartupMessages()
library('ggplot2')
library('pheatmap')
library('viridis')
(genomes <- OikScrambling:::loadAllGenomes())
(load("BreakPoints.Rdata"))
```

### Phylogenetic cladogram


```{r setting_up_functions, fig.height=4, fig.width=6, dev="svg"}
requireNamespace("ade4")
treeLeaf <- function(name, length=NULL) {
  if(!is.null(length)) length <- paste0(':', length)
  paste0(name, length)
}

treeNode <- function(branch1, branch2, length = NULL) {
  if(!is.null(length)) length <- paste0(':', length)
  paste0('(', branch1, ',', branch2, ')', length)
}

addRoot <- function(branch)  paste0(branch, ";")

tree <-
  addRoot(
    treeNode(
      treeNode( length = 2,
        treeLeaf("Okinawa", 1),
        treeLeaf("Kume", 1)
      ),
      treeNode( length = 1,
        treeNode( length = 1,
          treeLeaf("Osaka", 1),
          treeLeaf("Aomori", 1)
        ),
        treeNode( length =1,
          treeLeaf("Norway", 1),
          treeLeaf("Barcelona", 1)
        )
      )
    )
  )


```

### Generating coalesced alignments

The function `coalest_contigs()` is the primary driver of our synteny analysis. It accepts an argument, `minwidth`, which controls the minimum width of segments to be considered for synteny analyses.

In the next session, I calculate these alignments at a large number of minimum width cutoffs. 

```{r coa_cutoffs_1, cache=TRUE, fig.width=15}
# use coalesce_contigs at different cutoffs
minwidthCutoffs = c(0, 25, 50, 100, 250, 500, 750, 1000, 1250, 1500, 2000, 2500, 5000, 7500, 10000, 12500, 25000, 50000, 100000)
cutoff_coas = lapply(minwidthCutoffs, function(MinWidth) BiocParallel::bplapply(gbs, function(gb) coalesce_contigs(gb=gb, minwidth=MinWidth)) |> SimpleList()) |> SimpleList()
names(cutoff_coas) <- sapply(minwidthCutoffs, function(s) paste('coa_minWidth_', as.character(s), sep=''))
# Append uncoalesced alignment
cutoff_coas$uncoalesced <- gbs
# Reorder to put uncoalesced first
cutoff_coas <- cutoff_coas[c(20,1:19)]
```

Let's make some tables to help understand what's going on, in terms of how much is being removed, how big the
syntenic regions are, and so on.

```{r coa_cutoffs_2}
# You can then make a simple table that tabulates the number of segments at a number of cutoffs.
cutoff_coas_tables = SimpleList()
# Count number of segments.
cutoff_coas_tables$NumSegments <- as.data.frame(do.call(rbind, lapply(cutoff_coas, function(cutoff) sapply(cutoff, function(gb) as.integer(length(gb)) ))))
# Show how many total bases are left after coalescing.
# I divide by 1,000,000 to convert it to Mbp here.
cutoff_coas_tables$TotalAligned <- as.data.frame(do.call(rbind, lapply(cutoff_coas, function(cutoff) {
  cut_gb <- sapply(cutoff, function(gb) {
    total <- sum(width(gb))/1000000
    total
  })
  cut_gb
})))
# Show largest segment. Combine it with the query name to see which chromosome segment is biggest.
cutoff_coas_tables$LargestSegment <- as.data.frame(do.call(rbind, lapply(cutoff_coas, function(cutoff) {
  cut_gb <- sapply(names(cutoff), function(sp_pair) {
    gb <- cutoff[[sp_pair]]
    biggest_segment <- max(width(gb))/1000000
    if(is.infinite(biggest_segment)){
      biggest_segment = NA
    } 
    biggest_segment
  })
  cut_gb
})))
# Get name of largest segment, which can change based on the cutoffs.
cutoff_coas_tables$LargestSegmentName <- as.data.frame(do.call(rbind, lapply(cutoff_coas, function(cutoff) {
  cut_gb <- sapply(names(cutoff), function(sp_pair) {
    gb <- cutoff[[sp_pair]]
    biggest_segment <- max(width(gb))
    if(is.infinite(biggest_segment)){
      biggest_segment_name = NA
    } else {
      biggest_segment_name <- as.character(seqnames(gb)[which.max(width(gb))])
    }
    biggest_segment_name
  })
  cut_gb
})))


# Write a little function to relate a pair of species (A_B) to their genome size.
# named list of genome sizes (name=species, content=genome size).
genome_sizes=list(Aom=sum(lengths(genomes$Aom)), Bar=sum(lengths(genomes$Bar)),
                  Oki=sum(lengths(genomes$Oki)), Osa=sum(lengths(genomes$Osa)),
                  Kum=sum(lengths(genomes$Kum)), Nor=sum(lengths(genomes$Nor)),
                  Ply=175288331, Ros=275796282, Sav=177003750, Rob=115226814
                  )
match_pair_with_sizes = function(pair, genome_sizes) {
  spp = unlist(strsplit(pair, "_"))
  g1 = spp[1]
  g2 = spp[2]
  gs1 = genome_sizes[[g1]]
  gs2 = genome_sizes[[g2]]
  result = list()
  result[[g1]] = gs1
  result[[g2]] = gs2
  return(result)
}
# Use the genome sizes to calculate how much of the genomes are covered.
# This coverage value is just the total alignment length divided by the mean of the two genome sizes.
cutoff_coas_tables$PercentGenomeCovered <- as.data.frame(do.call(rbind, lapply(cutoff_coas, function(cutoff) {
  cut_gb <- sapply(names(cutoff), function(pair) {
    gb <- cutoff[[pair]]
    pair_sizes <- match_pair_with_sizes(pair, genome_sizes=genome_sizes)
    mean_genome_size <- mean(unlist(pair_sizes))
    covered <- (sum(lengths(gb))/mean_genome_size)*100
    covered
  })
  cut_gb
})))
# Show how many bases of the original alignment are covered.
uncoalescedAliTot <- cutoff_coas_tables$TotalAligned[1,]
cutoff_coas_tables$PercentOriginalAlignment <- do.call(rbind, apply(cutoff_coas_tables$TotalAligned, 1, function(x) x/uncoalescedAliTot)) *100

```

### Plotting features at different cutoffs
##### Number of segments
```{r coa_cutoff_numSegs, fig.height=4, fig.width=6, dev="svg"}
# Number of segments
pheatmap(cutoff_coas_tables$NumSegments, col=magma(100), cluster_cols=F, cluster_row=F, gaps_col=15, angle_col = 90, main='Number of alignments (uncoalesced) or syntenic regions (coalesced)', display_numbers=T, number_color='#d9d9d9', number_format="%.0f")
```
##### Total aligned
```{r coa_cutoff_totAli, fig.height=4, fig.width=6, dev="svg"}
pheatmap(cutoff_coas_tables$TotalAligned, col=magma(100), cluster_cols=F, gaps_col=15, cluster_row=F, angle_col = 90, main='Sum of all alignment widths (Mbp)', display_numbers=T, number_color='#d9d9d9')
```

##### Largest segment
```{r coa_cutoff_totAli, fig.height=4, fig.width=6, dev="svg"}
pheatmap(cutoff_coas_tables$LargestSegment, col=magma(100), cluster_cols=F, gaps_col=15, cluster_row=F, angle_col = 90, main='Size of largest segment (Mbp)', display_numbers=T, number_color='#d9d9d9')
```

##### Percent of genome covered by alignments
Note the denominator here is the mean of the query and target genome sizes.
```{r coa_cutoff_totAli, fig.height=4, fig.width=6, dev="svg"}
pheatmap(cutoff_coas_tables$PercentGenomeCovered, col=magma(100), cluster_cols=F, gaps_col=15, cluster_row=F, angle_col = 90, main='Percentage of query/target genomes covered (%)', display_numbers=T, number_color='#d9d9d9')
```

##### Percent of total aligned positions represented in alignments
Note the denominator here is the mean of the query and target genome sizes.
```{r coa_cutoff_totAli, fig.height=4, fig.width=6, dev="svg"}
pheatmap(cutoff_coas_tables$PercentOriginalAlignment, col=magma(100), cluster_cols=F, gaps_col=15, cluster_row=F, angle_col = 90, main='Percentage of query/target genomes covered (%)', display_numbers=T, number_color='#d9d9d9')
```

# Session information

```{r sessionInfo}
sessionInfo()
```


