---
title: "Introduction to the OikScrambling package"
author: 
 - "Charlotte West"
 - "Charles Plessy"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEncoding{UTF-8}
  %\VignetteIndexEntry{Introduction to the OikScrambling package}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup}
knitr::opts_chunk$set(cache = TRUE, cache.lazy = FALSE)
knitr::opts_knit$set(verbose = TRUE)
```

# Introduction

This package contains a collection of vignettes to perform the analysis of
pairwise genome alignments between _Oikopleura_ genomes.

The core functions used here are maintained in our _GenomicBreaks_ R package,
which is fully documented at: <https://oist.github.io/GenomicBreaks>.

## Load pacakges

### Core packages that provide functions we use a lot.

```{r loadlib, echo=T, results='hide'}
suppressPackageStartupMessages({
  library('GenomicBreaks')
  library('BSgenome')
  library('GenomicFeatures')
  library('ggplot2')
  library("BiocParallel")
})
requireNamespace("rGADEM")
requireNamespace("ggseqlogo")
```

### BSgenome packages

We need the sequences of the studied genomes.  They are provided in a _drat_
repository: <https://oist.github.io/plessy_oikgenomes_drat/>.

Example command to install one _Oikopleura_ BSgenome package if you do not yet
have it:

```
install.packages("BSgenome.Odioica.local.OKI2018.I69", repos="https://oist.github.io/plessy_oikgenomes_drat/")
```

```{r load_BSgenome_packages}
# These will need to be installed by the user
library("BSgenome.Odioica.local.OKI2018.I69")
library("BSgenome.Odioica.local.OSKA2016v1.9")
library("BSgenome.Odioica.local.Bar2.p4")
library("BSgenome.Odioica.local.KUM.M3")
library("BSgenome.Odioica.local.AOM.5")
library("BSgenome.Odioica.local.Odioica.reference.v3.0")
```

For convenience (such as easy looping, and tab-completion to show the available
objects), we create a `genomes` list containing all the genomes.

```{r genomes_object}
genomes <- SimpleList(
  # Chromosome assemblies
  Oki = OKI2018_I69, Osa = OSKA2016v1.9, Bar = Bar2_p4,
  # Less contiguous assemblies
  Kum = KUM_M3, Aom = AOM_5, Nor = OdB3)

## Genome lengths
(genome.lengths <- sapply(genomes, \(g) sum(seqlengths(seqinfo(g)))))

## Genome average AT content (multicore computation)
(genomes.AT <- BiocParallel::bplapply(genomes, \(g)
  weighted.mean(letterFrequency(getSeq(g), "AT", as.prob = TRUE), seqlengths(g))) |> unlist())
```

## Load data

### Genome annotations.

The annotations from `/bucket/LuscombeU/common/Breakpoints/Annotations` are
distributed in the same drat repository as the alignment data.

```
install.packages("BreakpointsData", repos="https://oist.github.io/plessy_oikgenomes_drat/")
```

```{r load_annotations, warning=FALSE}
annots <- SimpleList()

gff2txdb <- function(file, genome) {
  file <- system.file(paste0("extdata/Annotations/", file), package = "BreakpointsData")
  tx <- rtracklayer::import.gff(file)
  tx <- tx[seqnames(tx) %in% seqnames(genome)]
  tx <- GRanges(tx, seqinfo = seqinfo(genome))
  tx <- GenomicFeatures::makeTxDbFromGRanges(tx)
}

gff2txdb_Norway <- function(file, genome) {
  file <- system.file(paste0("extdata/Annotations/", file), package = "BreakpointsData")
  tx <- rtracklayer::import.gff(file)
  tx <- tx[!is.na(tx$mRNA)]
  # Remove "scaffoldA" objects in the OdB3 annotation
  tx <- tx[seqnames(tx) %in% seqnames(genome)]
  tx$ID <- tx$mRNA
  tx <- GRanges(tx, seqinfo = seqinfo(genome))
  tx <- GenomicFeatures::makeTxDbFromGRanges(tx)
}

annots$Oki <- gff2txdb("OKI2018_I69.v2/OKI2018_I69.v2.gm.gff.gz",  OKI2018_I69)
annots$Osa <- gff2txdb("OSKA2016v1.9/OSKA2016v1.9.gm.gff.gz",      OSKA2016v1.9)
annots$Bar <- gff2txdb("Bar2_p4.Flye/Bar2_p4.Flye.gm.gff.gz",      Bar2_p4)
annots$Kum <- gff2txdb("KUM-M3-7f/KUM-M3-7f.gm.gff.gz",            KUM_M3)
annots$Aom <- gff2txdb("AOM-5-5f/AOM-5-5f.gm.gff.gz",              AOM_5)
annots$Nor <- gff2txdb_Norway("OdB3/Oikopleura_annot_v1.0.gff.gz", OdB3)
```

### GenomicBreaks object

The core data is a list of `GenomicBreaks::GBreaks()` objects that is built
by a separate vignette (`vignette("Load genomic break data"), package="OikSyntenies"`).

The _query_ genome is the one that was provided as a FASTA file and aligned to
the _target_ genome (the one that was indexed by the aligner).  The _target_
genome is the main part of the object, and the _query_ genome information is
contained in the metadata columns (`mcols`) of the structure.

```{r GBreaks_object}
load("BreakPoints.Rdata")
gbs$Oki_Osa
gbs$Oki_Osa$query
```

In the example displayed above, the object contains the pairwise alignment
between genomes of two dioceous _Oikopleura_ individuals; one from the Osaka
assembly `OSKA2016` (_target_) and one from the Okinawa assembly `OKI2018_I69`
(_query_).

### Long and short arms

The long and short arms are annotated in the `GBreak` objects that are built
by the vignette (`vignette("Load genomic break data")`), using the function
`GenomicBreaks::flagLongShort()`.  A copy of the arms annotations is provided
in the `longShort` list.

```{r long_and_short_arms}
longShort
longShort$Oki
```

## Breakpoints and alignment stops

We define an **alignment stop** to be a position defined in either the
_target_ or _query_ genome, where an alignment begins or ends, and a
**genomic breakpoint** (or simply breakpoint) to be a genomic structural
mutation, arising from breakage and repair of the chromosome.  Such structural
events include insertion, deletion, inversion and translocation, and often arise
during recombination. 

# Measures of distance

## Synteny index

Ad-hoc index measuring to what extent a scaffold of the _target_ genome is
mostly aligned to a single scaffold in the _query_ genome.   See
`?GenomicBreaks::synteny_index` for details.  One limitation to the use of this
index is that it requires that at least the _query_ genome is a complete
chromosome assembly.

```{r}
sapply(gbs, synteny_index)
sapply(gbs, \(g) swap(g) |> synteny_index())
```

## Correlation

Ad-hoc index measuring the correlation of the coordinates of the syntenic
alignments in scaffolds of a _target_ genome and their best match in the
_query_ genome.  See `?GenomicBreaks::correlation_index` for details.  It is
intended to be more robust to the presence of uncollapsed haplotypes in the
_query_ genome but probably needs further testing.

```{r}
sapply(gbs, correlation_index)
sapply(gbs, \(g) swap(g) |> correlation_index())
```

## Gene Order Conservation

See `?GOC` for details.

```{r goc}
sapply(gbs, GOC)
sapply(gbs, \(g) swap(g) |> GOC())
```

# Phylogenetic cladogram

We assume that the _North Pacific_ and the _Atlantic_ species are more related
to each other than to the _Okinawan_ species.

```{r phylogenetic_tree, fig.height=4, fig.width=6, dev="svg"}
requireNamespace("ade4")
treeLeaf <- function(name, length=NULL) {
  if(!is.null(length)) length <- paste0(':', length)
  paste0(name, length)
}

treeNode <- function(branch1, branch2, length = NULL) {
  if(!is.null(length)) length <- paste0(':', length)
  paste0('(', branch1, ',', branch2, ')', length)
}

addRoot <- function(branch)  paste0(branch, ";")

tree <-
  addRoot(
    treeNode(
      treeNode( length = 2,
        treeLeaf("Okinawa", 1),
        treeLeaf("Kume", 1)
      ),
      treeNode( length = 1,
        treeNode( length = 1,
          treeLeaf("Osaka", 1),
          treeLeaf("Aomori", 1)
        ),
        treeNode( length =1,
          treeLeaf("Norway", 1),
          treeLeaf("Barcelona", 1)
        )
      )
    )
  )

plot(ade4::newick2phylog(tree))
```

# Coalescing alignments

Large syntenic regions can often appear cluttered with alignment breaks.  They
are either an artefact (for instance in case of incomplete purge of haplotypes)
or true breakpoint.  Even in that case, it may be needed to coalese them in
order to facilitate other computations such as the detection of inversions.

The algorithm in  `GenomicBreaks::coalesce_contigs()` is used to produce a new
`GBreaks` object with fewer alignment breaks by coalescing alignments separated
by short (user specified) distances.

The computation is done in `vignette("Load genomic break data")`

The resulting GRanges object has far fewer alignments and therefore far fewer
alignment stops. The algorithm is an initial step in alignment stop filtering,
with the goal of a reduced number of alignment stops that have a high
probability of being breakpoints.

```{r coalescing algorithm}
sapply(gbs, length)
sapply(coa, length)
```

# Width summary plots

The distribution of alignment widths takes a bimodal appearance after
collapsing.  Is the small peak made of artefacts ?  We will see shortly that the
answer is _no_.

```{r width_after_coalescing}
width2df <- function(where, what, gbl) {
  gb <- gbl[[where]]
  if (length(gb) == 0) return (NULL)
  data.frame(where = where, what = what, width = width(gb))
}

df <- rbind(
  # do.call allows a list to replace "..." in a function call
  do.call(rbind, lapply(names(gbs), width2df, "aligned", gbs)),
  do.call(rbind, lapply(names(coa), width2df, "collapsed", coa))
)

gg_freq_poly <- function(DF) {
    ggplot(DF |> as("data.frame")) +
    aes(width) +
    geom_freqpoly() +
    scale_x_log10()
}

gg_freq_poly(df) +
  aes(col = what) +
  geom_freqpoly() +
  scale_x_log10() +
  facet_wrap(~where, scales = "free_y") +
  ggtitle("Distribution of alignment width before and after collapsing")
```

First, the distribution of widths is not the same on long and short arms.
For this reason, it would be unwise to filter by width on some operations such
as coalescing.

```{r pre_compute_widths_object}
widths <- SimpleList()
makeWidthsDF <- function (objList) {
  lapply(names(objList), \(name) {
    DF <- mcols(objList[[name]])
    DF$name  <- name
    DF$width <- width(objList[[name]])
    DF$chr   <- seqnames(objList[[name]]) |>  sub(pat = "Chr", rep = "chr")
    DF$query <- DF$score <- NULL
    DF
  }) |> do.call(what=rbind)
}

widths$gbs  <- makeWidthsDF(gbs)
widths$coa  <- makeWidthsDF(coa)
widths$coa2 <- makeWidthsDF(coa2)
```

## Aligned regions

```{r widths_gbs}
gg_freq_poly(widths$gbs) +
  aes(col=Arm) +
  facet_wrap(~chr, scales = "free_y") +
  ggtitle("Distribution of alignment widths before collapsing, split by arm.")

gg_freq_poly(widths$gbs |> subset(chr == "chr1")) +
  aes(col=Arm) +
  facet_wrap(~name, scales = "free_y", ncol=5) +
  ggtitle("Distribution of alignment widths on chr1 before collapsing, split by genome pair")
```

## Unaligned regions

```{r widths_unaligned}
unal <- sapply(gbs, cleanGaps) |> SimpleList()
unal[ 1:5]  <- sapply(unal[ 1:5],  flagLongShort, longShort$Oki)
unal[ 6:10] <- sapply(unal[ 6:10], flagLongShort, longShort$Osa)
unal[11:15] <- sapply(unal[11:15], flagLongShort, longShort$Bar)
widths$unal  <- makeWidthsDF(unal)

gg_freq_poly(widths$unal) +
  aes(col=Arm) +
  facet_wrap(~chr, scales = "free_y") +
  ggtitle("Distribution of unaligned regions width before collapsing, split by arm.")

gg_freq_poly(widths$unal |> subset(chr == "chr1")) +
  aes(col=Arm) +
  facet_wrap(~name, scales = "free_y", ncol=5) +
  ggtitle("Distribution of unaligned regions width on chr1 before collapsing, split by genome pair")
```

## Coalesced regions

After coalescing, width distribution becomes clearly bimodal, when faceted by
chromosome and arm type.  There is a small peak under 500 bp, found on all arms
except YSR.  The second peak shows two different distributions for long and
short arms.

```{r width_of_coalesced_regions}
gg_freq_poly(widths$coa) +
  aes(col=Arm) +
  facet_wrap(~chr, scales = "free_y") +
  ggtitle("Distribution of alignment widths after collapsing, split by arm.")

gg_freq_poly(widths$coa |> subset(chr == "chr1")) +
  aes(col=Arm) +
  facet_wrap(~name, scales = "free_y", ncol=5) +
  ggtitle("Distribution of alignment widths on chr1 after collapsing, split by genome pair") +
  geom_vline(xintercept = 500)
```

Therefore, if the first peak represents events that we do not want to consider
breaking synteny (either alignment artefacts or insertion/transpositions of
short mobile elements), we can re-coalesce once after removing the shortest
intervals.

The computation is done in `vignette("Load genomic break data")`

```{r double_coalescing_algorithm}
sapply(gbs, length)
sapply(coa, length)
sapply(coa2, length)
```

## Double-coalesced regions

```{r re_coalesce}
gg_freq_poly(widths$coa2) +
  aes(col=Arm) +
  facet_wrap(~chr, scales = "free_y") +
  ggtitle("Distribution of alignment widths after double-collapsing, split by arm.")

gg_freq_poly(widths$coa2 |> subset(chr == "chr1")) +
  aes(col=Arm) +
  facet_wrap(~name, scales = "free_y", ncol=5) +
  ggtitle("Distribution of alignment widths on chr1 after double-collapsing, split by genome pair") 
```

# Analysis of the interval regions

Interval regions interrupt alignments or colinearity.  What do they contain ?

## Unaligned regions

```{r unaligned_regions}
reps <- rtracklayer::import(system.file("extdata/Annotations/OKI2018_I69.v2/OKI2018_I69.repeats.gff", package = "BreakpointsData"))
Oki_pairs <- c("Oki_Osa", "Oki_Bar", "Oki_Kum", "Oki_Aom", "Oki_Nor")
unal <- sapply(gbs[Oki_pairs], cleanGaps) |> SimpleList()

(reps_gbs <- tibble::tibble(
  pairname   = Oki_pairs,
  total      = sapply(unal[Oki_pairs], length),
  match_unal = sapply(unal[Oki_pairs], \(gb) length(subsetByOverlaps(gb, reps))),
  match_al   = sapply( gbs[Oki_pairs], \(gb) length(subsetByOverlaps(gb, reps))),
  aligned   = match_al   / total * 100,
  unaligned = match_unal / total * 100
))

ggplot(reps_gbs |> tidyr::pivot_longer(c("aligned", "unaligned"))) +
  aes(name, value) +
  ggtitle("Matches to repeats") +
  ylab("Percent matching repeats") +
  xlab("Type of region") +
  geom_boxplot() +
  geom_point(aes(col = pairname))
```

## Colinearity interruptors (unmapped regions ?)

```{r unaligned_regions}
unal_c <- sapply(coa[Oki_pairs], cleanGaps) |> SimpleList()

(reps_coa <- tibble::tibble(
  pairname   = Oki_pairs,
  total      = sapply(unal_c[Oki_pairs], length),
  match_unal = sapply(unal_c[Oki_pairs], \(gb) length(subsetByOverlaps(gb, reps))),
  match_al   = sapply(   coa[Oki_pairs], \(gb) length(subsetByOverlaps(gb, reps))),
  aligned   = match_al   / total * 100,
  unaligned = match_unal / total * 100
))

ggplot(reps_coa |> tidyr::pivot_longer(c("aligned", "unaligned"))) +
  aes(name, value) +
  ggtitle("Matches to repeats") +
  ylab("Percent matching repeats") +
  xlab("Type of region") +
  geom_boxplot() +
  geom_point(aes(col = pairname))
```

# Pairwise chromosome plots

## Oki – Bar

```{r parallel_chr_plots_Oki_Bar}
plotApairOfChrs(coa$Oki_Bar, "chr1", main = "Oki – Bar")
```

## Osa – Bar

```{r parallel_chr_plots_Osa_Bar}
plotApairOfChrs(coa$Osa_Bar, "Chr1", main = "Osa – Bar")
```

## Oki – Kum

The plot is not complete because the Kume assembly is not chromosome-scale.

```{r parallel_chr_plots_Oki_Kum}
plotApairOfChrs(coa$Oki_Kum, "chr1", main = "Oki – Kum")
```

Same after double-coalescing.

```{r parallel_chr_plots_Oki_Kum_coa2}
plotApairOfChrs(coa2$Oki_Kum, "chr1", main = "Oki – Kum")
```

## More in the _parallel plots_ vignette!

In the _parallel plots_ vignette
(`vignette("ParallelPlots", package = "OikScrambling")`), we build a more
more comprehensive collection of plots and explore arrangements for a figure
panel in paper.


# Structural variants

## Trivial inversions

### Documentation

Details can be found in `vignette("Introduction to GenomicBreaks", package = "GenomicBreaks")`,
in `vignette("Structural Variants", package = "GenomicBreaks")`,
and `?GenomicBreaks::flagInversions`

See also the [vignette](https://bioconductor.org/packages/release/bioc/vignettes/Gviz/inst/doc/Gviz.html)
of Gviz.

### Number of trivial inversions

More inversions are found after coalescing colinear blocks because of situations
where `+ - +` was `+ - - +` before collapsing. 

```{r detect_trivial_invertions}
sapply(gbs, function(gb) sum(flagInversions(gb)$inv))
sapply(coa, function(gb) sum(flagInversions(gb)$inv))
sapply(coa2, function(gb) sum(flagInversions(gb)$inv))
```

### Width of inverted regions

Many inversions are shorter than 1 kbp.

```{r width_of_inversions}
invs <- sapply(coa, function(gb) filterInversions(flagInversions(gb))) |> SimpleList()
sapply(invs, length)

# Sanity check that we detect inversions on both strands
sapply(invs, \(x) {summary(decode(strand(x)))})

widths$invs <- makeWidthsDF(invs)

gg_freq_poly(widths$invs) +
  aes(col=Arm) +
  facet_wrap(~chr, scales = "free_y") +
  ggtitle("Distribution of alignment widths for inverted regions, split by arm.") +
  geom_vline(xintercept = 1000)
```

### Width of gaps next to the inverted regions

```{r width_of_inversions}
inv.lgaps <- sapply(coa, leftInversionGaps) |> SimpleList()
inv.lgaps[ 1:5]  <- sapply(inv.lgaps[ 1:5],  flagLongShort, longShort$Oki)
inv.lgaps[ 6:10] <- sapply(inv.lgaps[ 6:10], flagLongShort, longShort$Osa)
inv.lgaps[11:15] <- sapply(inv.lgaps[11:15], flagLongShort, longShort$Bar)
sapply(inv.lgaps, length)

widths$invs.lgaps <- makeWidthsDF(inv.lgaps)

gg_freq_poly(widths$invs.lgaps) +
  aes(col=Arm) +
  facet_wrap(~chr, scales = "free_y") +
  ggtitle("Distribution widths of left gaps next to inverted regions, split by arm.") +
  geom_vline(xintercept = 1000)
```

### Motif search

Enrichment for motifs is being searched in
`vignette("Motif finding and analysis", package = "OikScrambling")`.

```{r load_PWMs}
gadems.invLeftGap <- readRDS("gadems.invLeftGap.Rda")
```

### Representation of some inversions

```{r}
x <- coa$Oki_Osa |> flagInversions() |> dist2next(ignore.strand = TRUE)

pmpcoord <- showInversions(x)

seqinfo2gieStain <- function(si) {
  data.frame(
    chrom      = seqlevels(si),
    chromStart = 0,
    chromEnd   = seqlengths(si),
    name       = seqlevels(si),
    gieStain   = "gneg"
  )
}

#r <- 63:70
r <- 94:98
#r <- 316:319
options(ucscChromosomeNames=FALSE)
gen <- GenomeAxisTrack(name="OKI2018_I69")
ide <- IdeogramTrack(chromosome = seqlevelsInUse(x[r]), genome = "OKI2018_I69", bands = seqinfo2gieStain(OKI2018_I69))
trk <- AnnotationTrack(x[r], name = "OKI2018_I69", id=LETTERS[seq_along(r)])
p1 <- grid::grid.grabExpr(plotTracks(list(ide, gen, trk), featureAnnotation = "id"))

gen2 <- GenomeAxisTrack(name="OSKA2016v1.9")
ide2 <- IdeogramTrack(chromosome = seqlevelsInUse(x$query[r]), genome = "OSKA2016v1.9", bands = seqinfo2gieStain(OSKA2016v1.9))
trk2 <- AnnotationTrack(x[r]$query, name = "OSKA2016v1.9", id=LETTERS[seq_along(r)])
p2 <- grid::grid.grabExpr(plotTracks(list(ide2,gen2,trk2), featureAnnotation = "id"))

gridExtra::grid.arrange(p1, p2, nrow=2)
```

## Trivial insersions

### Representation

The in<b>s</b>ersion below:

```
┌───────────────┬───────────────┬───────────────┐
│ XSR:101-200:+ │ XSR:201-300:+ │ XSR:301-400:+ │  (OKI2018_I69)
└───────────────┴───────────────┴───────────────┘
┌───────────────┬───────────────┬───────────────┐
│  S1:101-200:+ │  S2:801-900:+ │  S1:201-300:+ │  (OSKA2016)
└───────────────┴───────────────┴───────────────┘
```

Is represented as:

```{r ideal_insertions}
example("flagInsersions")

library("Gviz")
options(ucscChromosomeNames=FALSE)
gen <- GenomeAxisTrack(name = "genome")
trk <- AnnotationTrack(ins, name = "ins")
plotTracks(list(gen, trk))
```

*Without an outgroup it is not possible to know in which genome the break happened.*

### Detection

```{r detect_trivial_insertions}
sapply(gbs, function(gb)  sum(flagInsersions(gb)$ins))
sapply(coa, function(gb)  sum(flagInsersions(gb)$ins))
sapply(coa2, function(gb) sum(flagInsersions(gb)$ins))


# #r <- 63:70
# r <- 23:30
# #r <- 316:319
# options(ucscChromosomeNames=FALSE)
# gen <- GenomeAxisTrack(name="OKI2018_I69")
# ide <- IdeogramTrack(chromosome = seqlevelsInUse(x[r]), genome = "OKI2018_I69", bands = seqinfo2gieStain(OKI2018_I69))
# trk <- AnnotationTrack(x[r], name = "OKI2018_I69", id=LETTERS[seq_along(r)])
# p1 <- grid::grid.grabExpr(plotTracks(list(ide, gen, trk), featureAnnotation = "id"))
# 
# gen2 <- GenomeAxisTrack(name="OSKA2016")
# ide2 <- IdeogramTrack(chromosome = seqlevelsInUse(x$query[r])[1], genome = "OSKA2016", bands = seqinfo2gieStain(OSKA2016))
# trk2 <- AnnotationTrack(x[r]$query, name = "OSKA2016", id=LETTERS[seq_along(r)])
# p2 <- grid::grid.grabExpr(plotTracks(list(ide2,gen2,trk2), featureAnnotation = "id"))
# 
# 
# gen3 <- GenomeAxisTrack(name="OSKA2016")
# ide3 <- IdeogramTrack(chromosome = seqlevelsInUse(x$query[r])[2], genome = "OSKA2016", bands = seqinfo2gieStain(OSKA2016))
# trk3 <- AnnotationTrack(x[r]$query, name = "OSKA2016", id=LETTERS[seq_along(r)])
# p3 <- grid::grid.grabExpr(plotTracks(list(ide3,gen3,trk3), featureAnnotation = "id"))
# 
# gridExtra::grid.arrange(p1, p2, p3, nrow=3)
```

## Tandem repeats

Repeated regions of genomes are notoriously difficult to assemble and align. Thus, information about an alignment stop's proximity to a tandem repeat is useful information in breakpoint classification. Given a user-defined tolerance, the function `tan_bp` will classify alignment stops as either far from, close to, or within tandem repeats (elements 1,2 and 3 of the produced list, respectively). The function requires the tandem repeat coverage of one of the genomes. By default, the function will expect the target genome tandem coverage. Setting `query_tf = TRUE` will switch the outcome to be query genome oriented.

```{r echo=T, message=F, warning=F}
# 
# tan_O <- rtracklayer::import.gff3(system.file("extdata/OSKA2016.tantanf4w100.gff3.gz",  package="GenomicBreaks"))
# tan_O <- GRanges(tan_O, seqinfo = seqinfo(OSKA2016))
# tan_gr_O <- tan_bp(gr_ob = gr_O_Oki, tan = tan_O, tol = 50)
# tan_gr_O
# 
# tan_Oki <- rtracklayer::import.gff3(system.file("extdata/I69-5.tantanf4w100.gff3.gz",  package="GenomicBreaks"))
# tan_Oki <- GRanges(tan_Oki, seqinfo = seqinfo(OKI2018_I69))
# tan_gr_Oki <- tan_bp(gr_ob = gr_O_Oki, tan = tan_Oki, tol = 50, query_tf = TRUE)
# tan_gr_Oki

```

We can use another script to plot the density of tandem repeats around alignment stops (and breakpoints). In the following plots, breakpoints are aligned at the centre of the plots. Intuitively, this function can be generalised to see the density of any binary coverage characteristic around breakpoints, given a GRanges object with per-base coverage of a given characteristic. Here we stick with tandem repeat info:

```{r echo=T, message=F, warning=F, cache=FALSE}
# hm_tan_O <- gr_O_Oki %>%
#   feature_coverage(tan_O, win = 1000, lab = "Osaka ~ Okinawa", direction = "left") %>%
#   smoothHeatmap(output.size = c(2000,500), algorithm = "kernel") %T>%
#   plotHeatmap
# 
# hm_red_tan_O <- reduced_gr_O_Oki %>%
#   feature_coverage(tan_O, win = 1000, lab = "Osaka ~ Okinawa", direction = "left") %>%
#   smoothHeatmap(output.size = c(2000,500), algorithm = "kernel") %T>%
#   plotHeatmap
# 
# hm_tan_Oki <- gr_Oki_O %>%
#   feature_coverage(tan_Oki, win = 1000, lab = "Osaka ~ Okinawa", direction = "left") %>%
#   smoothHeatmap(output.size = c(2000,500), algorithm = "kernel") %T>%
#   plotHeatmapList
```

# Coverage

Another characteristic of alignment stops that we can examine is the coverage depth over said alignment stops. By aligning raw reads to assembled genomes, we can obtain per-base coverage depth for target or query genome. Low coverage directly on and surrounding an alignment stop may suggest unreliability in it being a true breakpoint. The function `bp_coverage` returns a GRanges object of the bps, with associated averaged and point converage in the metadatacolumns. 

```{r echo=T, message=F, warning=F}

# cov_gr_O_Oki <- bp_coverage(gr_ob = q_Oki, cov_gr = Oki_cov_pb, win = 50)
# cov_gr_O_Oki

```


# Breakpoint classification - master script

The function `master_bp_analysis` brings together the information about tandem repeats and coverage, as well as coalescing the alignment. It can perform the analyses for both the target and the query genome, depending on the available input data. The output is split into two GRanges objects; one for the target genome and one for the query, with associated information in the metadata columns. 

```{r echo=T, message=F, warning=F}

# fin_gr_O_Oki <- master_bp_analysis(pair_gr = gr_O_Oki, co_tol = 500, ref_tan = tan_O, ref_tan_tol = 50, q_tan = tan_Oki,
#                                    q_tan_tol = 50, q_cov = Oki_cov_pb, q_cov_tol = 50)
# fin_gr_O_Oki

```


# Nucleic acid content heatmaps

The `GenomicBreaks::bp_heatmap()` function plots nucleic acid content in windows
centered on alignment stops.  Lets look at `GC` content before and after
coalescing: 

```{r echo=T, fig.height=6, fig.width=12, message=FALSE, warning=FALSE}
library(heatmaps)
#hm_GC1 <- sapply(gbs,  bp_heatmap, basep_range = 1000, pat = "GC", direction = "left") |> SimpleList()
hm_GC2 <- sapply(coa,  bp_heatmap, basep_range = 1000, pat = "GC", direction = "left") |> SimpleList()
#hm_GC3 <- sapply(coa2, bp_heatmap, basep_range = 1000, pat = "GC", direction = "left") |> SimpleList()

maxHeight <- 2000
#sm_GC1 <- sapply(hm_GC1, smoothHeatmap, output.size = c(maxHeight,     500), algorithm = "kernel") |> SimpleList()
sm_GC2 <- sapply(hm_GC2, smoothHeatmap, output.size = c(maxHeight,     500), algorithm = "kernel") |> SimpleList()
#sm_GC3 <- sapply(hm_GC3, smoothHeatmap, output.size = c(maxHeight,     500), algorithm = "kernel") |> SimpleList()

#plotHeatmapList(sm_GC1[1:5])

plotHeatmapList(sm_GC2[1:5])
#plotHeatmapList(sm_GC2[6:10])
#plotHeatmapList(sm_GC2[11:15])

#plotHeatmapList(sm_GC3[1:5])
```

The alignment stops are ordered in such a way that start (or left breaks) are
centred on the top half of the plot, and end alignment stops are centred on the
bottom. This is why we see different directionality in the plots. At the
alignment stops, the GC content seems to be lower, but higher once within the
aligned region. 

Now looking at TATA content:

```{r TATA, fig.height=6, fig.width=12}
#hm_GC1_TATA <- sapply(gbs, bp_heatmap, basep_range = 1000, pat = "TATA", direction = "left") |> SimpleList()
hm_GC2_TATA <- sapply(coa, bp_heatmap, basep_range = 1000, pat = "TATA", direction = "left") |> SimpleList()

maxHeight <- 2000
#sm_GC1_TATA <- sapply(hm_GC1_TATA, smoothHeatmap, output.size = c(maxHeight,     500), algorithm = "kernel") |> SimpleList()
sm_GC2_TATA <- sapply(hm_GC2_TATA, smoothHeatmap, output.size = c(maxHeight,     500), algorithm = "kernel") |> SimpleList()
#sm_GC3_TATA <- sapply(hm_GC3_TATA, smoothHeatmap, output.size = c(maxHeight,     500), algorithm = "kernel") |> SimpleList()

#plotHeatmapList(sm_GC1_TATA)
plotHeatmapList(sm_GC2_TATA[1:5])
#plotHeatmapList(sm_GC3_TATA)
```

The directionaility here is consistent with the `GC` content analysis.
Furthermore; "TATA box sequence can act as a basal promoter element not only for
RNA polymerase II (RNAP II) transcription, but also for transcription by RNA
polymerase III (RNAP III)" - Wang Y, Jensen RC, Stumph WE. Role of TATA box
sequence and orientation in determining RNA polymerase II/III transcription
specificity. Nucleic Acids Res. 1996;24(15):3100–3106.
doi:10.1093/nar/24.15.3100. However, the areas are not particularly enriched
for TATA boxes, so it does not necessarily show that breakpoints are occurring
directly after promoter regions. 


```{r AAGCsGCwwmkCGrCTTyn, fig.height=6, fig.width=12}
#hm_GC1_mot <- sapply(gbs, bp_heatmap, basep_range = 1000, pat = "AGCNGC", direction = "left") |> SimpleList()
hm_GC2_mot <- sapply(coa, bp_heatmap, basep_range = 1000, pat = "AGCNGC", direction = "left") |> SimpleList()

maxHeight <- 2000
#sm_GC1_mot <- sapply(hm_GC1_mot, smoothHeatmap, output.size = c(maxHeight,     500), algorithm = "kernel") |> SimpleList()
sm_GC2_mot <- sapply(hm_GC2_mot, smoothHeatmap, output.size = c(maxHeight,     500), algorithm = "kernel") |> SimpleList()
#sm_GC3_mot <- sapply(hm_GC3_mot, smoothHeatmap, output.size = c(maxHeight,     500), algorithm = "kernel") |> SimpleList()

#plotHeatmapList(sm_GC1_mot)
plotHeatmapList(sm_GC2_mot[1:5])
#plotHeatmapList(sm_GC3_mot)
```


## Cluster analysis


```{r cluster_analysis, fig.height=20, fig.width=20}
# # Accessory functions
# clusterHeatmap <- function(hm, k = 2) kmeans(image(hm), k)
# 
# orderHeatmap <- function(hm, cl) {
#   image(hm) <- image(hm)[order(cl$cluster),]
#   hm
# }
# 
# subsetHeatmap <- function(hm, bool) {
#   image(hm) <- image(hm)[bool,]
#   hm
# }
# 
# # DAta
# hm_GC   <- bp_heatmap(      gr_Oki_O, basep_range  = 1000, pat = "GC",     direction = "left")
# hm_TATA <- bp_heatmap(      gr_Oki_O, basep_range  = 1000, pat = "TATA",   direction = "left")
# hm_tan  <- feature_coverage(gr_Oki_O, tan_Oki, win = 1000, lab = "Tandem", direction = "left")
# 
# # Define 3 K-mean clusters
# clusterHeatmap(hm_GC, 3) -> hm_cl_k4
# 
# # Order and smooth
# shm_GC <- orderHeatmap(hm_GC, hm_cl_k4) %>%
#   smoothHeatmap(output.size = c(2000,500), algorithm = "kernel")
# 
# shm_TATA <- orderHeatmap(hm_TATA, hm_cl_k4) %>%
#   smoothHeatmap(output.size = c(2000,500), algorithm = "kernel")
# 
# shm_tan <- orderHeatmap(hm_tan, hm_cl_k4) %>%
#   smoothHeatmap(output.size = c(2000,500), algorithm = "kernel")
# 
# # Plot the ordered data
# plotHeatmapList(list(shm_GC, shm_TATA, shm_tan))
# par(mfrow = c(1,1)) # plotHeatmapList messes with mrfrow...
# plotHeatmapMeta(list(hm_GC, hm_TATA, hm_tan))
# 
# plotHeatmapMeta(list(subsetHeatmap(hm_GC, hm_cl_k4$cluster == 1),
#                      subsetHeatmap(hm_GC, hm_cl_k4$cluster == 2),
#                      subsetHeatmap(hm_GC, hm_cl_k4$cluster == 3)))
# 
# kmeanOrderedPlot <- function (hm, k=3, seed = 1) {
#   set.seed(seed)
#   
#   cl <- kmeans(image(hm), k)
#   mat <- image(hm)[order(cl$cluster),]
#   
#   kmhm = Heatmap(
#     mat,
#     coords=c(-500,500),
#     label="kmeans",
#     scale=range(mat))
#   
#   plotHeatmapList(kmhm,
#                   cex.label=1.5,
#                   partition=as.vector(table(cl$cluster)),
#                   partition.legend=TRUE,
#                   partition.lines=TRUE,
#                   legend=TRUE,
#                   legend.pos="r",
#                   legend.width=0.3)
# }
# 
# kmeanOrderedPlot(shm_GC)
```

## Evidence for breakpoint hotspots

The function `bp_pair_analysis` takes two pairwise alignments with the same target genome, and plots the alignment stops on to the centred alignment stops of the other. In the plot below, Osaka is there consistent target genome, and as such acts as a coordinate system to relate alignment stops across genomes. Lets produce two of these 3-way analyses; one between Osaka-Okinawa-Norway, and one between Osaka-Okinawa-Aomori

```{r echo=T, message=F, warning=F}

# hm1 <- bp_pair_analysis(gr_ref_q1 = gr_O_Oki, gr_ref_q2 = gr_O_N, win = 1000, lab = "Oki~Nor")
# plotHeatmapMeta(hm1)
# 
# hm2 <- bp_pair_analysis(gr_ref_q1 = gr_O_Oki, gr_ref_q2 = gr_O_A, win = 1000, lab = "Oki~Aom")
# plotHeatmapMeta(hm2)

```

The accumulation of alignment breaks of one pairwise alignment onto another suggests the existence of breakpoint hotspots; regions where breaks are far more likely to occur. Intuitively, this would lead to the presumption of synteny blocks, also. The pattern is consistent after coalescing, too;

```{r echo=T, message=F, warning=F}

# reduced_gr_O_N <- coalesce_contigs(gr_ob = gr_O_N, tol = 500)
# 
# hm3 <- bp_pair_analysis(gr_ref_q1 = reduced_gr_O_Oki, gr_ref_q2 = reduced_gr_O_N, win = 1000, lab = "Oki~Nor")
# plotHeatmapMeta(hm3)

```

## Tandem repeat coverage around alignment stops (breakpoints)

The function `GenomicBreaks::feature_coverage()` will plot the coverage of tandem repeats around
centred alignment stops. 

```{r echo=T, message=F, warning=F, cache=FALSE}
# 
# hm_tan1 <- feature_coverage(gr_ob = gr_O_Oki, feat = tan_O, win = 4000, lab = "Osk ~ Oki", direction = "left")
# plotHeatmapMeta(hm_tan1)
#  
# hm_tan2 <- feature_coverage(gr_ob = reduced_gr_O_Oki, feat = tan_O, win = 4000, lab = "OSK~Oki (coalesced)", direction = "left")
# plotHeatmapMeta(hm_tan2)
# 
# # should I also add comparison of proportions of tandem proximities before and after coalescion?
```

There appears to be less tandem repeats around alignment stops after coalescion,
inferring that perhaps that some are artefacts of difficult alignment near to
tandem repeats. 


## Gene feature coverage around alignment stops (breakpoints)

TODO: analyse separately the breakpoint regions that are in colinear regions?

The function `feature_coverage` will plot the coverage of tandem repeats around
centred alignment stops. 

```{r genomic_features, cache=FALSE}
#current_GB <- gr_Oki_O # To ease recomputing with another object
current_GB <- gbs$Oki_Osa
#current_GB <- coa$Oki_Osa
pwm <- gadems.invLeftGap$Oki_Osa[[1]]
pwm@consensus
pwmHits <- matchPWM(pwm = rGADEM::getPWM(pwm), genomes$Oki)

hmList_OKI <- list()

hmList_OKI$genes      <- feature_coverage(current_GB, genes(annots$Oki),                         win = 2000, lab = "Oki genes", direction = "left")
hmList_OKI$promoters  <- feature_coverage(current_GB, promoters(annots$Oki),                     win = 2000, lab = "Oki promoters", direction = "left")
hmList_OKI$exons      <- feature_coverage(current_GB, exonicParts(annots$Oki),                   win = 2000, lab = "Oki exons", direction = "left")
hmList_OKI$introns    <- feature_coverage(current_GB, intronicParts(annots$Oki),                 win = 2000, lab = "Oki introns", direction = "left")
hmList_OKI$cds        <- feature_coverage(current_GB, cds(annots$Oki),                           win = 2000, lab = "Oki cds", direction = "left")
hmList_OKI$utrs5      <- feature_coverage(current_GB, unlist(fiveUTRsByTranscript(annots$Oki)),  win = 2000, lab = "Oki 5′ UTRs", direction = "left")
hmList_OKI$utrs3      <- feature_coverage(current_GB, unlist(threeUTRsByTranscript(annots$Oki)), win = 2000, lab = "Oki 3′ UTRs", direction = "left")
hmList_OKI$pwm        <- feature_coverage(current_GB, pwmHits                                  , win = 2000, lab = "PWM", direction = "left")

plotHeatmapMeta(hmList_OKI)
plotHeatmapMeta(hmList_OKI$genes)
plotHeatmapMeta(hmList_OKI[c("exons", "cds")])
plotHeatmapMeta(hmList_OKI[c("exons", "introns", "utrs5", "utrs3", "pwm")])
plotHeatmapMeta(hmList_OKI[c("introns", "utrs5", "utrs3", "pwm")])
plotHeatmapMeta(hmList_OKI[c("utrs5", "utrs3", "pwm")])
```

Aligned regions are enriched in exons and depleted in introns.  Is it because
exons are more alignable or is it because it is deleterous to break genes
in exons ?

## Gene feature coverage around PWM hits

Let's look at coverage around PWM hits of the AAGCsGCwwmkCGrCTTyn motif

```{r genomic_features_pwmHits, cache=FALSE}
current_GB <- pwmHits

hmList_PWM_OKI <- list()
hmList_PWM_OKI$genes     <- feature_coverage(current_GB, genes(annots$Oki),                         win = 2000, lab = "Oki genes", direction = "left")
hmList_PWM_OKI$promoters <- feature_coverage(current_GB, promoters(annots$Oki),                     win = 2000, lab = "Oki promoters", direction = "left")
hmList_PWM_OKI$exons     <- feature_coverage(current_GB, exonicParts(annots$Oki),                   win = 2000, lab = "Oki exons", direction = "left")
hmList_PWM_OKI$introns   <- feature_coverage(current_GB, intronicParts(annots$Oki),                 win = 2000, lab = "Oki introns", direction = "left")
hmList_PWM_OKI$cds       <- feature_coverage(current_GB, cds(annots$Oki),                           win = 2000, lab = "Oki cds", direction = "left")
hmList_PWM_OKI$utrs5     <- feature_coverage(current_GB, unlist(fiveUTRsByTranscript(annots$Oki)),  win = 2000, lab = "Oki 5′ UTRs", direction = "left")
hmList_PWM_OKI$utrs3     <- feature_coverage(current_GB, unlist(threeUTRsByTranscript(annots$Oki)), win = 2000, lab = "Oki 3′ UTRs", direction = "left")

plotHeatmapMeta(hmList_PWM_OKI)
plotHeatmapMeta(hmList_PWM_OKI[c("exons", "introns")])
plotHeatmapMeta(hmList_PWM_OKI[c("exons", "utrs5", "utrs3")])
plotHeatmapMeta(hmList_PWM_OKI[c("utrs5", "utrs3")])
```

They are enriched in introns...

```{r genomic_features3, cache=FALSE}
# 
# # Sandbox to make sanity checks.
# 
# a <- coa$Oki_Osa
# b <- unlist(fiveUTRsByTranscript(annots$Oki))
# 
# hm_a <- feature_coverage(a, b, win = 2000, lab = "All ranges", direction = "left")
# hm_b <- feature_coverage(subsetByOverlaps(a,  b), b, win = 2000, lab = "Subsetted ranges", direction = "left")
# 
# plotHeatmapMeta(list(hm_a))
# plotHeatmapMeta(list(hm_b))
```


## Okinawa genome coverage

As previously discussed, low coverage over an alignment stop could lower the likelihood of it being considered as a breakpoint. We have per-base coverage depth information for the Okinawan genome (`Oki_cov_pb`). However, the coverage of this particular assembly is quite good. In fact, we can investigate the coverge over alignment stops from the information obtained using `master_bp_analysis`. 

```{r echo=T, message=F, warning=F}
# fin_Oki <- fin_gr_O_Oki[[2]]
# min_cov <- min(min(fin_Oki$left_cov_pb), min(fin_Oki$right_cov_pb)) # minimum coverage over an alignment stop
# min_cov
# length(fin_Oki[fin_Oki$left_cov_pb == min_cov]) + length(fin_Oki[fin_Oki$right_cov_pb == min_cov]) # how many of the minimum coverage is observed
# length(fin_Oki[fin_Oki$left_cov_pb <= 50]) + length(fin_Oki[fin_Oki$right_cov_pb <= 50]) # how many alignment stops have a coverage of less than or euqal to 50

```

We may choose to kick out the one alignment stop for which there is no coverage. However, only 15 out of 34572 alignment stops have a coverage of less than or equal to 50, meaning that it would be hard to exclude more than just a few alignment stops using coverage information for breakpoint analysis. 



