---
title: "Exploring coding-sequence substitutions"
author: 
 - "Michael Mansfield"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Exploring coding-sequence substitutions}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
  markdown: 
    wrap: 72
---

```{r setup}
knitr::opts_knit$set(verbose = TRUE)
```

# Introduction

This vignette loads dN/dS statistics tables and explores the
relationship between substitutions in coding sequences and genomic
breaks.

This vignette assumes that prior vignettes have been explored by the
user previously and that the `GenomicBreaks` and `OikScrambling`
packages have been installed already.

# Packages and data

```{r load_pacakges_and_data}
suppressPackageStartupMessages({
  library("tibble")
  library("dplyr")
  library('GenomicBreaks')
  library('ggplot2')
  library("BreakpointsData")
})

(genomes <- OikScrambling:::loadAllGenomes())
(transcripts <- OikScrambling:::loadAllTranscriptsGR())

load("BreakPoints.Rdata")
```

# Genomic breaks

## dN/dS values
After you have loaded the transcripts using the `loadAllTranscriptsGR` function,
you should have a `GRanges` object for every species with one interval per gene
and dN/dS metadata columns. 

Similar to the `GBreaks` object in the `OrthogroupSyntenies` vignette. 

The `GBreaks` object from the `OrthogroupSyntenies` vignette is suitable.

```{r create_dNdS_GUIDANCE2_orthopairs, fig.height=12, fig.width=8.5, dev=c('svg', 'png')}
orthoPairToGBreaks <- function(name1, name2, annot1, annot2) {
  orthoPairs <- load_one_to_ones(
    system.file("extdata/OrthoFinder/N19.tsv", package = "BreakpointsData"),
    c(name1, name2))

  IDs2GRanges <- function (IDs, annot) {
    prefix <- Biobase::lcPrefix(IDs)                  # Guess prefix in transcript IDs from HOG files
    not_prefix <- Biobase::lcPrefix(annot$tx_name)    # Remove trailing characters that are part of the name
    not_prefix <- paste0(not_prefix,"$")              # Anchor to end of the string
    prefix <- sub(not_prefix, "", prefix)             # Finalise prefix
    IDs <- sub(prefix, "", IDs)                       # Remove prefix from IDS
    names(annot) <- annot$tx_name                     # Store transcript name in names slot
    gr <- granges(annot[IDs], use.mcols=T)            # Don't! discard metadata. Sort by ID
    strand(gr) <- "*"                                 # Make strandless
    gr                                                # Return the object
  }
  
  gb       <- IDs2GRanges(orthoPairs[,name1], annot1)
  gb$query <- IDs2GRanges(orthoPairs[,name2], annot2)
  gb <- GenomicBreaks:::GBreaks(gb)
  sort(gb)
}

orthoPairs <- SimpleList()
orthoPairs$Oki_Osa <- orthoPairToGBreaks("OKI2018_I69.v2.prot.longest.fa_1", "OSKA2016v1.9.prot.longest.fa_1"
                                        , transcripts$Oki, transcripts$Osa)
orthoPairs$Oki_Bar <- orthoPairToGBreaks("OKI2018_I69.v2.prot.longest.fa_1", "Bar2_p4.Flye.prot.longest.fa_1"
                                        , transcripts$Oki, transcripts$Bar)
orthoPairs$Oki_Kum <- orthoPairToGBreaks("OKI2018_I69.v2.prot.longest.fa_1", "KUM-M3-7f.prot.longest.fa_1"
                                        , transcripts$Oki, transcripts$Kum)
orthoPairs$Oki_Aom <- orthoPairToGBreaks("OKI2018_I69.v2.prot.longest.fa_1", "AOM-5-5f.prot.longest.fa_1"
                                        , transcripts$Oki, transcripts$Aom)
orthoPairs$Oki_Nor <- orthoPairToGBreaks("OKI2018_I69.v2.prot.longest.fa_1", "OdB3.v1.0.prot.fa_1.nohaplo"
                                       , transcripts$Oki, transcripts$Nor)

orthoPairs$Osa_Bar <- orthoPairToGBreaks("OSKA2016v1.9.prot.longest.fa_1", "Bar2_p4.Flye.prot.longest.fa_1"
                                        , transcripts$Osa, transcripts$Bar)
orthoPairs$Osa_Oki <- orthoPairToGBreaks("OSKA2016v1.9.prot.longest.fa_1", "OKI2018_I69.v2.prot.longest.fa_1"
                                        , transcripts$Osa, transcripts$Oki)
orthoPairs$Osa_Kum <- orthoPairToGBreaks("OSKA2016v1.9.prot.longest.fa_1", "KUM-M3-7f.prot.longest.fa_1"
                                        , transcripts$Osa, transcripts$Kum)
orthoPairs$Osa_Aom <- orthoPairToGBreaks("OSKA2016v1.9.prot.longest.fa_1", "AOM-5-5f.prot.longest.fa_1"
                                        , transcripts$Osa, transcripts$Aom)
orthoPairs$Osa_Nor <- orthoPairToGBreaks("OSKA2016v1.9.prot.longest.fa_1", "OdB3.v1.0.prot.fa_1.nohaplo"
                                       , transcripts$Osa, transcripts$Nor)


orthoPairs$Bar_Osa <- orthoPairToGBreaks("Bar2_p4.Flye.prot.longest.fa_1", "OSKA2016v1.9.prot.longest.fa_1"
                                        , transcripts$Bar, transcripts$Osa)
orthoPairs$Bar_Oki <- orthoPairToGBreaks("Bar2_p4.Flye.prot.longest.fa_1", "OKI2018_I69.v2.prot.longest.fa_1"
                                        , transcripts$Bar, transcripts$Oki)
orthoPairs$Bar_Kum <- orthoPairToGBreaks("Bar2_p4.Flye.prot.longest.fa_1", "KUM-M3-7f.prot.longest.fa_1"
                                        , transcripts$Bar, transcripts$Kum)
orthoPairs$Bar_Aom <- orthoPairToGBreaks("Bar2_p4.Flye.prot.longest.fa_1", "AOM-5-5f.prot.longest.fa_1"
                                        , transcripts$Bar, transcripts$Aom)
orthoPairs$Bar_Nor <- orthoPairToGBreaks("Bar2_p4.Flye.prot.longest.fa_1", "OdB3.v1.0.prot.fa_1.nohaplo"
                                       , transcripts$Bar, transcripts$Nor)

orthoPairs[ 1:5 ] <- sapply(orthoPairs[ 1:5 ],  flagLongShort, longShort$Oki)
orthoPairs[ 6:10] <- sapply(orthoPairs[ 6:10],  flagLongShort, longShort$Osa)
orthoPairs[11:15] <- sapply(orthoPairs[11:15],  flagLongShort, longShort$Bar)
```

Using these transcript-based `GBreaks` objects, you can annotate those
transcripts with arbitrary metadata. Note that the transcript identifier
is relative to the target.

TODO resolve cases where query metadata is not precisely equal to target metadata

Now, we can get to plotting.

```{r plot_init_orthopairs_dNdS_GUIDANCE2, fig.height=4, fig.width=6, dev=c("svg", "png")}
ggplot(tibble(as.data.frame(orthoPairs$Oki_Osa))) +
  aes(dNdS_GUIDANCE2, fill=Arm) +
  geom_boxplot() +
  coord_flip() +
  facet_wrap(~seqnames) +
  ggtitle('dN/dS by chromosome and chromosome arm for Oki/Osa')
```

Notice that an unplaced scaffold appears to have a gene that was used for the dN/dS analysis. Let's filter those out.

```{r plot_enumerate_dNdS_GUIDANCE2, fig.height=4, fig.width=6, dev=c("svg", "png")}
ggplot(tibble(as.data.frame(orthoPairs$Oki_Osa)) %>% filter(seqnames %in% c('chr1', 'chr2', 'PAR', 'XSR', 'YSR'))) +
  aes(dNdS_GUIDANCE2, fill=Arm) +
  geom_boxplot() +
  coord_flip() +
  facet_wrap(~seqnames) +
  ggtitle('dN/dS by chromosome and chromosome arm for Oki/Osa')
```

Let's enumerate the rest:

```{r dNdS_GUIDANCE2_enumerate, fig.height=4, fig.width=6, dev=c("svg", "png")}
# Note that the chromosome names change.
ggplot(tibble(as.data.frame(orthoPairs$Osa_Oki)) %>% filter(seqnames %in% c('Chr1', 'Chr2', 'PAR', 'XSR', 'YSR'))) +
  aes(dNdS_GUIDANCE2, fill=Arm) +
  geom_boxplot() +
  coord_flip() +
  facet_wrap(~seqnames) +
  ggtitle('dN/dS by chromosome and chromosome arm for Osa/Oki')
ggplot(tibble(as.data.frame(orthoPairs$Osa_Bar)) %>% filter(seqnames %in% c('Chr1', 'Chr2', 'PAR', 'XSR', 'YSR'))) +
  aes(dNdS_GUIDANCE2, fill=Arm) +
  geom_boxplot() +
  coord_flip() +
  facet_wrap(~seqnames) +
  ggtitle('dN/dS by chromosome and chromosome arm for Osa/Bar')

ggplot(tibble(as.data.frame(orthoPairs$Bar_Osa)) %>% filter(seqnames %in% c('Chr1', 'Chr2', 'PAR', 'XSR', 'YSR'))) +
  aes(dNdS_GUIDANCE2, fill=Arm) +
  geom_boxplot() +
  coord_flip() +
  facet_wrap(~seqnames) +
  ggtitle('dN/dS by chromosome and chromosome arm for Bar/Osa')

ggplot(tibble(as.data.frame(orthoPairs$Bar_Oki)) %>% filter(seqnames %in% c('Chr1', 'Chr2', 'PAR', 'XSR', 'YSR'))) +
  aes(dNdS_GUIDANCE2, fill=Arm) +
  geom_boxplot() +
  coord_flip() +
  facet_wrap(~seqnames) +
  ggtitle('dN/dS by chromosome and chromosome arm for Bar/Oki')
```

## Coalescing orthogroups
As in the `OrthogroupSyntenies` vignette, we'll need to coalesce the orthogroup
pairs in order to continue exploring the dN/dS values.

First, remove overlapping regions.

```{r flag_remove_overlaps}
flagOverlaps <- function(gr) {
  # Find overlaps
  ov <- findOverlaps(gr)
  # Index of self hits in the gr object
  idx <- queryHits(ov[!isSelfHit(ov)])
  # Convert to Boolean indexing the gr object
  seq_along(gr) %in% idx
}

orthoPairsFiltered <- sapply(orthoPairs, function(gb) {
  gb <- gb[!flagOverlaps(gb)]
  gb <- gb[!flagOverlaps(gb$query)]
  gb
}) |> SimpleList()
sapply(orthoPairsFiltered, length)
```

Now, coalesce the filtered orthogroup pairs into syntenic blocks. Note the code
below has been modified from the `OrthogroupsSynteny` vignette to accommodate
gluing dN/dS into the coalesced blocks.

```{r coalesce_orthopairs}
# A little helper to extract dN/dS values from the orthoPairs object.
dNdSFromOrthoPairs <- function(orthoPair, tx_name, column_name='dNdS_GUIDANCE2'){
  if(tx_name %in% orthoPair$tx_name){
    dnds <- as.data.frame(orthoPair[orthoPair$tx_name == tx_name,])[[column_name]]
  } else {
    dnds <- NA
  }
  
  dnds
}

coalOrtho <- function(gb) {
  # Coalesce
  coal <- coalesce_contigs(gb)
  
  # Map annotations to the coalesced blocks
  ov <- findOverlaps(coal, gb)
  
  # Extract gene names mapped to each blocks
  geneNames <- split(names(gb)[subjectHits(ov)], queryHits(ov))
  
  # Concatenate them as single strings and graft them to the coal object
  coal$geneNames <- sapply(geneNames, paste, collapse = ", ")
  
  # Graft dN/dS values too.
  coal$dNdS <- sapply(geneNames, function(name) {
    dNdSFromOrthoPairs(gb, tx_name=name, column_name='dNdS_GUIDANCE2')
  })
    
  # Count genes per syntenic block
  coal$geneNumber <- sapply(geneNames, length)
  
  coal
}
orthoBlocks <- sapply(orthoPairsFiltered, coalOrtho) |> SimpleList()

orthoBlocks[ 1:5 ] <- sapply(orthoBlocks[ 1:5 ],  flagLongShort, longShort$Oki)
orthoBlocks[ 6:10] <- sapply(orthoBlocks[ 6:10],  flagLongShort, longShort$Osa)
orthoBlocks[11:15] <- sapply(orthoBlocks[11:15],  flagLongShort, longShort$Bar)
```

Now that we have orthoblocks, let's assess how dN/dS relates to gene synteny.
First, create a function to look at blocks with X genes, then look up their
dN/dS values.

```{r dnds_synteny}

```

# Session information

```{r session_info}
sessionInfo()
```
