---
title: "Orthogroup syntenies"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEncoding{UTF-8}
  %\VignetteIndexEntry{Orthogroup syntenies}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup}
knitr::opts_knit$set(cache = TRUE)
```

Load packages and data
======================

See `?OikScrambling:::loadAllGenomes()`, `?OikScrambling:::loadAllTranscriptsGR()`,
and `vignette("LoadGenomicBreaks", package = "OikScrambling")` for how the
different objects are prepared.

```{r load_packages_and_data}
library('OikScrambling')   |> suppressPackageStartupMessages()
library('patchwork')
genomes <- OikScrambling:::loadAllGenomes(compat = F)
transcripts <- OikScrambling:::loadAllTranscriptsGR(compat = F) |> suppressWarnings()
load("BreakPoints.Rdata")
```

Prepare GBreaks objects
=======================

Orthogroups for _Oikopleura_ are loaded from the `BreakpointsData` package with
the `OikScrambling::load_one_to_ones()` function.  Original file is in
`/bucket/LuscombeU/common/Breakpoints/Orthologues/selTun+Apps+Amph+Vert_lp_100clstr_blast/OrthoFinder/Results_Oct07/Phylogenetic_Hierarchical_Orthogroups/N19.tsv`. See `news(package = "BreakpointsData")`
for inspecting changes in more details.

Load Orthogroup data
--------------------

This produces `GBreaks` objects that map orthologs from between two genomes.
In these objects, the _target_ and _query_ roles are equivalent.  The genomic
coordinates are taken from the annotation files (see
`?OikScrambling:::loadAllTranscriptsGR`.

### Orthogroup pairs

To maximise number of entries, we load data from the larvacean and the ascidian
subtrees respectively.  This produces the `orthoPairs` collection of objects.

```{r orthoPairs_object, dependson="load_packages_and_data"}
orthoGroupFileNames <- SimpleList(
  AOM.5.5f      = "AOM-5-5f.prot.longest.fa_1", 
  Bar2.p4       = "Bar2_p4.Flye.prot.longest.fa_1", 
  Ply           = "C_int_P.prot.longest.fa_1",
  Ros           = "C_int_R.prot.longest.fa_1",
  Int           = "Ciona_intestinalis.Uniprot.rn.fa_1",
  Sav           = "Ciona_savignyi.Uniprot.rn.fa_1",
  KUM.M3.7f     = "KUM-M3-7f.prot.longest.fa_1",
  OKI2018.I69   = "OKI2018_I69.v2.prot.longest.fa_1",
  OSKA2016v1.9  = "OSKA2016v1.9.prot.longest.fa_1",
  OdB3          = "OdB3.v1.0.prot.fa_1.nohaplo"
)

orthoPairToGBreaks <- function(genome1, genome2, transcripts, treeName="N19", HOGs=NULL) {
  if(is.null(HOGs))
    HOGs <- OikScrambling:::load_one_to_ones(
      system.file(paste0("extdata/OrthoFinder/",treeName,".tsv"), package = "BreakpointsData"),
      c(orthoGroupFileNames[[genome1]], orthoGroupFileNames[[genome2]]))

  IDs2GRanges <- function (IDs, annot) {
    prefix <- Biobase::lcPrefix(IDs)                  # Guess prefix in transcript IDs from HOG files
    not_prefix <- Biobase::lcPrefix(annot$tx_name)    # Remove trailing characters that are part of the name
    not_prefix <- paste0(not_prefix,"$")              # Anchor to end of the string
    prefix <- sub(not_prefix, "", prefix)             # Finalise prefix
    IDs <- sub(prefix, "", IDs)                       # Remove prefix from IDS
    names(annot) <- annot$tx_name                     # Store transcript name in names slot
    gr <- annot[IDs]                                  # Sort by ID
    strand(gr) <- "*"                                 # Make strandless
    gr                                                # Return the object
  }
  
  gb       <- IDs2GRanges(HOGs[,orthoGroupFileNames[[genome1]]], transcripts[[genome1]])
  if (!is.null(genomes[[genome1]]))
    seqinfo(gb) <- seqinfo(genomes[[genome1]])
  gb$query <- IDs2GRanges(HOGs[,orthoGroupFileNames[[genome2]]], transcripts[[genome2]])
  if (!is.null(genomes[[genome2]]))
   seqinfo(gb$query) <- seqinfo(genomes[[genome2]])
  gb <- GenomicBreaks:::GBreaks(gb)
  gb$HOG <- HOGs$HOG
  gb$OG  <- HOGs$OG
  sort(gb)
}

flagLongShort_ <- function(gr, transcripts) {
  genome <- unique(genome(gr))
  flagLongShort(gr, transcripts[[genome]])
}

orthoPairToGBreaks_all_Oiks <- function(treeName=NULL, HOGs=NULL) {
  orthoPairs <- SimpleList()
  orthoPairs$Oki_Osa <- orthoPairToGBreaks("OKI2018.I69", "OSKA2016v1.9",   transcripts, treeName, HOGs)
  orthoPairs$Oki_Bar <- orthoPairToGBreaks("OKI2018.I69", "Bar2.p4",        transcripts, treeName, HOGs)
  orthoPairs$Oki_Kum <- orthoPairToGBreaks("OKI2018.I69", "KUM.M3.7f",      transcripts, treeName, HOGs)
  orthoPairs$Oki_Aom <- orthoPairToGBreaks("OKI2018.I69", "AOM.5.5f",       transcripts, treeName, HOGs)
  orthoPairs$Oki_Nor <- orthoPairToGBreaks("OKI2018.I69", "OdB3",           transcripts, treeName, HOGs)
  
  orthoPairs$Osa_Bar <- orthoPairToGBreaks("OSKA2016v1.9",   "Bar2.p4",     transcripts, treeName, HOGs)
  orthoPairs$Osa_Oki <- orthoPairToGBreaks("OSKA2016v1.9",   "OKI2018.I69", transcripts, treeName, HOGs)
  orthoPairs$Osa_Kum <- orthoPairToGBreaks("OSKA2016v1.9",   "KUM.M3.7f",   transcripts, treeName, HOGs)
  orthoPairs$Osa_Aom <- orthoPairToGBreaks("OSKA2016v1.9",   "AOM.5.5f",    transcripts, treeName, HOGs)
  orthoPairs$Osa_Nor <- orthoPairToGBreaks("OSKA2016v1.9",   "OdB3",        transcripts, treeName, HOGs)
  
  orthoPairs$Bar_Osa <- orthoPairToGBreaks("Bar2.p4",   "OSKA2016v1.9",     transcripts, treeName, HOGs)
  orthoPairs$Bar_Oki <- orthoPairToGBreaks("Bar2.p4",   "OKI2018.I69",      transcripts, treeName, HOGs)
  orthoPairs$Bar_Kum <- orthoPairToGBreaks("Bar2.p4",   "KUM.M3.7f",        transcripts, treeName, HOGs)
  orthoPairs$Bar_Aom <- orthoPairToGBreaks("Bar2.p4",   "AOM.5.5f",         transcripts, treeName, HOGs)
  orthoPairs$Bar_Nor <- orthoPairToGBreaks("Bar2.p4",   "OdB3",             transcripts, treeName, HOGs)
  
  orthoPairs <- sapply(orthoPairs,  flagLongShort_, longShort)
  
  SimpleList(orthoPairs)
}

orthoPairs         <- orthoPairToGBreaks_all_Oiks("N19")
orthoPairs$Ply_Ros <- orthoPairToGBreaks("Ply", "Ros", transcripts, treeName="N20")
```

### Orthogroup core pairs

The `orthoPairs_core` collection is built similarly, but from "core"
orthogroups, that have a member in each species of the tunicate clade.

```{r orthoPairs_core, dependson="orthoPairs_object"}
orthoPairs_core         <- orthoPairToGBreaks_all_Oiks("N3")
orthoPairs_core$Ply_Ros <- orthoPairToGBreaks("Ply", "Ros", transcripts, treeName="N3")
```

### Orthogroups one-to-one in oiks.

Lastly we build an object for Oiks only where we require every orthologue to be
present as a single copy in every genome.  This is the `orthoPairs_one2oneInOiks`
collection.

```{r orthoPairs_one2oneInOiks, dependson="orthoPairs_object"}
orthoPairs_one2oneInOiks <-
  orthoPairToGBreaks_all_Oiks(treeName = NULL,
                              HOGs = OikScrambling:::load_one_to_ones(
                                       system.file("extdata/OrthoFinder/N19.tsv", package = "BreakpointsData")))
```

### Summary

Here is the number of entries in each object.

```{r summary_orthoPairs, dependson=c("orthoPairs_object", "orthoPairs_core", "orthoPairs_one2oneInOiks")}
sapply(orthoPairs, length)
sapply(orthoPairs_core, length)
sapply(orthoPairs_one2oneInOiks, length)
```

Oxford plots
============

Versus Osa
----------

```{r orthopair_plot_Oki_Osa}
p1 <- orthoPairs$Oki_Osa |> removeUnplacedContigs() |>
  makeOxfordPlots(type='point', diag = F) + theme_bw() + theme(legend.position='none') +
  scale_color_manual(values = c("#E78AC3", "#A6D854", "#FFD92F", "#8DA0CB", "#66C2A5")) + ggtitle(NULL)
```

```{r orthopair_plot_Bar_Osa}
p2 <- orthoPairs$Bar_Osa |> removeUnplacedContigs() |>
  makeOxfordPlots(type='point', diag=F) + theme_bw() + theme(legend.position='none') +
  scale_color_manual(values = c("#E78AC3", "#A6D854", "#FFD92F", "#8DA0CB", "#66C2A5")) + ggtitle(NULL)
```

```{r orthopair_plot_Aom_Osa}
p3 <- orthoPairs$Osa_Aom |> swap() |>
  scaffoldByFlipAndMerge(scafs$Aom_Osa, drop = TRUE) |> removeUnplacedContigs() |>
  makeOxfordPlots(type='point', diag=F) +
    theme_bw() +
    theme(legend.position='none') + ggtitle(NULL) +
    scale_color_manual(values = c("#E78AC3", "#A6D854", "#FFD92F", "#8DA0CB", "#66C2A5"))
```

```{r orthopair_plots, fig.height=8, fig.width=8,  dev=c("svg", "pdf", "png"), fig.ext=c("svg", "pdf", "png")}
(p1 + p2 + p3)
```

Versus Oki
----------

```{r orthopair_plot_Oki_Bar}
(p4 <- orthoPairs$Bar_Oki |> removeUnplacedContigs() |>
   makeOxfordPlots(type='point', diag = F) + theme_bw() + theme(legend.position='none') +
   scale_color_manual(values = c("#E78AC3", "#A6D854", "#FFD92F", "#8DA0CB", "#66C2A5")) + ggtitle(NULL))
```

```{r orthopair_plot_Oki_Kum, fig.height=8, fig.width=8,  dev=c("svg", "pdf", "png"), fig.ext=c("svg", "pdf", "png")}
(p5 <- orthoPairs$Oki_Kum |> swap() |> scaffoldByFlipAndMerge(scafs$Kum_Oki, drop = TRUE) |>
    removeUnplacedContigs() |> 
    makeOxfordPlots(type='point', diag=T) + theme_bw() + theme(legend.position='none') +
   scale_color_manual(values = c("#E78AC3", "#A6D854", "#FFD92F", "#8DA0CB", "#66C2A5")) + ggtitle(NULL))
```

Collinear regions
=================

Remove overlapping annotations
------------------------------

Some transcript annotations overlap and this breaks the coalescing algorithm.

Here we produce non-overlapping versions of the objects.

```{r filtered_objects, dependson="summary_orthoPairs"}
transcripts$Bar2.p4 |> length()
transcripts$Bar2.p4 |> reduce(min = 0) |> length()

flagOverlaps <- function(gr) {
  # Find overlaps
  ov <- findOverlaps(gr)
  # Index of self hits in the gr object
  idx <- queryHits(ov[!isSelfHit(ov)])
  # Convert to Boolean indexing the gr object
  seq_along(gr) %in% idx
}

transcripts$Bar2.p4[flagOverlaps(transcripts$Bar2.p4)]

# Show examples
orthoPairs$Oki_Osa[flagOverlaps(orthoPairs$Oki_Osa)]
orthoPairs$Oki_Osa$query[flagOverlaps(orthoPairs$Oki_Osa$query)]

# Remove and show how much was removed

orthoPairsFiltered <- sapply(orthoPairs, function(gb) {
  gb <- gb[!flagOverlaps(gb)]
  gb <- gb[!flagOverlaps(gb$query)]
  gb
}) |> SimpleList()

orthoPairsFiltered_core <- sapply(orthoPairs_core, function(gb) {
  gb <- gb[!flagOverlaps(gb)]
  gb <- gb[!flagOverlaps(gb$query)]
  gb
}) |> SimpleList()

orthoPairs_one2oneInOiks_Filtered <- sapply(orthoPairs_one2oneInOiks, function(gb) {
  gb <- gb[!flagOverlaps(gb)]
  gb <- gb[!flagOverlaps(gb$query)]
  gb
}) |> SimpleList()

sapply(orthoPairs, length)               - sapply(orthoPairsFiltered, length)
sapply(orthoPairs_core, length)          - sapply(orthoPairsFiltered_core, length)
sapply(orthoPairs_one2oneInOiks, length) - sapply(orthoPairs_one2oneInOiks_Filtered, length)
```


Coalesce syntenic blocks and annotate them
------------------------------------------

```{r coalesce, dependson="filtered_objects"}
coalOrtho <- function(gb) {
  # Coalesce
  coal <- coalesce_contigs(gb)
  
  # Map annotations to the coalesced blocks
  ov <- findOverlaps(coal, gb)
  
  # Extract gene names mapped to each blocks
  coal$geneNames <- CharacterList(split(names(gb)[subjectHits(ov)], queryHits(ov))) |> unname()
  # We can use the `ov` object for query ranges as well because of the way `coal` was constructed.
  coal$query$geneNames <- CharacterList(split(names(gb$query)[subjectHits(ov)], queryHits(ov))) |> unname()
  
  # Extract dNdS values
  coal$dNdS_GUIDANCE2  <- NumericList(split(gb$dNdS_GUIDANCE2 [subjectHits(ov)], queryHits(ov)))
  coal$dNdS_HmmCleaner <- NumericList(split(gb$dNdS_HmmCleaner[subjectHits(ov)], queryHits(ov)))
  coal$dNdS_PRANK      <- NumericList(split(gb$dNdS_PRANK     [subjectHits(ov)], queryHits(ov)))
  # We just copy dNdS values to query ranges because they are the same.
  coal$query$dNdS_GUIDANCE2  <- coal$dNdS_GUIDANCE2
  coal$query$dNdS_HmmCleaner <- coal$dNdS_HmmCleaner
  coal$query$dNdS_PRANK      <- coal$dNdS_PRANK

  # Count genes per syntenic block
  coal$geneNumber <- sapply(coal$geneNames, length)
  
  coal
}

orthoBlocks <- sapply(orthoPairsFiltered[1:15], coalOrtho) |> SimpleList()
orthoBlocks$Ply_Ros <- coalesce_contigs(orthoPairsFiltered$Ply_Ros)
orthoBlocks[ 1:15 ] <- sapply(orthoBlocks[ 1:15 ],  flagLongShort_, longShort)

orthoBlocks_core <- sapply(orthoPairsFiltered_core[1:15], coalOrtho) |> SimpleList()
orthoBlocks_core$Ply_Ros <- coalesce_contigs(orthoPairsFiltered_core$Ply_Ros)
orthoBlocks_core[ 1:15 ] <- sapply(orthoBlocks_core[ 1:15 ],  flagLongShort_, longShort)

orthoBlocks_one2oneInOiks <- sapply(orthoPairs_one2oneInOiks_Filtered, coalOrtho) |> SimpleList()
orthoBlocks_one2oneInOiks <- sapply(orthoBlocks_one2oneInOiks,  flagLongShort_, longShort) |> SimpleList()

sapply(orthoPairsFiltered, length)
sapply(orthoBlocks, length)
sapply(orthoPairsFiltered_core, length)
sapply(orthoBlocks_core, length)
sapply(orthoPairs_one2oneInOiks_Filtered, length)
sapply(orthoBlocks_one2oneInOiks, length)
```


Compute bridge regions
----------------------

Let's pre-compute bridge regions with the `GenomicBreaks::bridgeRegions()`
function.

```{r bridge_regions, dependson="filtered_objects"}
# oP_bridges               <- sapply(orthoPairsFiltered,                bridgeRegions) |> SimpleList()
# oP_core_bridges          <- sapply(orthoPairsFiltered_core,           bridgeRegions) |> SimpleList()
oP_one2oneInOiks_bridges <- sapply(orthoPairs_one2oneInOiks_Filtered, bridgeRegions) |> SimpleList()
```

Size distribution of the blocks
===============================

```{r quick_overview}
hist(orthoBlocks$Oki_Osa$geneNumber)
table(orthoBlocks$Oki_Osa$geneNumber)
orthoBlocks$Oki_Osa[order(orthoBlocks$Oki_Osa$geneNumber)] |> tail(11)

hist(orthoBlocks$Oki_Kum$geneNumber)
table(orthoBlocks$Oki_Kum$geneNumber)
orthoBlocks$Oki_Kum[order(orthoBlocks$Oki_Kum$geneNumber)] |> tail(11)
```

Gene Order Conservation is smaller in short arms
================================================

```{r GOC}
orthoBlocks_LSnoNA <- sapply(orthoBlocks[1:15], function(gb) gb[!is.na(gb$Arm)]) |> SimpleList()
sapply(orthoBlocks_LSnoNA, length)

df <- sapply(orthoBlocks_LSnoNA,
             function(gb) tapply(gb, paste(seqnames(gb), gb$Arm), GOC))

apply(df, 2, \(x) {
  tst <- t.test(x[c(1,3,5)], x[c(2,4,6)])
  c(pval=tst$p.value, mx=tst$estimate[1], my=tst$estimate[2])
}) 
```

<details>
<summary>Click to expand results on a microbenchmark comparing `sapply(split)`
and `tapply`</summary>
```
> microbenchmark::microbenchmark(
  times = 10,
  sapply = sapply(split(x, paste(seqnames(x), x$Arm)), GOC),
  tapply = tapply(x, paste(seqnames(x), x$Arm), GOC)
)
Unit: seconds
   expr      min       lq     mean   median       uq      max neval
 sapply 6.853530 6.921293 7.050267 6.949315 7.270793 7.477390    10
 tapply 6.921118 6.923827 7.028373 6.939487 6.968288 7.431115    10
 ```
</details>

Fraction of the genome covered or syntenic
==========================================

```{r fraction_aligned}
uncov  <- BiocParallel::bplapply(orthoPairsFiltered, cleanGaps) |> SimpleList()
unsyn  <- BiocParallel::bplapply(orthoBlocks,        cleanGaps) |> SimpleList()

  covered_tot    <- sapply(orthoPairsFiltered,   \(x) sum(width(x)))
  syntenic_tot   <- sapply(orthoBlocks,          \(x) sum(width(x)))
uncovered_tot    <- sapply(uncov,                \(x) sum(width(x)))
unsyntenic_tot   <- sapply(unsyn,                \(x) sum(width(x)))

(syn_summary <- cbind(
  covered_frac   = covered_tot   / ( covered_tot   + uncovered_tot ) * 100,
  orthogenes_n   = sapply(orthoPairsFiltered, length),
  syntenic_frac  = syntenic_tot  / ( syntenic_tot  + unsyntenic_tot ) * 100,
  syntenic_reg   = sapply(orthoBlocks, length)
 )|> as.data.frame())

sapply(syn_summary, \(x) tapply(x, row.names(syn_summary) |> OikScrambling:::compDistance(), mean))   |> round(1)
sapply(syn_summary, \(x) tapply(x, row.names(syn_summary) |> OikScrambling:::compDistance(), median)) |> round(1)
sapply(syn_summary, \(x) tapply(x, row.names(syn_summary) |> OikScrambling:::compDistance(), sd))     |> round(1)
```

Unfortunately, there are not enough transcripts from Ciona that are part of the
pan-tunicate orthogroup set, which makes the comparison difficult between
Oikopleura and Cionaâ€¦

```{r fraction_aligned_core}
uncov  <- BiocParallel::bplapply(orthoPairsFiltered_core, cleanGaps) |> SimpleList()
unsyn  <- BiocParallel::bplapply(orthoBlocks_core,        cleanGaps) |> SimpleList()

  covered_tot    <- sapply(orthoPairsFiltered_core,   \(x) sum(width(x)))
  syntenic_tot   <- sapply(orthoBlocks_core,          \(x) sum(width(x)))
uncovered_tot    <- sapply(uncov,                     \(x) sum(width(x)))
unsyntenic_tot   <- sapply(unsyn,                     \(x) sum(width(x)))

(syn_summary_core <- cbind(
  covered_frac   = covered_tot   / ( covered_tot   + uncovered_tot ) * 100,
  orthogenes_n   = sapply(orthoPairsFiltered_core, length),
  syntenic_frac  = syntenic_tot  / ( syntenic_tot  + unsyntenic_tot ) * 100,
  syntenic_reg   = sapply(orthoBlocks_core, length)
 )|> as.data.frame())

sapply(syn_summary_core, \(x) tapply(x, row.names(syn_summary_core) |> OikScrambling:::compDistance(), mean))   |> round(1)
sapply(syn_summary_core, \(x) tapply(x, row.names(syn_summary_core) |> OikScrambling:::compDistance(), median)) |> round(1)
sapply(syn_summary_core, \(x) tapply(x, row.names(syn_summary_core) |> OikScrambling:::compDistance(), sd))     |> round(1)
```

Agreement with nucleotide alignments
====================================

```{r DNA_prot_comparison}
(gb_P <- orthoBlocks$Bar_Osa)
sum(width(gb_P))
(gb_N <- coa$Bar_Osa)
sum(width(gb_N))
(ov <- subsetByOverlaps(gb_P, gb_N, type = "within"))
(jaccard <- sum(width(ov)) / sum(width(reduce(c(gb_P, gb_N)))))

gb_P <- gb_P[gb_P$geneNumber > 1]
gb_P
sum(gb_P$geneNumber)
(valid <- subsetByOverlaps(gb_P, gb_N, type = "within"))
sum(valid$geneNumber)
sum(width(valid))
```

Question: what does interrupt the colinearity of nucleotide regions in gene-centric
colinear regions ?

# HOX genes

## Hox 4

Appears to be duplicated in Bar so missing from HOG `N19.HOG0000192` in that
genome.

```{r Hox4, dev=c("svg", "pdf", "png"), fig.ext=c("svg", "pdf", "png")}
sapply(orthoPairs[1:15], \(gb) {
  x <- gb |> plyranges::filter(HOG == "N19.HOG0000192")
  if (length(x) == 0) return(NULL)
  x})

Hox4 <- orthoPairs$Oki_Osa |> plyranges::filter(HOG == "N19.HOG0000192")
Hox4_1e4 <- GBreaks(target = granges(Hox4) + 1e4, query = Hox4$query + 1e4)
Hox4_4e4 <- GBreaks(target = granges(Hox4) + 4e4, query = Hox4$query + 4e4)
Hox4_1e5 <- GBreaks(target = granges(Hox4) + 1e5, query = Hox4$query + 1e5)

subsetByOverlaps(coa$Oki_Osa, Hox4_1e4) |> plotApairOfChrs("chr2", xlim = gb2xlim(Hox4_1e4))
subsetByOverlaps(coa$Oki_Osa, Hox4_4e4) |> plotApairOfChrs("chr2", xlim = gb2xlim(Hox4_4e4))
subsetByOverlaps(coa$Oki_Osa, Hox4_1e5) |> plotApairOfChrs("chr2", xlim = gb2xlim(Hox4_1e5))

## Genes
Hox4_4e4.genes <- transcripts$OKI2018.I69 |> subsetByOverlaps(Hox4_4e4 |> range())
mids <- Hox4_4e4.genes |> gr2dna_seg() |> dplyr::mutate(mid = (start + end) / 2) |> dplyr::pull(mid)
text <- Hox4_4e4.genes$tx_name |> as.character()
annot <- genoPlotR::annotation(x1=start(Hox4_4e4.genes), x2=end(Hox4_4e4.genes), text=text, rot=30)
gbs$Oki_Osa |> plotApairOfChrs("chr2", xlim = gb2xlim(Hox4_4e4), annotations = annot)
```

<details>
<summary>Click to see details on where the non-plotted alignments go.</summary>
```{r}
subsetByOverlaps(gbs$Oki_Osa, granges(Hox4_4e4)) |> sort(i=T)  |> data.frame()
subsetByOverlaps(swap(gbs$Oki_Osa), granges(swap(Hox4_4e4))) |> sort(i=T)  |> data.frame()
```
<br/>

## Hox 1

HOG `N19.HOG0000193`.

```{r Hox1, dev=c("svg", "pdf", "png"), fig.ext=c("svg", "pdf", "png")}
sapply(orthoPairs[1:15], \(gb) {
  x <- gb |> plyranges::filter(HOG == "N19.HOG0000193")
  if (length(x) == 0) return(NULL)
  x})

Hox1 <- orthoPairs$Oki_Osa |> plyranges::filter(HOG == "N19.HOG0000193")
Hox1_1e4 <- GBreaks(target = granges(Hox1) + 1e4, query = Hox1$query + 1e4)
Hox1_4e4 <- GBreaks(target = granges(Hox1) + 4e4, query = Hox1$query + 4e4)
Hox1_1e5 <- GBreaks(target = granges(Hox1) + 1e5, query = Hox1$query + 1e5)

subsetByOverlaps(coa$Oki_Osa, Hox1_1e4) |> plotApairOfChrs("chr2", xlim = gb2xlim(Hox1_1e4))
subsetByOverlaps(coa$Oki_Osa, Hox1_4e4) |> plotApairOfChrs("chr2", xlim = gb2xlim(Hox1_4e4))
subsetByOverlaps(coa$Oki_Osa, Hox1_1e5) |> plotApairOfChrs("chr2", xlim = gb2xlim(Hox1_1e5))

## Genes
Hox1_4e4.genes <- transcripts$OKI2018.I69 |> subsetByOverlaps(Hox1_4e4 |> range())
mids <- Hox1_4e4.genes |> gr2dna_seg() |> dplyr::mutate(mid = (start + end) / 2) |> dplyr::pull(mid)
text <- Hox1_4e4.genes$tx_name |> as.character()
annot <- genoPlotR::annotation(x1=start(Hox1_4e4.genes), x2=end(Hox1_4e4.genes), text=text, rot=30)
gbs$Oki_Osa |> plotApairOfChrs("chr2", xlim = gb2xlim(Hox1_4e4), annotations = annot)
```

<details>
<summary>Click to see details on where the non-plotted alignments go.</summary>
```{r}
subsetByOverlaps(gbs$Oki_Osa, granges(Hox1_4e4)) |> sort(i=T)  |> data.frame()
subsetByOverlaps(swap(gbs$Oki_Osa), granges(swap(Hox1_4e4))) |> sort(i=T)  |> data.frame()
```
<br/>

# Ancestral states

Prototype 1

In the concept case below, B has moved in the North Atlantic clade.

 - Oki: A-B-C
 - Osa: A-B-C
 - Bar:  A-C, and B can be found somewhere else
 
As we work on alignment pairs, this translates to:

 - Oki_Osa: A-B-C
 - Oki_Bar: A, B, C
 
To find such cases I search for Oki-Bar orthoblock breakpoints that fall within
an Oki-Osa orthoblock.

```{r}
reIndex <- \(gb) {names(gb) <- seq_along(gb) ; gb}
barBreaks <- sapply(orthoBlocks_one2oneInOiks, get_bps, direction = "mid") |> SimpleList()


ROIs <- SimpleList()
findROIs <- function(g1, g2, g3) {
  pair1_2 <- paste(g1, sep = '_', g2)
  pair1_3 <- paste(g1, sep = '_', g3)
  gb <- orthoBlocks_one2oneInOiks[[pair1_2]] |>
    reIndex() |>
    subsetByOverlaps(barBreaks[[pair1_3]]) |>
    subset(geneNumber > 2)
  # Drop columns to ease browsing on single lines.
  NULL -> gb$dNdS_GUIDANCE2 -> gb$dNdS_HmmCleaner -> gb$dNdS_PRANK
  gb
}
ROIs$Oki_Osa_Bar <- findROIs("Oki", "Osa", "Bar")
ROIs$Oki_Bar_Osa <- findROIs("Oki", "Bar", "Osa")
ROIs$Oki_Aom_Nor <- findROIs("Oki", "Aom", "Nor")

findGene <- function(gb, gene) {
  if(is.null(gb$geneNames)) {
    ids <- gb$tx_name
    index <- gb$tx_name %in% gene
  } else {
    ids <- gb$geneNames
    index <- any(ids %in% gene)
  }
  gb[index]
}

# Genes of Interest

(GoI1 <- head(ROIs$Oki_Osa_Bar$geneNames, 1) |> unlist())
GoI2 <- c("g1205.t1", "g1208.t1", "g1209.t1", "g1210.t1") # To provide context

# Exploring the region

orthoBlocks$Oki_Osa |> findGene(c(GoI1, GoI2)) # g1206.t1 g1207.t1 g1208.t1 g1211.t1 are in chr1:4573346-4588029 | Chr1:402525-416983  
orthoPairs $Oki_Osa |> findGene(c(GoI1, GoI2)) |> as.data.frame() # Individual coordinates of the genes
orthoBlocks$Oki_Bar |> findGene(c(GoI1, GoI2)) # g1205.t1 g1206.t1 g1207.t1 g1208.t1 g1211.t1 are in chr1 4571907-4588029 | Chr1:582810-2680665
orthoPairs $Oki_Bar |> findGene(c(GoI1, GoI2)) |> as.data.frame() # Individual coordinates of the genes
orthoBlocks$Bar_Oki |> subsetByOverlaps(GRanges("Chr1:2669327-2680665")) |> swap()  # Let's forget about g1205.t1
orthoBlocks$Bar_Oki |> subsetByOverlaps(GRanges("Chr1:2669327-2680665")) |> swap() |> cleanGaps() |> width()
```

```
Oki         Osa       Bar  
g1206.t1    g96.t1    g651.t1
g1207.t1    g95.t1    g650.t1
g1208.t1    g94.t1    g652.t1
g1211.t1    g92.t1    g654.t1 
```

```{r}
### Between "g1207.t1" and "g1208.t1", there is a repeat region, where the Bar genome broke, but that is still in the Osa genome (bri)

unal$Oki_Osa |> subsetByOverlaps(GRanges("chr1", (4577337 + 4577995)/2)) # between g1207.t1 and g1208.t1 on Oki
unal$Osa_Oki |> subsetByOverlaps(GRanges("Chr1", ( 409953 + 410741 )/2)) # between g95.t1 and g94.t1 on Osa
# Or just:

(BP1_Oki_Osa <- bri$Oki_Osa |> subsetByOverlaps(GRanges("chr1", (4577337 + 4577995)/2))) # between g1207.t1 and g1208.t1 on Oki


# Now on Bar:
gbs$Bar_Oki |> reIndex()|> subsetByOverlaps(GRanges("Chr1", (2674502 + 2675030)/2)) # between g651.t1 and  g652.t1 on Bar
coa$Bar_Oki |> reIndex()|> subsetByOverlaps(GRanges("Chr1", (2674502 + 2675030)/2)) # between g651.t1 and  g652.t1 on Bar

(BP1_Bar <- unal$Bar_Oki |> subsetByOverlaps(GRanges("Chr1", (2674538 + 2674688)/2))) # between g651.t1 and  g652.t1 on Bar according to gbs or coa

# Nothing noticeable on either strand
pairwiseAlignment(type ="local", BP1_Oki_Osa |> plyranges::mutate(strand = '-'))
pairwiseAlignment(type ="local", BP1_Oki_Osa |> plyranges::mutate(strand = '+'))
pairwiseAlignment(type ="local", BP1_Oki_Osa $query, BP1_Bar)
pairwiseAlignment(type ="global", BP1_Oki_Osa $query, BP1_Bar  |> plyranges::mutate(strand = '-'))
 
oP_one2oneInOiks_bridges$Oki_Osa |> subsetByOverlaps(GRanges("chr1", (4577337 + 4577995)/2))
```

I can also search for orthologs that are marked "Col" in Oki_Osa and "Tra"
in Osa_Bar.

# Session information

```{r session_information}
sessionInfo()
```
