---
title: "Orthogroup syntenies"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEncoding{UTF-8}
  %\VignetteIndexEntry{Orthogroup syntenies}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

Load packages and data
======================

See `?OikScrambling:::loadAllGenomes`, `?OikScrambling:::loadAllTranscriptsGR`,
and `vignette("LoadGenomicBreaks", package = "OikScrambling")` for how the
different objects are prepared.

```{r load_packages_and_data}
library('OikScrambling')   |> suppressPackageStartupMessages()
library("ggpubr")
library("SummarizedExperiment")
(genomes <- OikScrambling:::loadAllGenomes())
(transcripts <- OikScrambling:::loadAllTranscriptsGR() |> suppressWarnings())
(load("BreakPoints.Rdata"))
```

Orthogroups
-----------

Load Orthogroups for _Oikopleura_ from the `BreakpointsData` package with the
`GenomicBreaks::load_one_to_ones_SE()` function.  Original file is in
`/bucket/LuscombeU/common/Breakpoints/Orthologues/selTun+Apps+Amph+Vert_lp_100clstr_blast/OrthoFinder/Results_Oct07/Phylogenetic_Hierarchical_Orthogroups/N19.tsv`.
See `news(package = "BreakpointsData")` for inspecting changes in more details.

```{r load_one_to_ones}
# Create a data frame that maps the original species names in the OrthoFinder 
# output to a set of new names that are easier to read.
species_name_map = data.frame(
  old_names=c("AOM-5-5f.prot.longest.fa_1", "Bar2_p4.Flye.prot.longest.fa_1", "KUM-M3-7f.prot.longest.fa_1", "OKI2018_I69.v2.prot.longest.fa_1", "OSKA2016v1.9.prot.longest.fa_1", "OdB3.v1.0.prot.fa_1.nohaplo"),
  new_names=c("Aom", "Bar", "Kum", "Oki", "Osa", "Nor")
)

load_one_to_ones_SE <- function(file, species_name_map) {
  # Read table
  pho <- read.delim(file, check.names = FALSE)
  
  # Remove all-NA columns
  pho <- pho[,sapply(pho, \(col) ! all(is.na(col)))]
  
  # Use the species name map to rename columns here.
  old_names <- colnames(pho)[4:ncol(pho)]
  new_names <- species_name_map[match(old_names, species_name_map$old_names),]$new_names
  colnames(pho)[4:ncol(pho)] <- new_names
  
  # Convert to SummarizedExperiment
  se <- SummarizedExperiment::SummarizedExperiment(
    assays = list(txs = pho[,-(1:3)]),
    rowData = DataFrame(pho[1:3])
  )

  assay(se, "txLists", withDimnames=FALSE) <- sapply(assay(se, 'txs'),     strsplit, split = ", ")
  assay(se, "txCount", withDimnames=FALSE) <- sapply(DataFrame(assay(se, 'txLists')), \(x) sapply(x, length))  # Not sure why it only works when putting a DataFrame at the middle
  assay(se, "txLists")[(assay(se, "txCount")) == 0] <- NA_character_
  
  rowData(se)$one2ones    <- rowSums(as.matrix(assay(se, "txCount")) == 1) == ncol(se)
  rowData(se)$anyMissing  <- rowSums(as.matrix(assay(se, "txCount")) == 0) > 0
  rowData(se)$anyDup      <- rowSums(as.matrix(assay(se, "txCount"))  > 1) > 0
  
  rowData(se)$txNames     <- apply(assay(se, "txLists"), 1, \(row) {
    row               |>  # Take a row from a matrix, a data.frame or a DataFrame
      as.list()       |>  # It is already list of character vectors, except for DataFrame subsets, which have to be coerced
      unlist()        |>  # Flatten it.  That is: `list(c("A", "B"), "C")` becomes `c("A", "B", "C")`
      unname()            # Remove element names
  })
  rowData(se)$txNames     <- sapply(rowData(se)$txNames, \(x) x[!is.na(x)])
  rowData(se)$txNames     <- CharacterList(rowData(se)$txNames)     # Convert to `CharacterList` for more comfortable display
  # rowData(se)$txNamesString <- unstrsplit(rowData(se)$txNames, ",") # If you would want it as a string...
  se
}

se <-  load_one_to_ones_SE(system.file("extdata/OrthoFinder/N19.tsv", package = "BreakpointsData"), species_name_map=species_name_map)

```

Flagging orthogroups by inferred homology class
-----------------------------------------------
While single-copy orthologues are arguably the most important component of the genome for between-species comparisons, it is also useful to know - or at least guess - at the other kinds of homologous relations that may exist within a gene family. This can identify, for example, clade-specific gene family expansions or clade-specific gene family deletions.

In the following section, I flag different types of homology by inferring them from OrthoFinder hierarchical orthogroup (HOG) counts.

To flag orthogroups, we need a count matrix. Extract this from the `SummarizedExperiment` object `se` with `assay()`.

```{r orthoflagging}
se_m <- assay(se, 'txCount')
rownames(se_m) <- rowData(se)$HOG

# Create a list of clades. Each clade contains a vector of species names (the "new_names" of the next
# data frame. The clades can overlap.
clades=list("Oki_Kum"=c("Kum","Oki"), "Osa_Aom"=c("Osa","Aom"), "Bar_Nor"=c("Bar","Nor"), "Northern"=c("Osa","Aom","Bar","Nor"))

# clade_list: a named list where each list contains a vector of species.
# expansion_reconciliation: How to reconcile situations where more than 1 clade shows an expansion. 
#                           There are only two options: "largest_clade" and "mean_count".
#                           "largest_clade" flags it to the clade with the most species
#                           "mean_count" flags it to the clade with the highest mean count
# deletion_reconciliation:  As above. "largest_clade" makes the most sense most of the time.
#                           For now, no other options are supported.
orthoflags <- flagAllPHO(se_m, clade_list=clades, expansion_reconciliation = "largest_clade", deletion_reconciliation="largest_clade")
# The function warns whenever there is an inconsistency with the flag. You can inspect these:
# warnings()
# If you want to see too many warnings, you can also use deletion_warnings=T in the flagAllPHO function.
```

You can then summarize the flags as follows:

```{r summarizing_orthoflags}
apply(orthoflags[,7:20], 2, function(x) table(unlist(x)))
```

The `orthoflags` object yields a matrix with one row per orthogroup, the count columns of the HOG table, and most importantly, a set of orthogroup annotations based on the counts of every species and clade. 

These annotations are not mutually exclusive. Consider the following:
```{r summarizing_orthoflags_2}
orthoflags[15,]
```

You can have a species-specific expansion (i.e., Okinawa) at the same time as a clade-specific expansion (i.e., Oki/Kum). 

Here there is also a non-clade-specific deletion. The Osaka-Aomori clade is wholly deleted, while Bar-Nor is not.

```{r summarizing_orthoflags_3}
# Take a look at the distribution of different species flags. 
ggplot(orthoflags) +
  aes(x=reorder(unlist(expansion_reconciled), unlist(expansion_reconciled), function(x) length(x))) + geom_bar(stat="count", position="dodge") +
  facet_wrap(~ present_in_all_spp, scales = 'free') +
  xlab(NULL) +
  coord_flip() +
  ggtitle("Orthogroups by clade-specific HOG expansions (TRUE=present in all spp.)")

ggplot(orthoflags) +
  aes(x=reorder(unlist(deletion_reconciled), unlist(deletion_reconciled), function(x) length(x))) + geom_bar(stat="count", position="dodge") +
  xlab(NULL) +
  coord_flip() +
  ggtitle("Orthogroups by clade-specific HOG deletions")

ggplot(orthoflags) +
  aes(x=reorder(unlist(expansion_species_specific), unlist(expansion_species_specific), function(x) length(x))) + geom_bar(stat="count", position="dodge") +
  facet_wrap(~ present_in_all_spp, scales = 'free' ) +
  xlab(NULL) +
  coord_flip() +
  ggtitle("Orthogroups by species-specific HOG expansions (TRUE=present in all spp.)")


ggplot(orthoflags) +
  aes(x=reorder(unlist(deletion_species_specific), unlist(deletion_species_specific), function(x) length(x))) + geom_bar(stat="count", position="dodge") +
  xlab(NULL) +
  coord_flip() +
  ggtitle("Orthogroups by species-specific HOG deletions")
```

In order to get these orthogroup annotations into the `GBreaks` object later, we add them as metadata columns to the `transcripts` object from above. 

```{r flagging_orthogroups_3}
# This function takes the output of `flagAllPHO` and parses it into a data frame
# suitable for glomming with addMetadataToGRanges.
orthoflagsToDF <- function(orthoflags, species) {
  annotations_per_row <- apply(orthoflags, 1, function(row) {
    row <- as.list(row)
    sp_transcripts <- row[[species]]
    transcript_ids <- unname(unlist(strsplit(x = sp_transcripts, ",")))
    hog <- row[["hog"]]
    og <- row[["og"]]
    gene_tree_parent_clade <- row[["gene_tree_parent_clade"]]
    hog_transcripts <- row[["transcripts"]]
    hog_taxa <- row[["taxa"]]
    hog_taxa_count <- row[["taxa_count"]]
    hog_flag <- row[["flag"]]
    hog_presence <- row[["present_in_all_species"]]
    if(!any(is.na(transcript_ids))){
      annotation <- lapply(transcript_ids, function(tx) {
        list(tx_name=tx, hog=hog, og=og, gene_tree_parent_clade=gene_tree_parent_clade, hog_transcripts=hog_transcripts, hog_taxa=hog_taxa, hog_taxa_count=hog_taxa_count, hog_flag=hog_flag, hog_presence=hog_presence)
      })
      annotation <- do.call(rbind, annotation)
    }
  })
  annotations <- as.data.frame(do.call(rbind, annotations_per_row))
  annotations
}

orthoflagsDF <- SimpleList()
orthoflagsDF$Oki <- orthoflagsToDF(orthoflags=orthoflags, species="Oki")
orthoflagsDF$Osa <- orthoflagsToDF(orthoflags=orthoflags, species="Osa")
orthoflagsDF$Bar <- orthoflagsToDF(orthoflags=orthoflags, species="Bar")
orthoflagsDF$Kum <- orthoflagsToDF(orthoflags=orthoflags, species="Kum")
orthoflagsDF$Aom <- orthoflagsToDF(orthoflags=orthoflags, species="Aom")
orthoflagsDF$Nor <- orthoflagsToDF(orthoflags=orthoflags, species="Nor")
```

Note that the "full" transcript names are used in the OrthoFinder output, whereas parsed names are used in the `transcript` object. Let's fix the names to make them parseable.

```{r adding_simple_names}
orthoflagsDF$Oki$tx_name_simple = unname(sapply(orthoflagsDF$Oki$tx_name, function(s) paste(unlist(strsplit(s, '\\.'))[3:4], collapse='.')))
orthoflagsDF$Osa$tx_name_simple = unname(sapply(orthoflagsDF$Osa$tx_name, function(s) paste(unlist(strsplit(s, '\\.'))[3:4], collapse='.')))
orthoflagsDF$Bar$tx_name_simple = unname(sapply(orthoflagsDF$Bar$tx_name, function(s) paste(unlist(strsplit(s, '\\.'))[2:3], collapse='.')))
orthoflagsDF$Kum$tx_name_simple = unname(sapply(orthoflagsDF$Kum$tx_name, function(s) paste(unlist(strsplit(s, '\\.'))[2:3], collapse='.')))
orthoflagsDF$Aom$tx_name_simple = unname(sapply(orthoflagsDF$Aom$tx_name, function(s) paste(unlist(strsplit(s, '\\.'))[2:3], collapse='.')))
orthoflagsDF$Nor$tx_name_simple = unname(sapply(orthoflagsDF$Nor$tx_name, function(s) paste(unlist(strsplit(s, '\\.'))[2], collapse='.')))
```

The `orthoflagsDF` object contains all the same information as the `orthoflags` object, but is in a slightly more convenient formatting for gluing on to the transcript annotations later. We do so here:

```{r gluing_orthoflags}
transcripts <- sapply(names(transcripts), function(sp){
  stitched <- OikScrambling:::addMetadataToGRanges(gr=transcripts[[sp]], df=orthoflagsDF[[sp]], gr_key='tx_name', df_key='tx_name_simple', df_col_name = 'hog_taxa', rename_meta = 'HOG_taxa')
  stitched <- OikScrambling:::addMetadataToGRanges(gr=stitched, df=orthoflagsDF[[sp]], gr_key='tx_name', df_key='tx_name_simple', df_col_name = 'hog_taxa_count', rename_meta = 'HOG_taxa_counts')
  stitched <- OikScrambling:::addMetadataToGRanges(gr=stitched, df=orthoflagsDF[[sp]], gr_key='tx_name', df_key='tx_name_simple', df_col_name = 'hog_flag', rename_meta = 'HOG_flag')
  stitched <- OikScrambling:::addMetadataToGRanges(gr=stitched, df=orthoflagsDF[[sp]], gr_key='tx_name', df_key='tx_name_simple', df_col_name = 'hog_presence', rename_meta = 'HOG_presence')
  stitched
})
transcripts |> SimpleList()
```

```{r load_orthogroups}
# Example for loading all orthogroups:
OikScrambling:::load_one_to_ones(system.file("extdata/OrthoFinder/N19.tsv", package = "BreakpointsData"))

# Example for loading a pair
OikScrambling:::load_one_to_ones( system.file("extdata/OrthoFinder/N19.tsv", package = "BreakpointsData")
                , c("Bar2_p4.Flye.prot.longest.fa_1", "OSKA2016v1.9.prot.longest.fa_1"))
```


Prepare GBreak objects
======================

```{r Bar_Osk}
orthoPairToGBreaks <- function(name1, name2, annot1, annot2, treeName="N19") {
  orthoPairs <- OikScrambling:::load_one_to_ones(
    system.file(paste0("extdata/OrthoFinder/",treeName,".tsv"), package = "BreakpointsData"),
    c(name1, name2))

  IDs2GRanges <- function (IDs, annot) {
    prefix <- Biobase::lcPrefix(IDs)                  # Guess prefix in transcript IDs from HOG files
    not_prefix <- Biobase::lcPrefix(annot$tx_name)    # Remove trailing characters that are part of the name
    not_prefix <- paste0(not_prefix,"$")              # Anchor to end of the string
    prefix <- sub(not_prefix, "", prefix)             # Finalise prefix
    IDs <- sub(prefix, "", IDs)                       # Remove prefix from IDS
    names(annot) <- annot$tx_name                     # Store transcript name in names slot
    gr <- annot[IDs]                                  # Sort by ID
    strand(gr) <- "*"                                 # Make strandless
    gr                                                # Return the object
  }
  
  gb       <- IDs2GRanges(orthoPairs[,name1], annot1)
  gb$query <- IDs2GRanges(orthoPairs[,name2], annot2)
  gb <- GenomicBreaks:::GBreaks(gb)
  sort(gb)
}

orthoPairToGBreaks_all_Oiks <- function(treeName) {
  orthoPairs <- SimpleList()
  orthoPairs$Oki_Osa <- orthoPairToGBreaks("OKI2018_I69.v2.prot.longest.fa_1", "OSKA2016v1.9.prot.longest.fa_1",   transcripts$Oki, transcripts$Osa, treeName)
  orthoPairs$Oki_Bar <- orthoPairToGBreaks("OKI2018_I69.v2.prot.longest.fa_1", "Bar2_p4.Flye.prot.longest.fa_1",   transcripts$Oki, transcripts$Bar, treeName)
  orthoPairs$Oki_Kum <- orthoPairToGBreaks("OKI2018_I69.v2.prot.longest.fa_1", "KUM-M3-7f.prot.longest.fa_1",      transcripts$Oki, transcripts$Kum, treeName)
  orthoPairs$Oki_Aom <- orthoPairToGBreaks("OKI2018_I69.v2.prot.longest.fa_1", "AOM-5-5f.prot.longest.fa_1",       transcripts$Oki, transcripts$Aom, treeName)
  orthoPairs$Oki_Nor <- orthoPairToGBreaks("OKI2018_I69.v2.prot.longest.fa_1", "OdB3.v1.0.prot.fa_1.nohaplo",      transcripts$Oki, transcripts$Nor, treeName)
  
  orthoPairs$Osa_Bar <- orthoPairToGBreaks("OSKA2016v1.9.prot.longest.fa_1",   "Bar2_p4.Flye.prot.longest.fa_1",   transcripts$Osa, transcripts$Bar, treeName)
  orthoPairs$Osa_Oki <- orthoPairToGBreaks("OSKA2016v1.9.prot.longest.fa_1",   "OKI2018_I69.v2.prot.longest.fa_1", transcripts$Osa, transcripts$Oki, treeName)
  orthoPairs$Osa_Kum <- orthoPairToGBreaks("OSKA2016v1.9.prot.longest.fa_1",   "KUM-M3-7f.prot.longest.fa_1",      transcripts$Osa, transcripts$Kum, treeName)
  orthoPairs$Osa_Aom <- orthoPairToGBreaks("OSKA2016v1.9.prot.longest.fa_1",   "AOM-5-5f.prot.longest.fa_1",       transcripts$Osa, transcripts$Aom, treeName)
  orthoPairs$Osa_Nor <- orthoPairToGBreaks("OSKA2016v1.9.prot.longest.fa_1",   "OdB3.v1.0.prot.fa_1.nohaplo",      transcripts$Osa, transcripts$Nor, treeName)
  
  orthoPairs$Bar_Osa <- orthoPairToGBreaks("Bar2_p4.Flye.prot.longest.fa_1",   "OSKA2016v1.9.prot.longest.fa_1",   transcripts$Bar, transcripts$Osa, treeName)
  orthoPairs$Bar_Oki <- orthoPairToGBreaks("Bar2_p4.Flye.prot.longest.fa_1",   "OKI2018_I69.v2.prot.longest.fa_1", transcripts$Bar, transcripts$Oki, treeName)
  orthoPairs$Bar_Kum <- orthoPairToGBreaks("Bar2_p4.Flye.prot.longest.fa_1",   "KUM-M3-7f.prot.longest.fa_1",      transcripts$Bar, transcripts$Kum, treeName)
  orthoPairs$Bar_Aom <- orthoPairToGBreaks("Bar2_p4.Flye.prot.longest.fa_1",   "AOM-5-5f.prot.longest.fa_1",       transcripts$Bar, transcripts$Aom, treeName)
  orthoPairs$Bar_Nor <- orthoPairToGBreaks("Bar2_p4.Flye.prot.longest.fa_1",   "OdB3.v1.0.prot.fa_1.nohaplo",      transcripts$Bar, transcripts$Nor, treeName)
  
  orthoPairs[ 1:5 ] <- sapply(orthoPairs[ 1:5 ],  flagLongShort, longShort$Oki)
  orthoPairs[ 6:10] <- sapply(orthoPairs[ 6:10],  flagLongShort, longShort$Osa)
  orthoPairs[11:15] <- sapply(orthoPairs[11:15],  flagLongShort, longShort$Bar)
  
  orthoPairs
}

orthoPairs         <- orthoPairToGBreaks_all_Oiks("N19")
orthoPairs$Ply_Ros <- orthoPairToGBreaks("C_int_P.prot.longest.fa_1", "C_int_R.prot.longest.fa_1"
                                        , transcripts$Ply, transcripts$Ros, treeName="N20")

# Same as above but using the same core orthogroups for all species.
orthoPairs_core         <- orthoPairToGBreaks_all_Oiks("N3")
orthoPairs_core$Ply_Ros <- orthoPairToGBreaks("C_int_P.prot.longest.fa_1", "C_int_R.prot.longest.fa_1"
                                             , transcripts$Ply, transcripts$Ros, treeName="N3")

sapply(orthoPairs, length)
sapply(orthoPairs_core, length)
```

Problem: some annotations overlap
---------------------------------

```{r fix_Bar_Osk}
transcripts$Bar |> length()
transcripts$Bar |> reduce(min = 0) |> length()

flagOverlaps <- function(gr) {
  # Find overlaps
  ov <- findOverlaps(gr)
  # Index of self hits in the gr object
  idx <- queryHits(ov[!isSelfHit(ov)])
  # Convert to Boolean indexing the gr object
  seq_along(gr) %in% idx
}

transcripts$Bar[flagOverlaps(transcripts$Bar)]

# Show examples
orthoPairs$Oki_Osa[flagOverlaps(orthoPairs$Oki_Osa)]
orthoPairs$Oki_Osa$query[flagOverlaps(orthoPairs$Oki_Osa$query)]

# Remove and show how much was removed

orthoPairsFiltered <- sapply(orthoPairs, function(gb) {
  gb <- gb[!flagOverlaps(gb)]
  gb <- gb[!flagOverlaps(gb$query)]
  gb
}) |> SimpleList()

orthoPairsFiltered_core <- sapply(orthoPairs_core, function(gb) {
  gb <- gb[!flagOverlaps(gb)]
  gb <- gb[!flagOverlaps(gb$query)]
  gb
}) |> SimpleList()

sapply(orthoPairs, length) - sapply(orthoPairsFiltered, length)
sapply(orthoPairs_core, length) - sapply(orthoPairsFiltered_core, length)
```

Exploring patterns in the pairwise objects
------------------------------------------

Coalesce syntenic blocks and annotate them
------------------------------------------

```{r coalesce}
coalOrtho <- function(gb) {
  # Coalesce
  coal <- coalesce_contigs(gb)
  
  # Map annotations to the coalesced blocks
  ov <- findOverlaps(coal, gb)
  
  # Extract gene names mapped to each blocks
  coal$geneNames <- CharacterList(split(names(gb)[subjectHits(ov)], queryHits(ov))) |> unname()
  # We can use the `ov` object for query ranges as well because of the way `coal` was constructed.
  coal$query$geneNames <- CharacterList(split(names(gb$query)[subjectHits(ov)], queryHits(ov))) |> unname()
  
  # Extract dNdS values
  coal$dNdS_GUIDANCE2  <- NumericList(split(gb$dNdS_GUIDANCE2 [subjectHits(ov)], queryHits(ov)))
  coal$dNdS_HmmCleaner <- NumericList(split(gb$dNdS_HmmCleaner[subjectHits(ov)], queryHits(ov)))
  coal$dNdS_PRANK      <- NumericList(split(gb$dNdS_PRANK     [subjectHits(ov)], queryHits(ov)))
  # We just copy dNdS values to query ranges because they are the same.
  coal$query$dNdS_GUIDANCE2  <- coal$dNdS_GUIDANCE2
  coal$query$dNdS_HmmCleaner <- coal$dNdS_HmmCleaner
  coal$query$dNdS_PRANK      <- coal$dNdS_PRANK
  
  # Add orthoflags. Since the flags are assigned to orthogroups, the flags are the same
  # for all single-copy orthologues.
  coal$HOG_taxa <- CharacterList(split(gb$HOG_taxa [subjectHits(ov)], queryHits(ov))) |> unname()
  coal$HOG_taxa_counts <- CharacterList(split(gb$HOG_taxa_counts [subjectHits(ov)], queryHits(ov))) |> unname()
  coal$HOG_flag <- CharacterList(split(gb$HOG_flag [subjectHits(ov)], queryHits(ov))) |> unname()
  coal$HOG_presence <- CharacterList(split(gb$HOG_presence [subjectHits(ov)], queryHits(ov))) |> unname()

  # Count genes per syntenic block
  coal$geneNumber <- sapply(coal$geneNames, length)
  
  coal
}

orthoBlocks <- sapply(orthoPairsFiltered[1:15], coalOrtho) |> SimpleList()
orthoBlocks$Ply_Ros <- coalesce_contigs(orthoPairsFiltered$Ply_Ros)
orthoBlocks[ 1:5 ] <- sapply(orthoBlocks[ 1:5 ],  flagLongShort, longShort$Oki)
orthoBlocks[ 6:10] <- sapply(orthoBlocks[ 6:10],  flagLongShort, longShort$Osa)
orthoBlocks[11:15] <- sapply(orthoBlocks[11:15],  flagLongShort, longShort$Bar)

orthoBlocks_core <- sapply(orthoPairsFiltered_core[1:15], coalOrtho) |> SimpleList()
orthoBlocks_core$Ply_Ros <- coalesce_contigs(orthoPairsFiltered_core$Ply_Ros)
orthoBlocks_core[ 1:5 ] <- sapply(orthoBlocks_core[ 1:5 ],  flagLongShort, longShort$Oki)
orthoBlocks_core[ 6:10] <- sapply(orthoBlocks_core[ 6:10],  flagLongShort, longShort$Osa)
orthoBlocks_core[11:15] <- sapply(orthoBlocks_core[11:15],  flagLongShort, longShort$Bar)

sapply(orthoBlocks, length)
sapply(orthoBlocks_core, length)

```

Quick overview of the results
=============================

Size distribution of the blocks
-------------------------------

```{r quick_overview}
stem(orthoBlocks$Oki_Osa$geneNumber)
table(orthoBlocks$Oki_Osa$geneNumber)
orthoBlocks$Oki_Osa[order(orthoBlocks$Oki_Osa$geneNumber)] |> tail(11)

stem(orthoBlocks$Oki_Kum$geneNumber)
table(orthoBlocks$Oki_Kum$geneNumber)
orthoBlocks$Oki_Kum[order(orthoBlocks$Oki_Kum$geneNumber)] |> tail(11)
```

Gene Order Conservation is smaller in short arms
------------------------------------------------

```{r GOC}
orthoBlocks_LSnoNA <- sapply(orthoBlocks[1:15], function(gb) gb[!is.na(gb$Arm)]) |> SimpleList()
sapply(orthoBlocks_LSnoNA, length)

df <- sapply(orthoBlocks_LSnoNA,
             function(gb) tapply(gb, paste(seqnames(gb), gb$Arm), GOC))

apply(df, 2, \(x) {
  tst <- t.test(x[c(1,3,5)], x[c(2,4,6)])
  c(pval=tst$p.value, mx=tst$estimate[1], my=tst$estimate[2])
}) 
```

Fraction of the genome covered or syntenic
------------------------------------------

```{r fraction_aligned}
uncov  <- BiocParallel::bplapply(orthoPairsFiltered, cleanGaps) |> SimpleList()
unsyn  <- BiocParallel::bplapply(orthoBlocks,        cleanGaps) |> SimpleList()

  covered_tot    <- sapply(orthoPairsFiltered,   \(x) sum(width(x)))
  syntenic_tot   <- sapply(orthoBlocks,          \(x) sum(width(x)))
uncovered_tot    <- sapply(uncov,                \(x) sum(width(x)))
unsyntenic_tot   <- sapply(unsyn,                \(x) sum(width(x)))

(syn_summary <- cbind(
  covered_frac   = covered_tot   / ( covered_tot   + uncovered_tot ) * 100,
  orthogenes_n   = sapply(orthoPairsFiltered, length),
  syntenic_frac  = syntenic_tot  / ( syntenic_tot  + unsyntenic_tot ) * 100,
  syntenic_reg   = sapply(orthoBlocks, length)
 )|> as.data.frame())

sapply(syn_summary, \(x) tapply(x, row.names(syn_summary) |> OikScrambling:::compDistance(), mean))   |> round(1)
sapply(syn_summary, \(x) tapply(x, row.names(syn_summary) |> OikScrambling:::compDistance(), median)) |> round(1)
sapply(syn_summary, \(x) tapply(x, row.names(syn_summary) |> OikScrambling:::compDistance(), sd))     |> round(1)
```

Unfortunately, there are not enough transcripts from Ciona that are part of the
pan-tunicate orthogroup set, which makes the comparison difficult between
Oikopleura and Ciona…

```{r fraction_aligned_core}
uncov  <- BiocParallel::bplapply(orthoPairsFiltered_core, cleanGaps) |> SimpleList()
unsyn  <- BiocParallel::bplapply(orthoBlocks_core,        cleanGaps) |> SimpleList()

  covered_tot    <- sapply(orthoPairsFiltered_core,   \(x) sum(width(x)))
  syntenic_tot   <- sapply(orthoBlocks_core,          \(x) sum(width(x)))
uncovered_tot    <- sapply(uncov,                     \(x) sum(width(x)))
unsyntenic_tot   <- sapply(unsyn,                     \(x) sum(width(x)))

(syn_summary_core <- cbind(
  covered_frac   = covered_tot   / ( covered_tot   + uncovered_tot ) * 100,
  orthogenes_n   = sapply(orthoPairsFiltered_core, length),
  syntenic_frac  = syntenic_tot  / ( syntenic_tot  + unsyntenic_tot ) * 100,
  syntenic_reg   = sapply(orthoBlocks_core, length)
 )|> as.data.frame())

sapply(syn_summary_core, \(x) tapply(x, row.names(syn_summary_core) |> OikScrambling:::compDistance(), mean))   |> round(1)
sapply(syn_summary_core, \(x) tapply(x, row.names(syn_summary_core) |> OikScrambling:::compDistance(), median)) |> round(1)
sapply(syn_summary_core, \(x) tapply(x, row.names(syn_summary_core) |> OikScrambling:::compDistance(), sd))     |> round(1)
```

Agreement with nucleotide alignments
------------------------------------

```{r DNA_prot_comparison}
(gb_P <- orthoBlocks$Bar_Osa)
sum(width(gb_P))
(gb_N <- coa$Bar_Osa)
sum(width(gb_N))
(ov <- subsetByOverlaps(gb_P, gb_N, type = "within"))
(jaccard <- sum(width(ov)) / sum(width(reduce(c(gb_P, gb_N)))))

gb_P <- gb_P[gb_P$geneNumber > 1]
gb_P
sum(gb_P$geneNumber)
(valid <- subsetByOverlaps(gb_P, gb_N, type = "within"))
sum(valid$geneNumber)
sum(width(valid))
```

Question: what does interrupt the colinearity of nucleotide regions in gene-centric
colinear regions ?

Genes per syntenic block
------------------------
```{r genes_per_block_1, fig.height=4, fig.width=6, dev=c("svg", "png")}
# Oki-Osa
# Genes per syntenic block
plot1 <- ggplot(as.data.frame(orthoBlocks$Oki_Osa), aes(x=geneNumber)) +
  geom_histogram() +
  ggtitle("Oki/Osa: genes per syntenic block")
# Genes per syntenic block, but on a logarithmic scale.
# Note the trickery to ensure counts of 1 are shown.
plot2 <- ggplot(as.data.frame(orthoBlocks$Oki_Osa), aes(x=geneNumber)) +
  geom_histogram(aes(y=..count..*10)) +
  scale_y_log10(labels=function(y) y/10, name="count") +
  ggtitle("Oki/Osa: genes per syntenic block (log10 axis)")

ggarrange(plot1, plot2)

# Oki-Bar
plot1 <- ggplot(as.data.frame(orthoBlocks$Oki_Bar), aes(x=geneNumber )) +
  geom_histogram() +
  ggtitle("Oki/Bar: genes per syntenic block")
plot2 <- ggplot(as.data.frame(orthoBlocks$Oki_Bar), aes(x=geneNumber)) +
  geom_histogram(aes(y=..count..*10)) +
  scale_y_log10(labels=function(y) y/10, name="count") +
  ggtitle("Oki/Bar: genes per syntenic block (log10 axis)")
ggarrange(plot1, plot2)

# Osa-Bar
plot1 <- ggplot(as.data.frame(orthoBlocks$Osa_Bar), aes(x=geneNumber )) +
  geom_histogram() +
  ggtitle("Osa/Bar: genes per syntenic block")
plot2 <- ggplot(as.data.frame(orthoBlocks$Osa_Bar), aes(x=geneNumber)) +
  geom_histogram(aes(y=..count..*10)) +
  scale_y_log10(labels=function(y) y/10, name="count") +
  ggtitle("Osa/Bar: genes per syntenic block (log10 axis)")
ggarrange(plot1, plot2)

```


# Session information

```{r session_information}
sessionInfo()
```
