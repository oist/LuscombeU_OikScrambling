---
title: "Orthogroup syntenies"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEncoding{UTF-8}
  %\VignetteIndexEntry{Orthogroup syntenies}
  %\VignetteEngine{knitr::rmarkdown}
editor_options:
  chunk_output_type: console
---

Load packages and data
======================

See `?OikScrambling:::loadAllGenomes`, `?OikScrambling:::loadAllTranscriptsGR`,
and `vignette("LoadGenomicBreaks", package = "OikScrambling")` for how the
different objects are prepared.

```{r load_packages_and_data}
library("OikScrambling")   |> suppressPackageStartupMessages()
library("ggpubr")
library("SummarizedExperiment")
(genomes <- OikScrambling:::loadAllGenomes())
(transcripts <- OikScrambling:::loadAllTranscriptsGR() |> suppressWarnings())
(load("BreakPoints.Rdata"))
```

Orthogroups
-----------

Load Orthogroups for _Oikopleura_ from the `BreakpointsData` package with the
`GenomicBreaks::load_one_to_ones_SE()` function.  Original file is in
`/bucket/LuscombeU/common/Breakpoints/Orthologues/selTun+Apps+Amph+Vert_lp_100clstr_blast/OrthoFinder/Results_Oct07/Phylogenetic_Hierarchical_Orthogroups/N19.tsv`.
See `news(package = "BreakpointsData")` for inspecting changes in more details.

```{r load_one_to_ones}
# Note that for now, I am only worried about Oikopleura. Subset the transcripts to include only oiks.
transcripts = subset(transcripts, names(transcripts) %in% c('Oki', 'Osa', 'Bar', 'Nor', 'Aom', 'Kum'))
# Create a data frame that maps the original species names in the OrthoFinder
# output to a set of new names that are easier to read.
species_name_map = data.frame(
  old_names=c("AOM-5-5f.prot.longest.fa_1", "Bar2_p4.Flye.prot.longest.fa_1", "KUM-M3-7f.prot.longest.fa_1", "OKI2018_I69.v2.prot.longest.fa_1", "OSKA2016v1.9.prot.longest.fa_1", "OdB3.v1.0.prot.fa_1.nohaplo"),
  new_names=c("Aom", "Bar", "Kum", "Oki", "Osa", "Nor")
)

load_one_to_ones_SE <- function(file, species_name_map) {
  # Read table
  pho <- read.delim(file, check.names = FALSE)

  # Remove all-NA columns
  pho <- pho[,sapply(pho, \(col) ! all(is.na(col)))]

  # Use the species name map to rename columns here.
  old_names <- colnames(pho)[4:ncol(pho)]
  new_names <- species_name_map[match(old_names, species_name_map$old_names),]$new_names
  colnames(pho)[4:ncol(pho)] <- new_names

  # Convert to SummarizedExperiment
  se <- SummarizedExperiment::SummarizedExperiment(
    assays = list(txs = pho[,-(1:3)]),
    rowData = DataFrame(pho[1:3])
  )

  assay(se, "txLists", withDimnames=FALSE) <- sapply(assay(se, 'txs'),     strsplit, split = ", ")
  rowData(se)$"txLists" <- sapply(assay(se, 'txs'),     strsplit, split = ", ")

  assay(se, "txCount", withDimnames=FALSE) <- sapply(DataFrame(assay(se, 'txLists')), \(x) sapply(x, length))  # Not sure why it only works when putting a DataFrame at the middle
  assay(se, "txLists")[(assay(se, "txCount")) == 0] <- NA_character_

  rowData(se)$txNames     <- apply(assay(se, "txLists"), 1, \(row) {
    row               |>  # Take a row from a matrix, a data.frame or a DataFrame
      as.list()       |>  # It is already list of character vectors, except for DataFrame subsets, which have to be coerced
      unlist()        |>  # Flatten it.  That is: `list(c("A", "B"), "C")` becomes `c("A", "B", "C")`
      unname()            # Remove element names
  })
  rowData(se)$txNames     <- sapply(rowData(se)$txNames, \(x) x[!is.na(x)])
  rowData(se)$txNames     <- CharacterList(rowData(se)$txNames)     # Convert to `CharacterList` for more comfortable display
  #rowData(se)$txNamesString <- unstrsplit(rowData(se)$txNames, ",") # If you would want it as a string...
  se
}

se <-  load_one_to_ones_SE(system.file("extdata/OrthoFinder/N19.tsv", package = "BreakpointsData"), species_name_map=species_name_map)

```

Flagging orthogroups by inferred homology class
-----------------------------------------------
While single-copy orthologues are arguably the most important component of the genome for between-species comparisons, it is also useful to know - or at least guess - at the other kinds of homologous relations that may exist within a gene family. This can identify, for example, clade-specific gene family expansions or clade-specific gene family deletions.

Here is an explanation of the orthogroup flags. Every HOG is annotated with a number of flags that are normally `TRUE` or `FALSE`. Clade-specific flags return either the name of the clade or `NA`. Details:

1. `present_in_all_spp`: All species in HOG have > 0 genes within the HOG
2. `one_to_one`: All species in HOG have exactly 1 gene within the HOG
3. `common_gene_duplication`: All species in HOG have > 0 genes within the HOG AND one or more species has > 1 gene
4. `expansion_species_specific`: One species has more than every other species, e.g. `c(sp1=1, sp2=1, sp3=3, sp4=2)`. Returns species name if true or `NA` if false
5. `expansion_clade_N`: One column for every clade. `TRUE` when ALL species in a clade are greater than ALL species outside the clade, e.g. `c(sp1=1, sp2=1, sp3=3, sp4=2)` is `TRUE` if `sp3+sp4` constitutes a clade
6. `expansion_reconciled`: An attempt to reconcile multiple clade-specific expansion flags. Clades can be nested (`clade1=c("sp1","sp2"), clade2=c("sp1","sp2","sp3","sp4")` and more than one clade-specific expansion can be `TRUE`. I attempt to resolve this as a single flag by assigning the flag as the clade with the most species (`flagAllPHO( ... , expansion_reconciliation="largest_clade"`, the default), but it can resolve to the clade with the highest mean count (`flagAllPHO( ... , expansion_reconciliation="mean_count"`)
7. `deletion_species_specific`: One species has 0 while all others have >0. Returns species name if true or `NA` if false
8. `deletion_clade_N`: Similar to `expansion_clade_N`, but different in that it does not care what the counts for other clades are. `TRUE` if all members of a clade have exactly 0 and `FALSE` if any species has >0
9. `deletion_reconciled`: Similar to `expansion_reconciled` and uses the same `largest_clade` tie breaking. `mean_count` does not work here because the mean count must be 0 for all species in a clade-specific deletion

Note that these flags are not mutually exclusive and can also be the inverse of one another. In our data, a clade-specific gene expansion may or may not correspond to a clade-specific deletion in other clades. E.g., `c(sp1=0, sp2=0, sp3=2, sp4=4)` could be a `sp1+sp2` deletion AND `sp3+sp4` expansion.

To flag orthogroups, we need a count matrix. Extract this from the `SummarizedExperiment` object `se` with `assay()` in the first part, then set up clades.

```{r orthoflagging}
se_m <- assay(se, 'txCount')
rownames(se_m) <- rowData(se)$HOG

# Create a list of clades. Each clade contains a vector of species names (the "new_names" of the next
# data frame. The clades can overlap.
clades=list("Oki_Kum"=c("Oki","Kum"), "Osa_Aom"=c("Osa","Aom"), "Bar_Nor"=c("Bar","Nor"), "Northern"=c("Osa","Aom","Bar","Nor"))

# clade_list: a named list where each list contains a vector of species.
# expansion_reconciliation: How to reconcile situations where more than 1 clade shows an expansion.
#                           There are only two options: "largest_clade" and "mean_count".
#                           "largest_clade" flags it to the clade with the most species
#                           "mean_count" flags it to the clade with the highest mean count
# deletion_reconciliation:  As above. "largest_clade" makes the most sense most of the time.
#                           For now, no other options are supported.
orthoflags <- OikScrambling:::flagAllPHO(se_m, clade_list=clades, expansion_reconciliation = "largest_clade", deletion_reconciliation="largest_clade")
# The function warns whenever there is an inconsistency with the flag. You can inspect these:
#     warnings()
# If you want to see too many warnings, you can also use deletion_warnings=T in the flagAllPHO function.
# This will warn you every time there is a deletion that satisfies more than one clade - which will be often!
# Several thousand times, in my case.
```

You can then summarize the flags as follows:

```{r summarizing_orthoflags}
(apply(orthoflags, 2, function(x) table(unlist(x))))
```

The `orthoflags` object yields a matrix with one row per orthogroup, the count columns of the HOG table, and most importantly, a set of orthogroup annotations based on the counts of every species and clade.

These annotations are not mutually exclusive. Consider the following:

```{r summarizing_orthoflags_2}
(assays(se)$txCount[15,])
(orthoflags[15,])
```

In this example, there is a species-specific expansion (i.e., Okinawa) at the same time as a clade-specific expansion (i.e., Oki/Kum). There is also a non-clade-specific deletion. The Osaka-Aomori clade is wholly deleted, while Bar-Nor is not.

In the following plots, I summarize some of the features of the `orthoflags` object.

```{r summarizing_orthoflags_3, fig.height=4, fig.width=6, dev=c("svg", "png")}
# Take a look at the distribution of different species flags.
ggplot(orthoflags) +
  aes(x=reorder(unlist(expansion_reconciled), unlist(expansion_reconciled), function(x) length(x))) + geom_bar(stat="count", position="dodge") +
  facet_wrap(~ present_in_all_spp, scales = 'free') +
  xlab(NULL) +
  coord_flip() +
  ggtitle("Orthogroups by clade-specific HOG expansions (TRUE=present in all spp.)")

ggplot(orthoflags) +
  aes(x=reorder(unlist(deletion_reconciled), unlist(deletion_reconciled), function(x) length(x))) + geom_bar(stat="count", position="dodge") +
  xlab(NULL) +
  coord_flip() +
  ggtitle("Orthogroups by clade-specific HOG deletions")

ggplot(orthoflags) +
  aes(x=reorder(unlist(expansion_species_specific), unlist(expansion_species_specific), function(x) length(x))) + geom_bar(stat="count", position="dodge") +
  facet_wrap(~ present_in_all_spp, scales = 'free' ) +
  xlab(NULL) +
  coord_flip() +
  ggtitle("Orthogroups by species-specific HOG expansions (TRUE=present in all spp.)")

ggplot(orthoflags) +
  aes(x=reorder(unlist(deletion_species_specific), unlist(deletion_species_specific), function(x) length(x))) + geom_bar(stat="count", position="dodge") +
  xlab(NULL) +
  coord_flip() +
  ggtitle("Orthogroups by species-specific HOG deletions")
```

In order to get these orthogroup annotations into the `GBreaks` object later, we add them as metadata columns to the `transcripts` object from above.

Since the indices of `orthoflags` are HOG IDs and not transcripts, we transmute the data a little to get a data frame indexed by a transcript ID. This format makes it easy to glom onto the transcripts file with `addMetadataToGRanges()`.

```{r flagging_orthogroups}
# The indices of the orthoflag matrix are HOG identifiers. So, relate the HOGs to transcripts and transfer
# the orthoflags to them.
rowData(se)$orthoFlags <- apply(orthoflags, 1, function(flags) flags)
# Transmute the SummarizedExperiment to make a species-specific data frame, indexed by gene IDs.
make_transcript_df <- function(SummarizedExperiment, species) {
  # Go over all of the rows in the annotation.
  tdf <- apply(rowData(se), 1, function(row) {
    # Grab some of the useful information.
    hog <- row$HOG
    og <- row$OG
    gtpc <- row$Gene.Tree.Parent.Clade
    #txNames <- row$txNames #|> CharacterList()
    hog_orthoflags <- row$orthoFlags
    species_transcripts <- row[[species]] |> unlist()
    # Make sure there are any transcripts for that species first.
    if(!identical(species_transcripts, character(0))) {
      species_df <- lapply(species_transcripts, function(transcript) {
        transcript_list <- list(hog=hog, txFull=transcript, og=og, gtpc=gtpc)
        # Note this hacky line that assumes gene IDs can be parsed out according to the .gX name
        # which is assigned by AUGUSTUS.
        if(grepl(".t", transcript)){
          transcript_list$txSimple <- paste("g", unlist(strsplit(transcript, ".g"))[2], sep="")
        } else {
          transcript_list$txSimple <- unlist(strsplit(transcript, "\\."))[2]
        }
        transcript_list <- append(transcript_list, hog_orthoflags)
        #transcript_list$txNames <- txNames
        transcript_list
      })
      species_df = do.call(rbind, species_df)
      species_df
    }
  })
  tdf <- do.call(rbind, tdf)
  # Make sure that the columns aren't themselves lists.
  tdf <- apply(tdf, 2, unlist)
  tdf <- as.data.frame(tdf)
  tdf$orthoFlagDF <- apply(tdf, 1, function(row) as.data.frame(as.list(row[5:20])))
  tdf
}
orthoflagsDF     <- SimpleList()
orthoflagsDF$Oki <- make_transcript_df(se, 'Oki')
orthoflagsDF$Osa <- make_transcript_df(se, 'Osa')
orthoflagsDF$Bar <- make_transcript_df(se, 'Bar')
orthoflagsDF$Kum <- make_transcript_df(se, 'Kum')
orthoflagsDF$Aom <- make_transcript_df(se, 'Aom')
orthoflagsDF$Nor <- make_transcript_df(se, 'Nor')
```

The `orthoflagsDF` object contains the same information as the `orthoflags` object, but is in a slightly more convenient format for gluing on to the transcript annotations. We do so here:

```{r gluing_orthoflags}
transcripts <- sapply(names(transcripts), function(sp){
  stitched <- OikScrambling:::addMetadataToGRanges(gr=transcripts[[sp]], df=orthoflagsDF[[sp]], gr_key='tx_name', df_key='txSimple', df_col_name = 'orthoFlagDF', rename_meta = 'orthoFlagDF')
  stitched
}) |> SimpleList()
```

Prepare GBreak objects
======================

```{r orthoPairs_object}
orthoPairToGBreaks <- function(name1, name2, annot1, annot2, treeName="N19", HOGs=NULL) {
  if(is.null(HOGs))
    HOGs <- OikScrambling:::load_one_to_ones(
      system.file(paste0("extdata/OrthoFinder/",treeName,".tsv"), package = "BreakpointsData"),
      c(name1, name2))

  IDs2GRanges <- function (IDs, annot) {
    prefix <- Biobase::lcPrefix(IDs)                  # Guess prefix in transcript IDs from HOG files
    not_prefix <- Biobase::lcPrefix(annot$tx_name)    # Remove trailing characters that are part of the name
    not_prefix <- paste0(not_prefix,"$")              # Anchor to end of the string
    prefix <- sub(not_prefix, "", prefix)             # Finalise prefix
    IDs <- sub(prefix, "", IDs)                       # Remove prefix from IDS
    names(annot) <- annot$tx_name                     # Store transcript name in names slot
    gr <- annot[IDs]                                  # Sort by ID
    strand(gr) <- "*"                                 # Make strandless
    gr                                                # Return the object
  }

  gb       <- IDs2GRanges(HOGs[,name1], annot1)
  gb$query <- IDs2GRanges(HOGs[,name2], annot2)
  gb <- GenomicBreaks:::GBreaks(gb)
  gb$HOG <- HOGs$HOG
  gb$OG  <- HOGs$OG
  sort(gb)
}

orthoPairToGBreaks_all_Oiks <- function(treeName=NULL, HOGs=NULL) {
  orthoPairs <- SimpleList()
  orthoPairs$Oki_Osa <- orthoPairToGBreaks("OKI2018_I69.v2.prot.longest.fa_1", "OSKA2016v1.9.prot.longest.fa_1",   transcripts$Oki, transcripts$Osa, treeName, HOGs)
  orthoPairs$Oki_Bar <- orthoPairToGBreaks("OKI2018_I69.v2.prot.longest.fa_1", "Bar2_p4.Flye.prot.longest.fa_1",   transcripts$Oki, transcripts$Bar, treeName, HOGs)
  orthoPairs$Oki_Kum <- orthoPairToGBreaks("OKI2018_I69.v2.prot.longest.fa_1", "KUM-M3-7f.prot.longest.fa_1",      transcripts$Oki, transcripts$Kum, treeName, HOGs)
  orthoPairs$Oki_Aom <- orthoPairToGBreaks("OKI2018_I69.v2.prot.longest.fa_1", "AOM-5-5f.prot.longest.fa_1",       transcripts$Oki, transcripts$Aom, treeName, HOGs)
  orthoPairs$Oki_Nor <- orthoPairToGBreaks("OKI2018_I69.v2.prot.longest.fa_1", "OdB3.v1.0.prot.fa_1.nohaplo",      transcripts$Oki, transcripts$Nor, treeName, HOGs)

  orthoPairs$Osa_Bar <- orthoPairToGBreaks("OSKA2016v1.9.prot.longest.fa_1",   "Bar2_p4.Flye.prot.longest.fa_1",   transcripts$Osa, transcripts$Bar, treeName, HOGs)
  orthoPairs$Osa_Oki <- orthoPairToGBreaks("OSKA2016v1.9.prot.longest.fa_1",   "OKI2018_I69.v2.prot.longest.fa_1", transcripts$Osa, transcripts$Oki, treeName, HOGs)
  orthoPairs$Osa_Kum <- orthoPairToGBreaks("OSKA2016v1.9.prot.longest.fa_1",   "KUM-M3-7f.prot.longest.fa_1",      transcripts$Osa, transcripts$Kum, treeName, HOGs)
  orthoPairs$Osa_Aom <- orthoPairToGBreaks("OSKA2016v1.9.prot.longest.fa_1",   "AOM-5-5f.prot.longest.fa_1",       transcripts$Osa, transcripts$Aom, treeName, HOGs)
  orthoPairs$Osa_Nor <- orthoPairToGBreaks("OSKA2016v1.9.prot.longest.fa_1",   "OdB3.v1.0.prot.fa_1.nohaplo",      transcripts$Osa, transcripts$Nor, treeName, HOGs)

  orthoPairs$Bar_Osa <- orthoPairToGBreaks("Bar2_p4.Flye.prot.longest.fa_1",   "OSKA2016v1.9.prot.longest.fa_1",   transcripts$Bar, transcripts$Osa, treeName, HOGs)
  orthoPairs$Bar_Oki <- orthoPairToGBreaks("Bar2_p4.Flye.prot.longest.fa_1",   "OKI2018_I69.v2.prot.longest.fa_1", transcripts$Bar, transcripts$Oki, treeName, HOGs)
  orthoPairs$Bar_Kum <- orthoPairToGBreaks("Bar2_p4.Flye.prot.longest.fa_1",   "KUM-M3-7f.prot.longest.fa_1",      transcripts$Bar, transcripts$Kum, treeName, HOGs)
  orthoPairs$Bar_Aom <- orthoPairToGBreaks("Bar2_p4.Flye.prot.longest.fa_1",   "AOM-5-5f.prot.longest.fa_1",       transcripts$Bar, transcripts$Aom, treeName, HOGs)
  orthoPairs$Bar_Nor <- orthoPairToGBreaks("Bar2_p4.Flye.prot.longest.fa_1",   "OdB3.v1.0.prot.fa_1.nohaplo",      transcripts$Bar, transcripts$Nor, treeName, HOGs)

  orthoPairs[ 1:5 ] <- sapply(orthoPairs[ 1:5 ],  flagLongShort, longShort$Oki)
  orthoPairs[ 6:10] <- sapply(orthoPairs[ 6:10],  flagLongShort, longShort$Osa)
  orthoPairs[11:15] <- sapply(orthoPairs[11:15],  flagLongShort, longShort$Bar)

  orthoPairs
}

orthoPairs         <- orthoPairToGBreaks_all_Oiks("N19")
#orthoPairs$Ply_Ros <- orthoPairToGBreaks("C_int_P.prot.longest.fa_1", "C_int_R.prot.longest.fa_1"
#                                        , transcripts$Ply, transcripts$Ros, treeName="N20")

# Same as above but using the same core orthogroups for all species.
#orthoPairs_core         <- orthoPairToGBreaks_all_Oiks("N3")
#orthoPairs_core$Ply_Ros <- orthoPairToGBreaks("C_int_P.prot.longest.fa_1", "C_int_R.prot.longest.fa_1"
#                                             , transcripts$Ply, transcripts$Ros, treeName="N3")

orthoPairs_one2oneInOiks <-
  orthoPairToGBreaks_all_Oiks(treeName = NULL,
                              HOGs = OikScrambling:::load_one_to_ones(
                                       system.file("extdata/OrthoFinder/N19.tsv", package = "BreakpointsData")))


sapply(orthoPairs, length)
sapply(orthoPairs_core, length)
sapply(orthoPairs_one2oneInOiks, length)
```

Problem: some annotations overlap
---------------------------------

```{r fix_gbreaks}
transcripts$Bar |> length()
transcripts$Bar |> reduce(min = 0) |> length()

flagOverlaps <- function(gr) {
  # Find overlaps
  ov <- findOverlaps(gr)
  # Index of self hits in the gr object
  idx <- queryHits(ov[!isSelfHit(ov)])
  # Convert to Boolean indexing the gr object
  seq_along(gr) %in% idx
}

transcripts$Bar[flagOverlaps(transcripts$Bar)]

# Show examples
orthoPairs$Oki_Osa[flagOverlaps(orthoPairs$Oki_Osa)]
orthoPairs$Oki_Osa$query[flagOverlaps(orthoPairs$Oki_Osa$query)]

# Remove and show how much was removed

orthoPairsFiltered <- sapply(orthoPairs, function(gb) {
  gb <- gb[!flagOverlaps(gb)]
  gb <- gb[!flagOverlaps(gb$query)]
  gb
}) |> SimpleList()

# orthoPairsFiltered_core <- sapply(orthoPairs_core, function(gb) {
#   gb <- gb[!flagOverlaps(gb)]
#   gb <- gb[!flagOverlaps(gb$query)]
#   gb
# }) |> SimpleList()

sapply(orthoPairs, length) - sapply(orthoPairsFiltered, length)
#sapply(orthoPairs_core, length) - sapply(orthoPairsFiltered_core, length)
```

Patterns in pairwise gene alignments
====================================

Coalesce syntenic blocks and annotate them
------------------------------------------

```{r coalesce}
coalOrtho <- function(gb) {
  # Coalesce
  coal <- coalesce_contigs(gb)

  # Map annotations to the coalesced blocks
  ov <- findOverlaps(coal, gb)

  # Extract gene names mapped to each blocks
  coal$geneNames <- CharacterList(split(names(gb)[subjectHits(ov)], queryHits(ov))) |> unname()
  # We can use the `ov` object for query ranges as well because of the way `coal` was constructed.
  coal$query$geneNames <- CharacterList(split(names(gb$query)[subjectHits(ov)], queryHits(ov))) |> unname()

  # Extract dNdS values
  coal$dNdS_GUIDANCE2  <- NumericList(split(gb$dNdS_GUIDANCE2 [subjectHits(ov)], queryHits(ov)))
  coal$dNdS_HmmCleaner <- NumericList(split(gb$dNdS_HmmCleaner[subjectHits(ov)], queryHits(ov)))
  coal$dNdS_PRANK      <- NumericList(split(gb$dNdS_PRANK     [subjectHits(ov)], queryHits(ov)))
  # We just copy dNdS values to query ranges because they are the same.
  coal$query$dNdS_GUIDANCE2  <- coal$dNdS_GUIDANCE2
  coal$query$dNdS_HmmCleaner <- coal$dNdS_HmmCleaner
  coal$query$dNdS_PRANK      <- coal$dNdS_PRANK

  # Add orthoflags. Since the flags are assigned to orthogroups, the flags are the same
  # for all single-copy orthologues.
  coal$orthoFlagDF <- split(gb$orthoFlagDF [subjectHits(ov)], queryHits(ov)) |> unname()

  # Count genes per syntenic block
  coal$geneNumber <- sapply(coal$geneNames, length)

  coal
}

orthoBlocks <- sapply(orthoPairsFiltered[1:15], coalOrtho) |> SimpleList()
# orthoBlocks$Ply_Ros <- coalesce_contigs(orthoPairsFiltered$Ply_Ros)
orthoBlocks[ 1:5 ] <- sapply(orthoBlocks[ 1:5 ],  flagLongShort, longShort$Oki)
orthoBlocks[ 6:10] <- sapply(orthoBlocks[ 6:10],  flagLongShort, longShort$Osa)
orthoBlocks[11:15] <- sapply(orthoBlocks[11:15],  flagLongShort, longShort$Bar)

# orthoBlocks_core <- sapply(orthoPairsFiltered_core[1:15], coalOrtho) |> SimpleList()
# orthoBlocks_core$Ply_Ros <- coalesce_contigs(orthoPairsFiltered_core$Ply_Ros)
# orthoBlocks_core[ 1:5 ] <- sapply(orthoBlocks_core[ 1:5 ],  flagLongShort, longShort$Oki)
# orthoBlocks_core[ 6:10] <- sapply(orthoBlocks_core[ 6:10],  flagLongShort, longShort$Osa)
# orthoBlocks_core[11:15] <- sapply(orthoBlocks_core[11:15],  flagLongShort, longShort$Bar)

sapply(orthoBlocks, length)
#sapply(orthoBlocks_core, length)

```

Quick overview of the results
=============================

Size distribution of the blocks
-------------------------------

```{r quick_overview}
stem(orthoBlocks$Oki_Osa$geneNumber)
table(orthoBlocks$Oki_Osa$geneNumber)
orthoBlocks$Oki_Osa[order(orthoBlocks$Oki_Osa$geneNumber)] |> tail(11)

stem(orthoBlocks$Oki_Kum$geneNumber)
table(orthoBlocks$Oki_Kum$geneNumber)
orthoBlocks$Oki_Kum[order(orthoBlocks$Oki_Kum$geneNumber)] |> tail(11)
```

Gene Order Conservation is smaller in short arms
------------------------------------------------

```{r GOC}
orthoBlocks_LSnoNA <- sapply(orthoBlocks[1:15], function(gb) gb[!is.na(gb$Arm)]) |> SimpleList()
sapply(orthoBlocks_LSnoNA, length)

df <- sapply(orthoBlocks_LSnoNA,
             function(gb) tapply(gb, paste(seqnames(gb), gb$Arm), GOC))

apply(df, 2, \(x) {
  tst <- t.test(x[c(1,3,5)], x[c(2,4,6)])
  c(pval=tst$p.value, mx=tst$estimate[1], my=tst$estimate[2])
})
```

Fraction of the genome covered or syntenic
------------------------------------------

```{r fraction_aligned}
uncov  <- BiocParallel::bplapply(orthoPairsFiltered, cleanGaps) |> SimpleList()
unsyn  <- BiocParallel::bplapply(orthoBlocks,        cleanGaps) |> SimpleList()

  covered_tot    <- sapply(orthoPairsFiltered,   \(x) sum(width(x)))
  syntenic_tot   <- sapply(orthoBlocks,          \(x) sum(width(x)))
uncovered_tot    <- sapply(uncov,                \(x) sum(width(x)))
unsyntenic_tot   <- sapply(unsyn,                \(x) sum(width(x)))

(syn_summary <- cbind(
  covered_frac   = covered_tot   / ( covered_tot   + uncovered_tot ) * 100,
  orthogenes_n   = sapply(orthoPairsFiltered, length),
  syntenic_frac  = syntenic_tot  / ( syntenic_tot  + unsyntenic_tot ) * 100,
  syntenic_reg   = sapply(orthoBlocks, length)
 )|> as.data.frame())

sapply(syn_summary, \(x) tapply(x, row.names(syn_summary) |> OikScrambling:::compDistance(), mean))   |> round(1)
sapply(syn_summary, \(x) tapply(x, row.names(syn_summary) |> OikScrambling:::compDistance(), median)) |> round(1)
sapply(syn_summary, \(x) tapply(x, row.names(syn_summary) |> OikScrambling:::compDistance(), sd))     |> round(1)
```

Unfortunately, there are not enough transcripts from Ciona that are part of the
pan-tunicate orthogroup set, which makes the comparison difficult between
Oikopleura and Cionaâ€¦

```{r fraction_aligned_core}
# uncov  <- BiocParallel::bplapply(orthoPairsFiltered_core, cleanGaps) |> SimpleList()
# unsyn  <- BiocParallel::bplapply(orthoBlocks_core,        cleanGaps) |> SimpleList()
#
#   covered_tot    <- sapply(orthoPairsFiltered_core,   \(x) sum(width(x)))
#   syntenic_tot   <- sapply(orthoBlocks_core,          \(x) sum(width(x)))
# uncovered_tot    <- sapply(uncov,                     \(x) sum(width(x)))
# unsyntenic_tot   <- sapply(unsyn,                     \(x) sum(width(x)))
#
# (syn_summary_core <- cbind(
#   covered_frac   = covered_tot   / ( covered_tot   + uncovered_tot ) * 100,
#   orthogenes_n   = sapply(orthoPairsFiltered_core, length),
#   syntenic_frac  = syntenic_tot  / ( syntenic_tot  + unsyntenic_tot ) * 100,
#   syntenic_reg   = sapply(orthoBlocks_core, length)
#  )|> as.data.frame())
#
# sapply(syn_summary_core, \(x) tapply(x, row.names(syn_summary_core) |> OikScrambling:::compDistance(), mean))   |> round(1)
# sapply(syn_summary_core, \(x) tapply(x, row.names(syn_summary_core) |> OikScrambling:::compDistance(), median)) |> round(1)
# sapply(syn_summary_core, \(x) tapply(x, row.names(syn_summary_core) |> OikScrambling:::compDistance(), sd))     |> round(1)
```

Agreement with nucleotide alignments
------------------------------------

```{r DNA_prot_comparison}
(gb_P <- orthoBlocks$Bar_Osa)
sum(width(gb_P))
(gb_N <- coa$Bar_Osa)
sum(width(gb_N))
(ov <- subsetByOverlaps(gb_P, gb_N, type = "within"))
(jaccard <- sum(width(ov)) / sum(width(reduce(c(gb_P, gb_N)))))

gb_P <- gb_P[gb_P$geneNumber > 1]
gb_P
sum(gb_P$geneNumber)
(valid <- subsetByOverlaps(gb_P, gb_N, type = "within"))
sum(valid$geneNumber)
sum(width(valid))
```

Question: what does interrupt the colinearity of nucleotide regions in gene-centric
colinear regions ?

Genes per syntenic block
------------------------
```{r genes_per_block_1, fig.height=4, fig.width=6, dev=c("svg", "png")}
# Oki-Osa
# Genes per syntenic block
plot1 <- ggplot(as.data.frame(orthoBlocks$Oki_Osa), aes(x=geneNumber)) +
  geom_histogram() +
  ggtitle("Oki/Osa: genes per syntenic block")
# Genes per syntenic block, but on a logarithmic scale.
# Note the trickery to ensure counts of 1 are shown.
plot2 <- ggplot(as.data.frame(orthoBlocks$Oki_Osa), aes(x=geneNumber)) +
  geom_histogram(aes(y=..count..*10)) +
  scale_y_log10(labels=function(y) y/10, name="count") +
  ggtitle("Oki/Osa: genes per syntenic block (log10 axis)")

ggarrange(plot1, plot2)

# Oki-Bar
plot1 <- ggplot(as.data.frame(orthoBlocks$Oki_Bar), aes(x=geneNumber )) +
  geom_histogram() +
  ggtitle("Oki/Bar: genes per syntenic block")
plot2 <- ggplot(as.data.frame(orthoBlocks$Oki_Bar), aes(x=geneNumber)) +
  geom_histogram(aes(y=..count..*10)) +
  scale_y_log10(labels=function(y) y/10, name="count") +
  ggtitle("Oki/Bar: genes per syntenic block (log10 axis)")
ggarrange(plot1, plot2)

# Osa-Bar
plot1 <- ggplot(as.data.frame(orthoBlocks$Osa_Bar), aes(x=geneNumber )) +
  geom_histogram() +
  ggtitle("Osa/Bar: genes per syntenic block")
plot2 <- ggplot(as.data.frame(orthoBlocks$Osa_Bar), aes(x=geneNumber)) +
  geom_histogram(aes(y=..count..*10)) +
  scale_y_log10(labels=function(y) y/10, name="count") +
  ggtitle("Osa/Bar: genes per syntenic block (log10 axis)")
ggarrange(plot1, plot2)

```

Where do these blocks occur?

```{r genes_per_block_2, fig.height=4, fig.width=6, dev=c("svg", "png")}
big_chr = c("chr1","chr2","PAR","XSR","YSR")
dat = as.data.frame(orthoBlocks$Oki_Osa)
dat = subset(dat, dat$seqnames %in% big_chr)
simple_plot <- ggplot( dat ) +
  aes(x=geneNumber) +
  geom_bar(stat='count') +
  facet_wrap(seqnames~Arm, ncol=2) +
  xlab('Genes per block') +
  geom_histogram(aes(y=..count..*10), binwidth = 1) +
  scale_y_log10(labels=function(y) y/10, name="count") +
  ggtitle("Oki-Osa: All-species HOGs by genomic location")
simple_plot
```

```{r genes_per_block_3, fig.height=4, fig.width=6, dev=c("svg", "png")}
big_chr = c("chr1","chr2","PAR","XSR","YSR")
dat = subset(as.data.frame(orthoBlocks$Oki_Bar), as.data.frame(orthoBlocks$Oki_Bar)$seqnames %in% big_chr)
simple_plot <- ggplot( dat ) +
  aes(x=geneNumber) +
  geom_bar(stat='count') +
  facet_wrap(seqnames~Arm, ncol=2) +
  xlab('Genes per block') +
  geom_histogram(aes(y=..count..*10), binwidth = 1) +
  scale_y_log10(labels=function(y) y/10, name="count") +
  ggtitle("Oki-Bar: All-species HOGs by genomic location")
simple_plot
```

```{r genes_per_block_4, fig.height=4, fig.width=6, dev=c("svg", "png")}
big_chr = c("Chr1","Chr2","PAR","XSR","YSR")
dat = subset(as.data.frame(orthoBlocks$Osa_Bar), as.data.frame(orthoBlocks$Osa_Bar)$seqnames %in% big_chr)
simple_plot <- ggplot( dat ) +
  aes(x=geneNumber) +
  geom_bar(stat='count') +
  facet_wrap(seqnames~Arm, ncol=2) +
  xlab('Genes per block') +
  geom_histogram(aes(y=..count..*10), binwidth = 1) +
  scale_y_log10(labels=function(y) y/10, name="count") +
  ggtitle("Osa-Bar: All-species HOGs by genomic location")
simple_plot
```

Genomic locations of HOGs found in all species
----------------------------------------------
Genes that are found in all species are found where in the genome?

```{r basic_flags_1, fig.height=6, fig.width=4, dev=c("svg", "png")}
big_chr = c("chr1","chr2","PAR","XSR","YSR")
dat = subset(as.data.frame(orthoPairs$Oki_Osa), as.data.frame(orthoPairs$Oki_Osa)$seqnames %in% big_chr)
simple_plot <- ggplot( dat ) +
  aes(x=unlist(lapply(orthoFlagDF, function(x) x$present_in_all_spp))) +
  geom_bar(stat='count') +
  facet_wrap(~Arm) +
  xlab('All-species HOG') +
  ggtitle("Oki-Osa: All-species HOGs by genomic location")

simple_plot

complex_plot <- ggplot( dat ) +
  aes(x=unlist(lapply(orthoFlagDF, function(x) x$present_in_all_spp))) +
  geom_bar(stat='count') +
  geom_text(aes(label=paste(..count.., ' (', scales::percent((..count..)/sum(..count..), accuracy = 0.1), ')', sep=''), y=..count..), stat='count', vjust=-0.5, size=2.5) +
  scale_y_continuous(expand=expansion(mult=c(0, 0.35))) +
  facet_wrap(seqnames~Arm, ncol=2) +
  xlab('All-species HOG') +
  ggtitle("Oki-Osa: All-species HOGs by genomic location")

complex_plot
```

```{r basic_flags_2, fig.height=6, fig.width=4, dev=c("svg", "png")}
big_chr = c("chr1","chr2","PAR","XSR","YSR")
dat = subset(as.data.frame(orthoPairs$Oki_Bar), as.data.frame(orthoPairs$Oki_Bar)$seqnames %in% big_chr)
simple_plot <- ggplot( dat ) +
  aes(x=unlist(lapply(orthoFlagDF, function(x) x$present_in_all_spp))) +
  geom_bar(stat='count') +
  facet_wrap(~Arm) +
  xlab('All-species HOG') +
  ggtitle("Oki-Bar: All-species HOGs by genomic location")

simple_plot

complex_plot <- ggplot( dat ) +
  aes(x=unlist(lapply(orthoFlagDF, function(x) x$present_in_all_spp))) +
  geom_bar(stat='count') +
  geom_text(aes(label=paste(..count.., ' (', scales::percent((..count..)/sum(..count..), accuracy = 0.1), ')', sep=''), y=..count..), stat='count', vjust=-0.5, size=2.5) +
  scale_y_continuous(expand=expansion(mult=c(0, 0.35))) +
  facet_wrap(seqnames~Arm, ncol=2) +
  xlab('All-species HOG') +
  ggtitle("Oki-Bar: All-species HOGs by genomic location")

complex_plot
```

```{r basic_flags_3, fig.height=6, fig.width=4, dev=c("svg", "png")}
big_chr = c("Chr1","Chr2","PAR","XSR","YSR")
dat = subset(as.data.frame(orthoPairs$Osa_Bar), as.data.frame(orthoPairs$Osa_Bar)$seqnames %in% big_chr)
simple_plot <- ggplot( dat ) +
  aes(x=unlist(lapply(orthoFlagDF, function(x) x$present_in_all_spp))) +
  geom_bar(stat='count') +
  facet_wrap(~Arm) +
  xlab('All-species HOG') +
  ggtitle("Osa-Bar: All-species HOGs by genomic location")

simple_plot

complex_plot <- ggplot( dat ) +
  aes(x=unlist(lapply(orthoFlagDF, function(x) x$present_in_all_spp))) +
  geom_bar(stat='count') +
  geom_text(aes(label=paste(..count.., ' (', scales::percent((..count..)/sum(..count..), accuracy = 0.1), ')', sep=''), y=..count..), stat='count', vjust=-0.5, size=2.5) +
  scale_y_continuous(expand=expansion(mult=c(0, 0.35))) +
  facet_wrap(seqnames~Arm, ncol=2) +
  xlab('All-species HOG') +
  ggtitle("Osa-Bar: All-species HOGs by genomic location")

complex_plot
```

Taken together: in general, a greater fraction of genes on long arms can be found in all species. Let us continue this logic further.

Genomic locations of one-to-one HOGs
------------------------------------

A HOG is either one-to-one (exactly one HOG constituent from every species) or not. Not-one-one-one gene means either one or more species has >1 gene in the same HOG without being resolved as a clade-specific HOG, or else the gene is missing in one or more species. Both can be true at once (e.g., counts of 6, 1, 1, 1, 3, 0)

Where are one-to-one orthologues located in the genome?

```{r basic_flags_4, fig.height=4, fig.width=6, dev=c("svg", "png")}
big_chr = c("chr1","chr2","PAR","XSR","YSR")
dat = subset(as.data.frame(orthoPairs$Oki_Osa), as.data.frame(orthoPairs$Oki_Osa)$seqnames %in% big_chr)
simple_plot <- ggplot( dat ) +
  aes(x=unlist(lapply(orthoFlagDF, function(x) x$one_to_one))) +
  geom_bar(stat='count') +
  facet_wrap(~Arm) +
  xlab('One-to-one HOG') +
  ggtitle("Oki-Osa: One-to-one HOGs by genomic location")

simple_plot

complex_plot <- ggplot( dat ) +
  aes(x=unlist(lapply(orthoFlagDF, function(x) x$present_in_all_spp))) +
  geom_bar(stat='count') +
  geom_text(aes(label=paste(..count.., ' (', scales::percent((..count..)/sum(..count..), accuracy = 0.1), ')', sep=''), y=..count..), stat='count', vjust=-0.5, size=2.5) +
  scale_y_continuous(expand=expansion(mult=c(0, 0.35))) +
  facet_wrap(seqnames~Arm, ncol=2) +
  xlab('One-to-one HOG') +
  ggtitle("Oki-Osa: One-to-one HOGs by genomic location")

complex_plot
```

```{r basic_flags_5, fig.height=4, fig.width=6, dev=c("svg", "png")}
big_chr = c("chr1","chr2","PAR","XSR","YSR")
dat = subset(as.data.frame(orthoPairs$Oki_Bar), as.data.frame(orthoPairs$Oki_Bar)$seqnames %in% big_chr)
simple_plot <- ggplot( dat ) +
  aes(x=unlist(lapply(orthoFlagDF, function(x) x$one_to_one))) +
  geom_bar(stat='count') +
  facet_wrap(~Arm) +
  xlab('One-to-one HOG') +
  ggtitle("Oki-Bar: One-to-one HOGs by genomic location")

simple_plot

complex_plot <- ggplot( dat ) +
  aes(x=unlist(lapply(orthoFlagDF, function(x) x$present_in_all_spp))) +
  geom_bar(stat='count') +
  geom_text(aes(label=paste(..count.., ' (', scales::percent((..count..)/sum(..count..), accuracy = 0.1), ')', sep=''), y=..count..), stat='count', vjust=-0.5, size=2.5) +
  scale_y_continuous(expand=expansion(mult=c(0, 0.35))) +
  facet_wrap(seqnames~Arm, ncol=2) +
  xlab('One-to-one HOG') +
  ggtitle("Oki-Bar: One-to-one HOGs by genomic location")

complex_plot
```

```{r basic_flags_6, fig.height=4, fig.width=6, dev=c("svg", "png")}
big_chr = c("Chr1","Chr2","PAR","XSR","YSR")
dat = subset(as.data.frame(orthoPairs$Osa_Bar), as.data.frame(orthoPairs$Osa_Bar)$seqnames %in% big_chr)
simple_plot <- ggplot( dat ) +
  aes(x=unlist(lapply(orthoFlagDF, function(x) x$one_to_one))) +
  geom_bar(stat='count') +
  facet_wrap(~Arm) +
  xlab('One-to-one HOG') +
  ggtitle("Osa-Bar: One-to-one HOGs by genomic location")

simple_plot

complex_plot <- ggplot( dat ) +
  aes(x=unlist(lapply(orthoFlagDF, function(x) x$present_in_all_spp))) +
  geom_bar(stat='count') +
  geom_text(aes(label=paste(..count.., ' (', scales::percent((..count..)/sum(..count..), accuracy = 0.1), ')', sep=''), y=..count..), stat='count', vjust=-0.5, size=2.5) +
  scale_y_continuous(expand=expansion(mult=c(0, 0.35))) +
  facet_wrap(seqnames~Arm, ncol=2) +
  xlab('One-to-one HOG') +
  ggtitle("Osa-Bar: One-to-one HOGs by genomic location")

complex_plot
```

Thus, it seems that whether or not a gene participates in a one-to-one HOG also depends on where the gene is encoded. Long chromosome arms are more often host to one-to-ones, and this is also true for the XSR, which always has the highest proportion of one-to-one genes across all species pairs.

Genomic locations of species- and clade-specific HOG expansions
---------------------------------------------------------------
In the following section, I attempt to identify species- and clade-specific gene duplications using counts from HOG counts. For a given `query`-`target` combination, the `collect_clade_expansions()` function extracts from a `GBreaks` object 3 different data frames:

1. Species-specific duplications in the query genome (referred to as `sp1` in the code below)
2. Species-specific duplications in the target genome (referred to as `sp2` in the code below)
3. Clade-specific duplications common to the query and target

N.B. Note that this step uses a concatenate of the two species names to extract a specific column from the `orthoFlagsDF` (`expansion_clade_X_Y`). Ensure that the clade names line up precisely with the species names.

In order to identify these events in the coordinate system of the query (chromosomal) assembly, it is necessary to formulate some objects similar to `orthoPairs`. Because these genes can be species-specific, there may not be a region that corresponds to that gene at all in the other. How the following function deals with this:

* Clade-specific genes: These are shared between the query and target, so these are present within the `orthoPairs` already.
* Query-specific genes: Generate a new `orthoPairs`-like object starting from the query genome transcript coordinates. Query coordinates and features become NA
* Target-specific genes: The `collectCladeExpansions()` function checks whether the genes flanking the target-specific gene are encoded on the same contig in the target genome. If they are, it checks whether both of those genes are in `orthoPairs`. If they are, and the corresponding query genes are encoded on the same query chromosome, then the target-specific gene is inferred as being between the query's genes.

```{r gene_duplications_1}
# Find midpoints of a GRanges.
grMidpoint <- function(gr) {
  starts <- as.data.frame(ranges(gr))$start
  ends <- as.data.frame(ranges(gr))$end
  mids <- (starts+ends)/2
  mids
}

# Given a chromosome-scale assembly (sp1) and a second species of a clade (sp2),
# plot coordinates of clade-specific gene expansions (common to sp1+sp2) and
# species-specific expansions.
collectCladeExpansions <- function(orthopairs, sp1, sp2, bigChr, longShort) {
  result <- SimpleList()
  orthopair <- orthopairs[[paste(sp1, sp2, sep="_")]]
  orthopair$midpoint <- grMidpoint(orthopair)
  orthopair <- as.data.frame(orthopair)
  orthopair <- subset(orthopair, orthopair$seqnames %in% big_chr)

  # Clade-specific expansions
  # The clade-specific data frame is easiest. This is the subset of the orthoPair where expansion_clade_X is TRUE.
  dat_clade <- orthopair[as.logical(unlist(lapply(orthopair$orthoFlagDF, function(x) x[[paste("expansion_clade_", sp1, "_", sp2, sep="")]] )))==TRUE,] |> as.data.frame()
  dat_clade <- dat_clade[,!grepl("OG" , colnames(dat_clade))] # Drop HOG and OG columns to facilitate rbinding
  result[[paste(sp1, sp2, sep="_")]] <- dat_clade

  # sp1-specific expansion
  # sp1, the chromosomal assembly, is somewhat easy to indicate positions of species-specific duplications.
  # Since species-specific expansions are not in orthoPairs, we must make a fake one out of transcript coordinates.
  # We also need sp1's longest transcripts per gene to coordinate with sp2 later, so start with that.
  transcripts_sp1 <- transcripts[[sp1]]
  transcripts_sp1 <- as.data.frame(transcripts_sp1)
  # Subset transcripts to include only the longest per gene: split by gene ID, sort by longest, glue back together
  transcripts_sp1$geneid <- unname(sapply(transcripts_sp1$tx_name, function(s) unlist(strsplit(s, "\\.t"))[1] ))
  transcripts_sp1 <- split(transcripts_sp1, transcripts_sp1$geneid) # split
  transcripts_sp1 <- lapply(transcripts_sp1, function(geneid) { # sort by longest
    biggest_gene = geneid[which.max(geneid$width),]
    biggest_gene
  })
  transcripts_sp1 <- do.call(rbind, transcripts_sp1) |> as.data.frame() # glue
  transcripts_sp1 <- transcripts_sp1[order(transcripts_sp1$seqnames, transcripts_sp1$start),]
  
  # sp1-specific genes
  df_sp1 <- transcripts[[sp1]] |> as.data.frame()
  df_sp1 <- subset(df_sp1, df_sp1$seqnames %in% big_chr) # Include only chromosome-scale scaffolds
  df_sp1 <- df_sp1[which(unlist(lapply(df_sp1$orthoFlagDF, function(x) x$expansion_species_specific ))==sp1),] # Subset to species-specific expansions
  # Add a bunch of empty columns to make the object look like an orthoPair
  df_sp1 <- cbind(df_sp1, query.seqnames=NA, query.start=NA, query.end=NA, query.width=NA, query.strand=NA, query.tx_id=NA, query.tx_name=NA, query.dNdS_GUIDANCE2=NA, query.dNdS_HmmCleaner=NA, query.dNdS_PRANK=NA, query.orthoFlagDF=df_sp1$orthoFlagDF)
  df_sp1 <- flagLongShort(GRanges(df_sp1), longShort) |> as.data.frame() # Add back in long-short arm information
  df_sp1$midpoint <- grMidpoint(GRanges(df_sp1)) # Add in gene midpoints
  dat_sp1 <- df_sp1
  result[[sp1]] <- dat_sp1 # add to result list

  # sp2-specific genes
  # As with sp1, sp2-specific expansions cannot be part of the orthoPairs, by definition.
  # However, there is an additional problem that sp2's genes do not exist on sp1 - so how
  # can we position them on the sp1 chromosomal assembly?
  # If the sp2-specific gene's neighbours are in orthoGroups with sp1 genes, and those genes
  # are collinear in sp1, then the position of that expansion is inferred to be between those
  # two orthoPairs in sp1.
  transcripts_sp2 <- as.data.frame(transcripts[[sp2]])
  transcripts_sp2$midpoint <- grMidpoint(transcripts[[sp2]])
  # Subset transcripts to include only the longest per gene: split by gene ID, sort by longest, glue back together
  transcripts_sp2$geneid <- unname(sapply(transcripts_sp2$tx_name, function(s) unlist(strsplit(s, "\\.t"))[1] ))
  transcripts_sp2 <- split(transcripts_sp2, transcripts_sp2$geneid) # split
  transcripts_sp2 <- lapply(transcripts_sp2, function(geneid) { # sort by longest
    biggest_gene = geneid[which.max(geneid$width),]
    biggest_gene
  })
  transcripts_sp2 <- do.call(rbind, transcripts_sp2) |> as.data.frame() # glue
  transcripts_sp2 <- transcripts_sp2[order(transcripts_sp2$seqnames, transcripts_sp2$start),]
  df_sp2 <- subset(transcripts_sp2, transcripts_sp2$seqnames %in% unique(unlist(orthopair$query.seqnames))) # Subset to only contigs that correspond to sp1's chr-scale scaffolds
  df_sp2 <- df_sp2[which(unlist(lapply(df_sp2$orthoFlagDF, function(x) x$expansion_species_specific ))==sp2),] # Subset to species-specific expansions

  # This is where the wheels fall off a bit, so to speak. It is complicated, but this is the logic:
  #     1. If sp2-specific gene has adjacent genes;
  #     2. If adjacent genes on same contig in sp2;
  #     3. If adjacent genes in orthoPair with sp1;
  #     4. If sp1's genes both on the same contig in sp1;
  #     5. If the sp1's orthoPair'ed genes are collinear with no intervening genes in sp1;
  #     6. Then the position of the sp2-specific gene is inferred by the edges of the
  #        adjacent genes. We generate a orthoPairs-like object from this inference.
  df_sp2_specific <- lapply(1:nrow(df_sp2), function(gene){
    cur_gene <- df_sp2[gene,]
    prev_gene <- transcripts_sp2[which(transcripts_sp2$tx_name == cur_gene$tx_name)-1,]
    next_gene <- transcripts_sp2[which(transcripts_sp2$tx_name == cur_gene$tx_name)+1,]
    if(nrow(prev_gene)!=0 & nrow(next_gene)!=0) {
      target_seqnames <- c(as.character(cur_gene$seqnames), as.character(prev_gene$seqnames),  as.character(next_gene$seqnames))
      # If all genes on same contig in the target genome...
      if(length(unique(target_seqnames)) == 1) {
        # If previous and next genes in an orthopair (and make sure they actually exist)
        if(prev_gene$tx_name %in% orthopair$query.tx_name & next_gene$tx_name %in% orthopair$query.tx_name & nrow(orthopair[orthopair$query.tx_name == prev_gene$tx_name,])!=0 & nrow(orthopair[orthopair$query.tx_name == next_gene$tx_name,]) != 0 ) {
          prev_orthopair <- orthopair[orthopair$query.tx_name == prev_gene$tx_name,]
          next_orthopair <- orthopair[orthopair$query.tx_name == next_gene$tx_name,]
          query_seqnames <- c(as.character(prev_orthopair$seqnames), as.character(next_orthopair$seqnames))
          target_prev_gene <- transcripts_sp1[which(transcripts_sp1$tx_name == prev_orthopair$tx_name),]
          target_next_gene <- transcripts_sp1[which(transcripts_sp1$tx_name == next_orthopair$tx_name),]
          # If all members of this orthopair are on the same chromosome in the target genome
          # and the target's previous and next genes actually exist
          if(length(unique(query_seqnames)) == 1 & nrow(target_prev_gene)!=0 & nrow(target_next_gene)!=0 ) {
            # If the sp2 gene's neighbours are both in orthoPairs, check if they immediately neighbour one another in sp1
            # If they do, then the difference between their indices is exactly 2
            # (because the "next gene" is 2 rows ahead of the "previous gene")
            target_prev_gene_index = which(transcripts_sp1$tx_name == prev_orthopair$tx_name)
            target_next_gene_index = which(transcripts_sp1$tx_name == next_orthopair$tx_name)
            if( (target_next_gene_index-target_prev_gene_index)==2) { # If target's genes are collinear...
              mod_orthopair <- prev_orthopair
              mod_orthopair$start   <- prev_orthopair$end+1   # Create a fake locus start point after its preceding gene
              mod_orthopair$end     <- next_orthopair$start-1 # Create a fake locus end point before its next gene
              mod_orthopair$width   <- mod_orthopair$end - mod_orthopair$start
              mod_orthopair$tx_id   <- NA # A gene specific to sp2 cannot have a tx_id in the reference
              mod_orthopair$tx_name <- NA # ""
              mod_orthopair$dNdS_GUIDANCE2  <- NA # A species-specific gene cannot have a dN/dS value because I only use 1-to-1s
              mod_orthopair$dNdS_HmmCleaner <- NA # ""
              mod_orthopair$dNdS_PRANK      <- NA # ""
              mod_orthopair$orthoFlagDF <- cur_gene$orthoFlagDF # orthoFlags can be transferred for simplicity's sake
              mod_orthopair$query.start <- cur_gene$start
              mod_orthopair$query.end   <- cur_gene$end
              mod_orthopair$query.width <- cur_gene$end - cur_gene$start
              mod_orthopair$query.tx_id <- cur_gene$tx_id
              mod_orthopair$query.dNdS_GUIDANCE2  <- NA # A species-specific gene cannot have a dN/dS value because I only use 1-to-1s
              mod_orthopair$query.dNdS_HmmCleaner <- NA # ""
              mod_orthopair$query.dNdS_PRANK      <- NA # ""
              mod_orthopair$query.orthoFlagDF <- cur_gene$orthoFlagDF
              mod_orthopair$midpoint <- (next_orthopair$start-1+prev_orthopair$end+1)/2
              rownames(mod_orthopair) <- NULL
              return(mod_orthopair)
            } else {
              warning_message = paste("sp2-specific gene ", cur_gene$tx_name, " is flanked by query genome orthopairs ", paste(prev_orthopair$tx_name, prev_orthopair$seqnames, prev_orthopair$start, prev_orthopair$end, collapse=','), " and ", paste(next_orthopair$tx_name, next_orthopair$seqnames, next_orthopair$start, next_orthopair$end, collapse=','), ", but they are not collinear. Can't infer position of target species-specific gene unless it can be placed between two collinear orthopairs in the reference genome.", sep="")
              warning(warning_message)
              return(NULL)
            }
          } else {
            warning_message = paste("sp2-specific gene ", cur_gene$tx_name, " is flanked by orthopairs from ", prev_orthopair$seqnames, " and ", next_orthopair$seqnames, " in the query genome. Can't infer position of target species-specific gene unless it can be placed between two collinear orthopairs in the reference genome.", sep="")
            #warning(warning_message)
            return(NULL)
          }
        } else {
          warning_message = paste("sp2-specific gene ", cur_gene$tx_name, "'s next gene ", next_gene$tx_name, " and previous gene ", prev_gene$tx_name, " are not in orthopairs. Can't infer position of a species-specific gene unless it can be placed on the reference genome.", sep="")
          #warning(warning_message)
          return(NULL)
        }
      } else {
        warning_message = paste("sp2-specific gene ", cur_gene$tx_name, "'s next gene ", next_gene$tx_name, " and previous gene ", prev_gene$tx_name, " are not on the same contig. seqnames: ", paste(target_seqnames, collapse=","), "\n Can't infer position of a species-specific gene unless neighbouring genes are on same contig.",  sep="")
        #warning(warning_message)
        return(NULL)
      }
    } else {
      return(NULL)
    }
  })
  dat_sp2 <- do.call(rbind, df_sp2_specific) |> as.data.frame()
  # bind rows back into a data.frame
  result[[sp2]] <- dat_sp2

  result
}

big_chr <- c("chr1","chr2","PAR","XSR","YSR")
duplications <- SimpleList()
duplications$Oki_Kum <- collectCladeExpansions(orthopairs=orthoPairs, sp1="Oki", sp2="Kum", bigChr=big_chr, longShort=longShort$Oki)
big_chr <- c("Chr1","Chr2","PAR","XSR","YSR")
duplications$Osa_Aom <- collectCladeExpansions(orthopairs=orthoPairs, sp1="Osa", sp2="Aom", bigChr=big_chr, longShort=longShort$Osa)
duplications$Bar_Nor <- collectCladeExpansions(orthopairs=orthoPairs, sp1="Bar", sp2="Nor", bigChr=big_chr, longShort=longShort$Bar)
```

N.B. The function `collectCladeExpansions()` tries to warn you when something funny happens with respect to the target-specific genes. Funny occurrences include:
1. The target's genes immediately up- and down-stream of a target-specific gene are not encoded on the same contig
2. The target's genes immediately up- and down-stream of a target-specific gene are encoded on the same contig, but are not found within an orthoPair
3. The target's genes immediately up- and down-stream of a target-specific gene are found within an orthoPair, but those orthoPairs are found on different chromosomes in the query genome
4. The target's genes immediately up- and down-stream of a target-specific gene are found within an orthoPair, and those orthoPairs are on the same chromosome, but they are not collinear

You can inspect these with `warnings()`, although there will be more than 50 such warnings. You can increase this by using `options(nwarnings=10000)` before running the `collectCladeExpansions()` function. To save you some time, this is the result using the version `0.5.0` of the `BreakPointsData`:

Warning | Oki-Kum | Osa-Aom | Bar-Nor
------- | ------- | ------- | -------
1 (diff. target contigs) | 11 | 1 | 100
2 (orthologue neighbours not in orthoPairs) | 919 | 733 | 1842
3 (orthologue neighbours not on same query chr.) | 26 | 17 | 64
3 (orthologue neighbours not collinear on query chr.) | 286 | 307 | 490

Quickly check where these gene expansions are located:
```{r gene_duplications_2}
# Make sure factor levels are in alphabetical order and exclude chromosomes that were already snipped out.
# It makes the later faceting look ugly if they are not sorted properly.
duplications <- lapply(duplications, function(pair){
  lapply(pair, function(sp){
    sp$seqnames <- droplevels(factor(sp$seqnames, levels=sort(as.character(unique(sp$seqnames)))))
    sp
  })
})

(lapply(duplications, function(pair) {
  sapply(pair, function(dup_tb) table(dup_tb$seqnames))
}))
```

The `duplications` object contains data frames that add up the number of clade- and species-specific genomes. Where do duplications fall in the genome?

```{r gene_duplications_pos_oki_1, fig.height=4, fig.width=6, dev=c("svg", "png")}
# Plot distribution of clade-specific duplications across the genome.
ggplot(duplications$Oki_Kum$Oki_Kum) +
  aes(x=midpoint) +
  geom_histogram(binwidth=100000) +
  facet_wrap(seqnames~Arm, scales = "free_x", ncol=2) +
  ggtitle('Oki-Kum: Clade-specific gene family expansions')

# Oki-specific.
ggplot(duplications$Oki_Kum$Oki) +
  aes(x=midpoint) +
  geom_histogram(binwidth=100000) +
  facet_wrap(seqnames~Arm, scales = "free_x", ncol=2) +
  ggtitle('Oki: Species-specific gene family expansions')

# Kum-specific.
ggplot(duplications$Oki_Kum$Kum) +
  aes(x=midpoint) +
  #geom_density() +
  geom_histogram(binwidth=100000) +
  #geom_boxplot(stat='count') +
  facet_wrap(seqnames~Arm, scales = "free_x", ncol=2) +
  ggtitle('Kum: Species-specific gene family expansions')

# All gene expansions: Oki-specific, Kum-specific, and Oki+Kum-specific.
joinedDup <- as.data.frame(do.call(rbind, duplications$Oki_Kum))
joinedDup$Arm <- flagLongShort(GRanges(joinedDup), longShort$Oki) |> as.data.frame()
ggplot(do.call(rbind, duplications$Oki_Kum)) +
  aes(x=midpoint) +
  geom_histogram(binwidth=100000) +
  facet_wrap(seqnames~Arm, scales = "free_x", ncol=2) +
  ggtitle('Oki-Kum: All species- and clade-specific duplications')

# As above, but without faceting by sequence, which makes a certain pattern immediately clear...
ggplot(do.call(rbind, duplications$Oki_Kum)) +
  aes(x=midpoint) +
  geom_histogram(binwidth=100000) +
  facet_wrap(~Arm, scales = "free_x", ncol=2) +
  ggtitle('Oki-Kum: All species- and clade-specific duplications')
```

Sure, it looks like there is a pattern there. But is it statistically significant?

```{r gene_duplications_pos_oki_2, fig.height=4, fig.width=6, dev=c("svg", "png")}
plotExpansionStats <- function(duplication_pair, pair_name) {
  df <- do.call(rbind, duplication_pair) |> mutate(bin=cut_width(midpoint, 100000)) |> dplyr::group_by(seqnames, Arm, bin) |> dplyr::summarise(count=dplyr::n())
  plot1 <- ggplot(df) + aes(y=count) + geom_boxplot() + facet_wrap(~Arm, ncol=2) + ggtitle(paste(pair_name, ", dup. by arm", sep=""))
  plot2 <- ggplot(df) + aes(y=count) + geom_boxplot() + facet_wrap(seqnames~Arm, ncol=2) + ggtitle(paste(pair_name, ", dup. by chr/arm", sep=""))
  plot_joined = ggarrange(plot1, plot2)
  plot_joined
}
plotExpansionStats(duplications$Oki_Kum, pair_name = "Oki-Kum")

calcExpansionStats <- function(duplication_pair, pair_name, conf.level=0.95) {
  df <- do.call(rbind, duplication_pair) |> mutate(bin=cut_width(midpoint, 100000)) |> dplyr::group_by(seqnames, Arm, bin) |> dplyr::summarise(count=dplyr::n())
  # Show some numbers...
  anova = aov(df$count ~ df$seqnames + df$Arm) |> summary()
  tukey = TukeyHSD(aov(df$count ~ df$seqnames + df$Arm), conf.level=conf.level)
  return(SimpleList(anova=anova, tukey=tukey))
}
expansionStats <- calcExpansionStats(duplications$Oki_Kum, pair_name = "Oki-Kum", conf.level=0.95)
(expansionStats$anova)
(expansionStats$tukey)
```

Let's inspect the other chromosomal assemblies.

```{r gene_duplications_pos_osa_1}
ggplot(duplications$Osa_Aom$Osa_Aom) +
  aes(x=midpoint) +
  geom_histogram(binwidth=100000) +
  facet_wrap(seqnames~Arm, scales = "free_x", ncol=2) +
  ggtitle('Osa-Aom: Clade-specific gene family expansions')

ggplot(duplications$Osa_Aom$Osa) +
  aes(x=midpoint) +
  geom_histogram(binwidth=100000) +
  facet_wrap(seqnames~Arm, scales = "free_x", ncol=2) +
  ggtitle('Osa: Species-specific gene family expansions')

ggplot(duplications$Osa_Aom$Aom) +
  aes(x=midpoint) +
  geom_histogram(binwidth=100000) +
  facet_wrap(seqnames~Arm, scales = "free_x", ncol=2) +
  ggtitle('Aom: Species-specific gene family expansions')


ggplot(do.call(rbind, duplications$Osa_Aom)) +
  aes(x=midpoint) +
  geom_histogram(binwidth=100000) +
  facet_wrap(seqnames~Arm, scales = "free_x", ncol=2) +
  ggtitle('Osa-Aom: All species- and clade-specific duplications')

# As above, but without faceting by sequence, which makes a certain pattern immediately clear...
ggplot(do.call(rbind, duplications$Osa_Aom)) +
  aes(x=midpoint) +
  geom_histogram(binwidth=100000) +
  facet_wrap(~Arm, scales = "free_x", ncol=2) +
  ggtitle('Osa-Aom: All species- and clade-specific duplications')
```

```{r gene_duplications_pos_osa_2, fig.height=4, fig.width=6, dev=c("svg", "png")}
plotExpansionStats(duplications$Osa_Aom, pair_name = "Osa-Aom")

stats <- calcExpansionStats(duplications$Osa_Aom, pair_name = "Osa-Aom")
stats$anova
stats$tukey
```


```{r gene_duplications_pos_bar_1}
ggplot(duplications$Bar_Nor$Bar_Nor) +
  aes(x=midpoint) +
  geom_histogram(binwidth=100000) +
  facet_wrap(seqnames~Arm, scales = "free_x", ncol=2) +
  ggtitle('Gene family expansions: Bar-Nor')

ggplot(duplications$Bar_Nor$Bar) +
  aes(x=midpoint) +
  geom_histogram(binwidth=100000) +
  facet_wrap(seqnames~Arm, scales = "free_x", ncol=2) +
  ggtitle('Species-specific gene family expansions: Bar')

ggplot(duplications$Bar_Nor$Nor) +
  aes(x=midpoint) +
  geom_histogram(binwidth=100000) +
  facet_wrap(seqnames~Arm, scales = "free_x", ncol=2) +
  ggtitle('Species-specific gene family expansions: Nor')

ggplot(do.call(rbind, duplications$Bar_Nor)) +
  aes(x=midpoint) +
  geom_histogram(binwidth=100000) +
  facet_wrap(seqnames~Arm, scales = "free_x", ncol=2) +
  ggtitle('Bar, Nor: All species- and clade-specific duplications')

# As above, but without faceting by sequence, which makes a certain pattern immediately clear...
ggplot(do.call(rbind, duplications$Bar_Nor)) +
  aes(x=midpoint) +
  geom_histogram(binwidth=100000) +
  facet_wrap(~Arm, scales = "free_x", ncol=2) +
  ggtitle('Bar, Nor: All species- and clade-specific duplications')
```

```{r gene_duplications_pos_bar_2, fig.height=4, fig.width=6, dev=c("svg", "png")}
plotExpansionStats(duplications$Bar_Nor, pair_name = "Bar-Nor")

stats <- calcExpansionStats(duplications$Bar_Nor, pair_name = "Bar-Nor")
stats$anova
stats$tukey
```

TODO
Clade-specific deletions
------------------------
In the same vein as the analysis above, let's examine where genes tend to be deleted. Here it is slightly easier, because we can simply look at cases where the `orthoPair` is a species-specific deletion of either the query or the target.

=======
# HOX genes

## Hox 4

Appears to be duplicated in Bar so missing from HOG `N19.HOG0000192` in that
genome.

```{r Hox4}
sapply(orthoPairs[1:15], \(gb) {
  x <- gb |> plyranges::filter(HOG == "N19.HOG0000192")
  if (length(x) == 0) return(NULL)
  x})

Hox4 <- orthoPairs$Oki_Osa |> plyranges::filter(HOG == "N19.HOG0000192")
Hox4_1e4 <- GBreaks(target = granges(Hox4) + 1e4, query = Hox4$query + 1e4)
Hox4_4e4 <- GBreaks(target = granges(Hox4) + 4e4, query = Hox4$query + 4e4)
Hox4_1e5 <- GBreaks(target = granges(Hox4) + 1e5, query = Hox4$query + 1e5)

subsetByOverlaps(coa$Oki_Osa, Hox4_1e4) |> plotApairOfChrs("chr2", xlim = gb2xlim(Hox4_1e4))
subsetByOverlaps(coa$Oki_Osa, Hox4_4e4) |> plotApairOfChrs("chr2", xlim = gb2xlim(Hox4_4e4))
subsetByOverlaps(coa$Oki_Osa, Hox4_1e5) |> plotApairOfChrs("chr2", xlim = gb2xlim(Hox4_1e5))

## Genes
Hox4_4e4.genes <- transcripts$Oki |> subsetByOverlaps(Hox4_4e4 |> range())
mids <- Hox4_4e4.genes |> gr2dna_seg() |> dplyr::mutate(mid = (start + end) / 2) |> dplyr::pull(mid)
text <- Hox4_4e4.genes$tx_name |> as.character()
annot <- genoPlotR::annotation(x1=start(Hox4_4e4.genes), x2=end(Hox4_4e4.genes), text=text, rot=30)
gbs$Oki_Osa |> plotApairOfChrs("chr2", xlim = gb2xlim(Hox4_4e4), annotations = annot)
```

## Hox 1

HOG `N19.HOG0000193`.

```{r Hox1}
sapply(orthoPairs[1:15], \(gb) {
  x <- gb |> plyranges::filter(HOG == "N19.HOG0000193")
  if (length(x) == 0) return(NULL)
  x})

Hox1 <- orthoPairs$Oki_Osa |> plyranges::filter(HOG == "N19.HOG0000193")
Hox1_1e4 <- GBreaks(target = granges(Hox1) + 1e4, query = Hox1$query + 1e4)
Hox1_4e4 <- GBreaks(target = granges(Hox1) + 4e4, query = Hox1$query + 4e4)
Hox1_1e5 <- GBreaks(target = granges(Hox1) + 1e5, query = Hox1$query + 1e5)

subsetByOverlaps(coa$Oki_Osa, Hox1_1e4) |> plotApairOfChrs("chr2", xlim = gb2xlim(Hox1_1e4))
subsetByOverlaps(coa$Oki_Osa, Hox1_4e4) |> plotApairOfChrs("chr2", xlim = gb2xlim(Hox1_4e4))
subsetByOverlaps(coa$Oki_Osa, Hox1_1e5) |> plotApairOfChrs("chr2", xlim = gb2xlim(Hox1_1e5))

## Genes
Hox1_4e4.genes <- transcripts$Oki |> subsetByOverlaps(Hox1_4e4 |> range())
mids <- Hox1_4e4.genes |> gr2dna_seg() |> dplyr::mutate(mid = (start + end) / 2) |> dplyr::pull(mid)
text <- Hox1_4e4.genes$tx_name |> as.character()
annot <- genoPlotR::annotation(x1=start(Hox1_4e4.genes), x2=end(Hox1_4e4.genes), text=text, rot=30)
gbs$Oki_Osa |> plotApairOfChrs("chr2", xlim = gb2xlim(Hox1_4e4), annotations = annot)
```

# Session information

```{r session_information}
sessionInfo()
```
