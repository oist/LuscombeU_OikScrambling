---
title: "Orthogroup syntenies"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEncoding{UTF-8}
  %\VignetteIndexEntry{Orthogroup syntenies}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

Load packages and data
======================

See `?OikScrambling:::loadAllGenomes`, `?OikScrambling:::loadAllTranscriptsGR`,
and `vignette("LoadGenomicBreaks", package = "OikScrambling")` for how the
different objects are prepared.

```{r load_packages_and_data}
library("OikScrambling")   |> suppressPackageStartupMessages()
library("ggpubr")
library("SummarizedExperiment")
(genomes <- OikScrambling:::loadAllGenomes())
(transcripts <- OikScrambling:::loadAllTranscriptsGR() |> suppressWarnings())
(load("BreakPoints.Rdata"))
```

Orthogroups
-----------

Load Orthogroups for _Oikopleura_ from the `BreakpointsData` package with the
`GenomicBreaks::load_one_to_ones_SE()` function.  Original file is in
`/bucket/LuscombeU/common/Breakpoints/Orthologues/selTun+Apps+Amph+Vert_lp_100clstr_blast/OrthoFinder/Results_Oct07/Phylogenetic_Hierarchical_Orthogroups/N19.tsv`.
See `news(package = "BreakpointsData")` for inspecting changes in more details.

```{r load_one_to_ones}
# Note that for now, I am only worried about Oikopleura. Subset the transcripts to include only oiks.
transcripts = subset(transcripts, names(transcripts) %in% c('Oki', 'Osa', 'Bar', 'Nor', 'Aom', 'Kum'))
# Create a data frame that maps the original species names in the OrthoFinder 
# output to a set of new names that are easier to read.
species_name_map = data.frame(
  old_names=c("AOM-5-5f.prot.longest.fa_1", "Bar2_p4.Flye.prot.longest.fa_1", "KUM-M3-7f.prot.longest.fa_1", "OKI2018_I69.v2.prot.longest.fa_1", "OSKA2016v1.9.prot.longest.fa_1", "OdB3.v1.0.prot.fa_1.nohaplo"),
  new_names=c("Aom", "Bar", "Kum", "Oki", "Osa", "Nor")
)

load_one_to_ones_SE <- function(file, species_name_map) {
  # Read table
  pho <- read.delim(file, check.names = FALSE)
  
  # Remove all-NA columns
  pho <- pho[,sapply(pho, \(col) ! all(is.na(col)))]
  
  # Use the species name map to rename columns here.
  old_names <- colnames(pho)[4:ncol(pho)]
  new_names <- species_name_map[match(old_names, species_name_map$old_names),]$new_names
  colnames(pho)[4:ncol(pho)] <- new_names
  
  # Convert to SummarizedExperiment
  se <- SummarizedExperiment::SummarizedExperiment(
    assays = list(txs = pho[,-(1:3)]),
    rowData = DataFrame(pho[1:3])
  )

  assay(se, "txLists", withDimnames=FALSE) <- sapply(assay(se, 'txs'),     strsplit, split = ", ")
  rowData(se)$"txLists" <- sapply(assay(se, 'txs'),     strsplit, split = ", ")

  assay(se, "txCount", withDimnames=FALSE) <- sapply(DataFrame(assay(se, 'txLists')), \(x) sapply(x, length))  # Not sure why it only works when putting a DataFrame at the middle
  assay(se, "txLists")[(assay(se, "txCount")) == 0] <- NA_character_

  rowData(se)$txNames     <- apply(assay(se, "txLists"), 1, \(row) {
    row               |>  # Take a row from a matrix, a data.frame or a DataFrame
      as.list()       |>  # It is already list of character vectors, except for DataFrame subsets, which have to be coerced
      unlist()        |>  # Flatten it.  That is: `list(c("A", "B"), "C")` becomes `c("A", "B", "C")`
      unname()            # Remove element names
  })
  rowData(se)$txNames     <- sapply(rowData(se)$txNames, \(x) x[!is.na(x)])
  rowData(se)$txNames     <- CharacterList(rowData(se)$txNames)     # Convert to `CharacterList` for more comfortable display
  #rowData(se)$txNamesString <- unstrsplit(rowData(se)$txNames, ",") # If you would want it as a string...
  se
}

se <-  load_one_to_ones_SE(system.file("extdata/OrthoFinder/N19.tsv", package = "BreakpointsData"), species_name_map=species_name_map)

```

Flagging orthogroups by inferred homology class
-----------------------------------------------
While single-copy orthologues are arguably the most important component of the genome for between-species comparisons, it is also useful to know - or at least guess - at the other kinds of homologous relations that may exist within a gene family. This can identify, for example, clade-specific gene family expansions or clade-specific gene family deletions.

Here is an explanation of the orthogroup flags. Every HOG is annotated with a number of flags that are normally `TRUE` or `FALSE`. Clade-specific flags return either the name of the clade or `NA`. Details:

1. `present_in_all_spp`: All species in HOG have > 0 genes within the HOG
2. `one_to_one`: All species in HOG have exactly 1 gene within the HOG
3. `common_gene_duplication`: All species in HOG have > 0 genes within the HOG AND one or more species has > 1 gene
4. `expansion_species_specific`: One species has more than every other species, e.g. `c(sp1=1, sp2=1, sp3=3, sp4=2)`. Returns species name if true or `NA` if false
5. `expansion_clade_N`: One column for every clade. `TRUE` when ALL species in a clade are greater than ALL species outside the clade, e.g. `c(sp1=1, sp2=1, sp3=3, sp4=2)` is `TRUE` if `sp3+sp4` constitutes a clade
6. `expansion_reconciled`: An attempt to reconcile multiple clade-specific expansion flags. Clades can be nested (`clade1=c("sp1","sp2"), clade2=c("sp1","sp2","sp3","sp4")` and more than one clade-specific expansion can be `TRUE`. I attempt to resolve this as a single flag by assigning the flag as the clade with the most species (`flagAllPHO( ... , expansion_reconciliation="largest_clade"`, the default), but it can resolve to the clade with the highest mean count (`flagAllPHO( ... , expansion_reconciliation="mean_count"`)
7. `deletion_species_specific`: One species has 0 while all others have >0. Returns species name if true or `NA` if false
8. `deletion_clade_N`: Similar to `expansion_clade_N`, but different in that it does not care what the counts for other clades are. `TRUE` if all members of a clade have exactly 0 and `FALSE` if any species has >0
9. `deletion_reconciled`: Similar to `expansion_reconciled` and uses the same `largest_clade` tie breaking. `mean_count` does not work here because the mean count must be 0 for all species in a clade-specific deletion

Note that these flags are not mutually exclusive and can also be the inverse of one another. In our data, a clade-specific gene expansion may or may not correspond to a clade-specific deletion in other clades. E.g., `c(sp1=0, sp2=0, sp3=2, sp4=4)` could be a `sp1+sp2` deletion AND `sp3+sp4` expansion.

To flag orthogroups, we need a count matrix. Extract this from the `SummarizedExperiment` object `se` with `assay()` in the first part, then set up clades.

```{r orthoflagging}
se_m <- assay(se, 'txCount')
rownames(se_m) <- rowData(se)$HOG

# Create a list of clades. Each clade contains a vector of species names (the "new_names" of the next
# data frame. The clades can overlap.
clades=list("Oki_Kum"=c("Oki","Kum"), "Osa_Aom"=c("Osa","Aom"), "Bar_Nor"=c("Bar","Nor"), "Northern"=c("Osa","Aom","Bar","Nor"))

# clade_list: a named list where each list contains a vector of species.
# expansion_reconciliation: How to reconcile situations where more than 1 clade shows an expansion. 
#                           There are only two options: "largest_clade" and "mean_count".
#                           "largest_clade" flags it to the clade with the most species
#                           "mean_count" flags it to the clade with the highest mean count
# deletion_reconciliation:  As above. "largest_clade" makes the most sense most of the time.
#                           For now, no other options are supported.
orthoflags <- OikScrambling:::flagAllPHO(se_m, clade_list=clades, expansion_reconciliation = "largest_clade", deletion_reconciliation="largest_clade") |> suppressWarnings()
# The function warns whenever there is an inconsistency in clade expansion flags. You can run the function without
# suppressWarnings() to inspect these:
#     warnings()
# If you want to see too many warnings, you can also use deletion_warnings=T in the flagAllPHO function.
# This will warn you every time there is a deletion that satisfies more than one clade - which will be often!
# Several thousand times. So you can increase the number of warnings you see by using options(nwarnings=10000),
# then running the function above without suppressing the warnings.
```

You can then summarize the flags as follows:

```{r summarizing_orthoflags}
(apply(orthoflags, 2, function(x) table(unlist(x))))
```

The `orthoflags` object yields a matrix with one row per orthogroup, the count columns of the HOG table, and most importantly, a set of orthogroup annotations based on the counts of every species and clade. 

These annotations are not mutually exclusive. Consider the following:

```{r summarizing_orthoflags_2}
(assays(se)$txCount[15,])
(orthoflags[15,])
```

In this example, there is a species-specific expansion (Okinawa) at the same time as a clade-specific expansion (Oki/Kum). There is also a non-clade-specific deletion. The Osaka-Aomori clade is wholly deleted, while Bar-Nor is not.

In the following plots, I summarize some of the features of the `orthoflags` object.

```{r summarizing_orthoflags_3, fig.height=4, fig.width=6, dev=c("svg", "png")}
# Take a look at the distribution of different species flags. 
ggplot(orthoflags) +
  aes(x=reorder(unlist(expansion_reconciled), unlist(expansion_reconciled), function(x) length(x))) + geom_bar(stat="count", position="dodge") +
  facet_wrap(~ present_in_all_spp, scales = 'free') +
  xlab(NULL) +
  coord_flip() +
  ggtitle("Orthogroups by clade-specific HOG expansions (TRUE=present in all spp.)")

ggplot(orthoflags) +
  aes(x=reorder(unlist(deletion_reconciled), unlist(deletion_reconciled), function(x) length(x))) + geom_bar(stat="count", position="dodge") +
  xlab(NULL) +
  coord_flip() +
  ggtitle("Orthogroups by clade-specific HOG deletions")

ggplot(orthoflags) +
  aes(x=reorder(unlist(expansion_species_specific), unlist(expansion_species_specific), function(x) length(x))) + geom_bar(stat="count", position="dodge") +
  facet_wrap(~ present_in_all_spp, scales = 'free' ) +
  xlab(NULL) +
  coord_flip() +
  ggtitle("Orthogroups by species-specific HOG expansions (TRUE=present in all spp.)")

ggplot(orthoflags) +
  aes(x=reorder(unlist(deletion_species_specific), unlist(deletion_species_specific), function(x) length(x))) + geom_bar(stat="count", position="dodge") +
  xlab(NULL) +
  coord_flip() +
  ggtitle("Orthogroups by species-specific HOG deletions")
```

In order to get these orthogroup annotations into the `GBreaks` object later, we add them as metadata columns to the `transcripts` object from above. 

Since the indices of `orthoflags` are HOG IDs and not transcripts, we transmute the data a little to get a data frame indexed by a transcript ID. This format makes it easy to glom onto the transcripts file with `addMetadataToGRanges()`.

```{r flagging_orthogroups}
# The indices of the orthoflag matrix are HOG identifiers. So, relate the HOGs to transcripts and transfer
# the orthoflags to them.
rowData(se)$orthoFlags <- apply(orthoflags, 1, function(flags) flags)
# Transmute the SummarizedExperiment to make a species-specific data frame, indexed by gene IDs.
make_transcript_df <- function(SummarizedExperiment, species) {
  # Go over all of the rows in the annotation.
  tdf <- apply(rowData(se), 1, function(row) {
    # Grab some of the useful information.
    hog <- row$HOG
    og <- row$OG
    gtpc <- row$Gene.Tree.Parent.Clade
    #txNames <- row$txNames #|> CharacterList()
    hog_orthoflags <- row$orthoFlags
    species_transcripts <- row[[species]] |> unlist()
    # Make sure there are any transcripts for that species first.
    if(!identical(species_transcripts, character(0))) {
      species_df <- lapply(species_transcripts, function(transcript) {
        transcript_list <- list(hog=hog, txFull=transcript, og=og, gtpc=gtpc)
        # Note this hacky line that assumes gene IDs can be parsed out according to the .gX name
        # which is assigned by AUGUSTUS.
        if(grepl(".t", transcript)){
          transcript_list$txSimple <- paste("g", unlist(strsplit(transcript, ".g"))[2], sep="")
        } else {
          transcript_list$txSimple <- unlist(strsplit(transcript, "\\."))[2]
        }
        transcript_list <- append(transcript_list, hog_orthoflags)
        #transcript_list$txNames <- txNames
        transcript_list
      })
      species_df = do.call(rbind, species_df)
      species_df
    }
  })
  tdf <- do.call(rbind, tdf)
  # Make sure that the columns aren't themselves lists.
  tdf <- apply(tdf, 2, unlist)
  tdf <- as.data.frame(tdf)
  tdf$orthoFlagDF <- apply(tdf, 1, function(row) as.data.frame(as.list(row[5:20])))
  tdf
}
orthoflagsDF     <- SimpleList()
orthoflagsDF$Oki <- make_transcript_df(se, 'Oki')
orthoflagsDF$Osa <- make_transcript_df(se, 'Osa')
orthoflagsDF$Bar <- make_transcript_df(se, 'Bar')
orthoflagsDF$Kum <- make_transcript_df(se, 'Kum')
orthoflagsDF$Aom <- make_transcript_df(se, 'Aom')
orthoflagsDF$Nor <- make_transcript_df(se, 'Nor')
```

The `orthoflagsDF` object contains the same information as the `orthoflags` object, but is in a slightly more convenient format for gluing on to the transcript annotations. We do so here:

```{r gluing_orthoflags}
transcripts <- sapply(names(transcripts), function(sp){
  stitched <- OikScrambling:::addMetadataToGRanges(gr=transcripts[[sp]], df=orthoflagsDF[[sp]], gr_key='tx_name', df_key='txSimple', df_col_name = 'orthoFlagDF', rename_meta = 'orthoFlagDF')
  stitched
}) |> SimpleList()
```

Prepare GBreak objects
======================

```{r creating_gbreaks}
orthoPairToGBreaks <- function(name1, name2, annot1, annot2, treeName="N19") {
  orthoPairs <- OikScrambling:::load_one_to_ones(
    system.file(paste0("extdata/OrthoFinder/",treeName,".tsv"), package = "BreakpointsData"),
    c(name1, name2))

  IDs2GRanges <- function (IDs, annot) {
    prefix <- Biobase::lcPrefix(IDs)                  # Guess prefix in transcript IDs from HOG files
    not_prefix <- Biobase::lcPrefix(annot$tx_name)    # Remove trailing characters that are part of the name
    not_prefix <- paste0(not_prefix,"$")              # Anchor to end of the string
    prefix <- sub(not_prefix, "", prefix)             # Finalise prefix
    IDs <- sub(prefix, "", IDs)                       # Remove prefix from IDS
    names(annot) <- annot$tx_name                     # Store transcript name in names slot
    gr <- annot[IDs]                                  # Sort by ID
    strand(gr) <- "*"                                 # Make strandless
    gr                                                # Return the object
  }
  
  gb       <- IDs2GRanges(orthoPairs[,name1], annot1)
  gb$query <- IDs2GRanges(orthoPairs[,name2], annot2)
  gb <- GenomicBreaks:::GBreaks(gb)
  sort(gb)
}

orthoPairToGBreaks_all_Oiks <- function(treeName) {
  orthoPairs <- SimpleList()
  orthoPairs$Oki_Osa <- orthoPairToGBreaks("OKI2018_I69.v2.prot.longest.fa_1", "OSKA2016v1.9.prot.longest.fa_1",   transcripts$Oki, transcripts$Osa, treeName)
  orthoPairs$Oki_Bar <- orthoPairToGBreaks("OKI2018_I69.v2.prot.longest.fa_1", "Bar2_p4.Flye.prot.longest.fa_1",   transcripts$Oki, transcripts$Bar, treeName)
  orthoPairs$Oki_Kum <- orthoPairToGBreaks("OKI2018_I69.v2.prot.longest.fa_1", "KUM-M3-7f.prot.longest.fa_1",      transcripts$Oki, transcripts$Kum, treeName)
  orthoPairs$Oki_Aom <- orthoPairToGBreaks("OKI2018_I69.v2.prot.longest.fa_1", "AOM-5-5f.prot.longest.fa_1",       transcripts$Oki, transcripts$Aom, treeName)
  orthoPairs$Oki_Nor <- orthoPairToGBreaks("OKI2018_I69.v2.prot.longest.fa_1", "OdB3.v1.0.prot.fa_1.nohaplo",      transcripts$Oki, transcripts$Nor, treeName)
  
  orthoPairs$Osa_Bar <- orthoPairToGBreaks("OSKA2016v1.9.prot.longest.fa_1",   "Bar2_p4.Flye.prot.longest.fa_1",   transcripts$Osa, transcripts$Bar, treeName)
  orthoPairs$Osa_Oki <- orthoPairToGBreaks("OSKA2016v1.9.prot.longest.fa_1",   "OKI2018_I69.v2.prot.longest.fa_1", transcripts$Osa, transcripts$Oki, treeName)
  orthoPairs$Osa_Kum <- orthoPairToGBreaks("OSKA2016v1.9.prot.longest.fa_1",   "KUM-M3-7f.prot.longest.fa_1",      transcripts$Osa, transcripts$Kum, treeName)
  orthoPairs$Osa_Aom <- orthoPairToGBreaks("OSKA2016v1.9.prot.longest.fa_1",   "AOM-5-5f.prot.longest.fa_1",       transcripts$Osa, transcripts$Aom, treeName)
  orthoPairs$Osa_Nor <- orthoPairToGBreaks("OSKA2016v1.9.prot.longest.fa_1",   "OdB3.v1.0.prot.fa_1.nohaplo",      transcripts$Osa, transcripts$Nor, treeName)
  
  orthoPairs$Bar_Osa <- orthoPairToGBreaks("Bar2_p4.Flye.prot.longest.fa_1",   "OSKA2016v1.9.prot.longest.fa_1",   transcripts$Bar, transcripts$Osa, treeName)
  orthoPairs$Bar_Oki <- orthoPairToGBreaks("Bar2_p4.Flye.prot.longest.fa_1",   "OKI2018_I69.v2.prot.longest.fa_1", transcripts$Bar, transcripts$Oki, treeName)
  orthoPairs$Bar_Kum <- orthoPairToGBreaks("Bar2_p4.Flye.prot.longest.fa_1",   "KUM-M3-7f.prot.longest.fa_1",      transcripts$Bar, transcripts$Kum, treeName)
  orthoPairs$Bar_Aom <- orthoPairToGBreaks("Bar2_p4.Flye.prot.longest.fa_1",   "AOM-5-5f.prot.longest.fa_1",       transcripts$Bar, transcripts$Aom, treeName)
  orthoPairs$Bar_Nor <- orthoPairToGBreaks("Bar2_p4.Flye.prot.longest.fa_1",   "OdB3.v1.0.prot.fa_1.nohaplo",      transcripts$Bar, transcripts$Nor, treeName)
  
  orthoPairs[ 1:5 ] <- sapply(orthoPairs[ 1:5 ],  flagLongShort, longShort$Oki)
  orthoPairs[ 6:10] <- sapply(orthoPairs[ 6:10],  flagLongShort, longShort$Osa)
  orthoPairs[11:15] <- sapply(orthoPairs[11:15],  flagLongShort, longShort$Bar)
  
  orthoPairs
}

orthoPairs         <- orthoPairToGBreaks_all_Oiks("N19")
#orthoPairs$Ply_Ros <- orthoPairToGBreaks("C_int_P.prot.longest.fa_1", "C_int_R.prot.longest.fa_1"
#                                        , transcripts$Ply, transcripts$Ros, treeName="N20")

# Same as above but using the same core orthogroups for all species.
#orthoPairs_core         <- orthoPairToGBreaks_all_Oiks("N3")
#orthoPairs_core$Ply_Ros <- orthoPairToGBreaks("C_int_P.prot.longest.fa_1", "C_int_R.prot.longest.fa_1"
#                                             , transcripts$Ply, transcripts$Ros, treeName="N3")

sapply(orthoPairs, length)
#sapply(orthoPairs_core, length)
```

Problem: some annotations overlap
---------------------------------

```{r fix_gbreaks}
transcripts$Bar |> length()
transcripts$Bar |> reduce(min = 0) |> length()

flagOverlaps <- function(gr) {
  # Find overlaps
  ov <- findOverlaps(gr)
  # Index of self hits in the gr object
  idx <- queryHits(ov[!isSelfHit(ov)])
  # Convert to Boolean indexing the gr object
  seq_along(gr) %in% idx
}

transcripts$Bar[flagOverlaps(transcripts$Bar)]

# Show examples
orthoPairs$Oki_Osa[flagOverlaps(orthoPairs$Oki_Osa)]
orthoPairs$Oki_Osa$query[flagOverlaps(orthoPairs$Oki_Osa$query)]

# Remove and show how much was removed

orthoPairsFiltered <- sapply(orthoPairs, function(gb) {
  gb <- gb[!flagOverlaps(gb)]
  gb <- gb[!flagOverlaps(gb$query)]
  gb
}) |> SimpleList()

# orthoPairsFiltered_core <- sapply(orthoPairs_core, function(gb) {
#   gb <- gb[!flagOverlaps(gb)]
#   gb <- gb[!flagOverlaps(gb$query)]
#   gb
# }) |> SimpleList()

sapply(orthoPairs, length) - sapply(orthoPairsFiltered, length)
#sapply(orthoPairs_core, length) - sapply(orthoPairsFiltered_core, length)
```

Exploring patterns in the pairwise objects
------------------------------------------

Coalesce syntenic blocks and annotate them
------------------------------------------

```{r coalesce}
coalOrtho <- function(gb) {
  # Coalesce
  coal <- coalesce_contigs(gb)
  
  # Map annotations to the coalesced blocks
  ov <- findOverlaps(coal, gb)
  
  # Extract gene names mapped to each blocks
  coal$geneNames <- CharacterList(split(names(gb)[subjectHits(ov)], queryHits(ov))) |> unname()
  # We can use the `ov` object for query ranges as well because of the way `coal` was constructed.
  coal$query$geneNames <- CharacterList(split(names(gb$query)[subjectHits(ov)], queryHits(ov))) |> unname()
  
  # Extract dNdS values
  coal$dNdS_GUIDANCE2  <- NumericList(split(gb$dNdS_GUIDANCE2 [subjectHits(ov)], queryHits(ov)))
  coal$dNdS_HmmCleaner <- NumericList(split(gb$dNdS_HmmCleaner[subjectHits(ov)], queryHits(ov)))
  coal$dNdS_PRANK      <- NumericList(split(gb$dNdS_PRANK     [subjectHits(ov)], queryHits(ov)))
  # We just copy dNdS values to query ranges because they are the same.
  coal$query$dNdS_GUIDANCE2  <- coal$dNdS_GUIDANCE2
  coal$query$dNdS_HmmCleaner <- coal$dNdS_HmmCleaner
  coal$query$dNdS_PRANK      <- coal$dNdS_PRANK
  
  # Add orthoflags. Since the flags are assigned to orthogroups, the flags are the same
  # for all single-copy orthologues.
  coal$orthoFlagDF <- split(gb$orthoFlagDF [subjectHits(ov)], queryHits(ov)) |> unname()

  # Count genes per syntenic block
  coal$geneNumber <- sapply(coal$geneNames, length)
  
  coal
}

orthoBlocks <- sapply(orthoPairsFiltered[1:15], coalOrtho) |> SimpleList()
# orthoBlocks$Ply_Ros <- coalesce_contigs(orthoPairsFiltered$Ply_Ros)
orthoBlocks[ 1:5 ] <- sapply(orthoBlocks[ 1:5 ],  flagLongShort, longShort$Oki)
orthoBlocks[ 6:10] <- sapply(orthoBlocks[ 6:10],  flagLongShort, longShort$Osa)
orthoBlocks[11:15] <- sapply(orthoBlocks[11:15],  flagLongShort, longShort$Bar)

# orthoBlocks_core <- sapply(orthoPairsFiltered_core[1:15], coalOrtho) |> SimpleList()
# orthoBlocks_core$Ply_Ros <- coalesce_contigs(orthoPairsFiltered_core$Ply_Ros)
# orthoBlocks_core[ 1:5 ] <- sapply(orthoBlocks_core[ 1:5 ],  flagLongShort, longShort$Oki)
# orthoBlocks_core[ 6:10] <- sapply(orthoBlocks_core[ 6:10],  flagLongShort, longShort$Osa)
# orthoBlocks_core[11:15] <- sapply(orthoBlocks_core[11:15],  flagLongShort, longShort$Bar)

sapply(orthoBlocks, length)
#sapply(orthoBlocks_core, length)

```

Quick overview of the results
=============================

Size distribution of the blocks
-------------------------------

```{r quick_overview}
stem(orthoBlocks$Oki_Osa$geneNumber)
table(orthoBlocks$Oki_Osa$geneNumber)
orthoBlocks$Oki_Osa[order(orthoBlocks$Oki_Osa$geneNumber)] |> tail(11)

stem(orthoBlocks$Oki_Kum$geneNumber)
table(orthoBlocks$Oki_Kum$geneNumber)
orthoBlocks$Oki_Kum[order(orthoBlocks$Oki_Kum$geneNumber)] |> tail(11)
```

Gene Order Conservation is smaller in short arms
------------------------------------------------

```{r GOC}
orthoBlocks_LSnoNA <- sapply(orthoBlocks[1:15], function(gb) gb[!is.na(gb$Arm)]) |> SimpleList()
sapply(orthoBlocks_LSnoNA, length)

df <- sapply(orthoBlocks_LSnoNA,
             function(gb) tapply(gb, paste(seqnames(gb), gb$Arm), GOC))

apply(df, 2, \(x) {
  tst <- t.test(x[c(1,3,5)], x[c(2,4,6)])
  c(pval=tst$p.value, mx=tst$estimate[1], my=tst$estimate[2])
}) 
```

Fraction of the genome covered or syntenic
------------------------------------------

```{r fraction_aligned}
uncov  <- BiocParallel::bplapply(orthoPairsFiltered, cleanGaps) |> SimpleList()
unsyn  <- BiocParallel::bplapply(orthoBlocks,        cleanGaps) |> SimpleList()

  covered_tot    <- sapply(orthoPairsFiltered,   \(x) sum(width(x)))
  syntenic_tot   <- sapply(orthoBlocks,          \(x) sum(width(x)))
uncovered_tot    <- sapply(uncov,                \(x) sum(width(x)))
unsyntenic_tot   <- sapply(unsyn,                \(x) sum(width(x)))

(syn_summary <- cbind(
  covered_frac   = covered_tot   / ( covered_tot   + uncovered_tot ) * 100,
  orthogenes_n   = sapply(orthoPairsFiltered, length),
  syntenic_frac  = syntenic_tot  / ( syntenic_tot  + unsyntenic_tot ) * 100,
  syntenic_reg   = sapply(orthoBlocks, length)
 )|> as.data.frame())

sapply(syn_summary, \(x) tapply(x, row.names(syn_summary) |> OikScrambling:::compDistance(), mean))   |> round(1)
sapply(syn_summary, \(x) tapply(x, row.names(syn_summary) |> OikScrambling:::compDistance(), median)) |> round(1)
sapply(syn_summary, \(x) tapply(x, row.names(syn_summary) |> OikScrambling:::compDistance(), sd))     |> round(1)
```

Unfortunately, there are not enough transcripts from Ciona that are part of the
pan-tunicate orthogroup set, which makes the comparison difficult between
Oikopleura and Ciona…

```{r fraction_aligned_core}
# uncov  <- BiocParallel::bplapply(orthoPairsFiltered_core, cleanGaps) |> SimpleList()
# unsyn  <- BiocParallel::bplapply(orthoBlocks_core,        cleanGaps) |> SimpleList()
# 
#   covered_tot    <- sapply(orthoPairsFiltered_core,   \(x) sum(width(x)))
#   syntenic_tot   <- sapply(orthoBlocks_core,          \(x) sum(width(x)))
# uncovered_tot    <- sapply(uncov,                     \(x) sum(width(x)))
# unsyntenic_tot   <- sapply(unsyn,                     \(x) sum(width(x)))
# 
# (syn_summary_core <- cbind(
#   covered_frac   = covered_tot   / ( covered_tot   + uncovered_tot ) * 100,
#   orthogenes_n   = sapply(orthoPairsFiltered_core, length),
#   syntenic_frac  = syntenic_tot  / ( syntenic_tot  + unsyntenic_tot ) * 100,
#   syntenic_reg   = sapply(orthoBlocks_core, length)
#  )|> as.data.frame())
# 
# sapply(syn_summary_core, \(x) tapply(x, row.names(syn_summary_core) |> OikScrambling:::compDistance(), mean))   |> round(1)
# sapply(syn_summary_core, \(x) tapply(x, row.names(syn_summary_core) |> OikScrambling:::compDistance(), median)) |> round(1)
# sapply(syn_summary_core, \(x) tapply(x, row.names(syn_summary_core) |> OikScrambling:::compDistance(), sd))     |> round(1)
```

Agreement with nucleotide alignments
------------------------------------

```{r DNA_prot_comparison}
(gb_P <- orthoBlocks$Bar_Osa)
sum(width(gb_P))
(gb_N <- coa$Bar_Osa)
sum(width(gb_N))
(ov <- subsetByOverlaps(gb_P, gb_N, type = "within"))
(jaccard <- sum(width(ov)) / sum(width(reduce(c(gb_P, gb_N)))))

gb_P <- gb_P[gb_P$geneNumber > 1]
gb_P
sum(gb_P$geneNumber)
(valid <- subsetByOverlaps(gb_P, gb_N, type = "within"))
sum(valid$geneNumber)
sum(width(valid))
```

Question: what does interrupt the colinearity of nucleotide regions in gene-centric
colinear regions ?

Genes per syntenic block
------------------------
```{r genes_per_block_1, fig.height=4, fig.width=6, dev=c("svg", "png")}
# Oki-Osa
# Genes per syntenic block
plot1 <- ggplot(as.data.frame(orthoBlocks$Oki_Osa), aes(x=geneNumber)) +
  geom_histogram() +
  ggtitle("Oki/Osa: genes per syntenic block")
# Genes per syntenic block, but on a logarithmic scale.
# Note the trickery to ensure counts of 1 are shown.
plot2 <- ggplot(as.data.frame(orthoBlocks$Oki_Osa), aes(x=geneNumber)) +
  geom_histogram(aes(y=..count..*10)) +
  scale_y_log10(labels=function(y) y/10, name="count") +
  ggtitle("Oki/Osa: genes per syntenic block (log10 axis)")

ggarrange(plot1, plot2)

# Oki-Bar
plot1 <- ggplot(as.data.frame(orthoBlocks$Oki_Bar), aes(x=geneNumber )) +
  geom_histogram() +
  ggtitle("Oki/Bar: genes per syntenic block")
plot2 <- ggplot(as.data.frame(orthoBlocks$Oki_Bar), aes(x=geneNumber)) +
  geom_histogram(aes(y=..count..*10)) +
  scale_y_log10(labels=function(y) y/10, name="count") +
  ggtitle("Oki/Bar: genes per syntenic block (log10 axis)")
ggarrange(plot1, plot2)

# Osa-Bar
plot1 <- ggplot(as.data.frame(orthoBlocks$Osa_Bar), aes(x=geneNumber )) +
  geom_histogram() +
  ggtitle("Osa/Bar: genes per syntenic block")
plot2 <- ggplot(as.data.frame(orthoBlocks$Osa_Bar), aes(x=geneNumber)) +
  geom_histogram(aes(y=..count..*10)) +
  scale_y_log10(labels=function(y) y/10, name="count") +
  ggtitle("Osa/Bar: genes per syntenic block (log10 axis)")
ggarrange(plot1, plot2)

```

Where do these blocks occur?

```{r genes_per_block_2, fig.height=4, fig.width=6, dev=c("svg", "png")}
big_chr = c("chr1","chr2","PAR","XSR","YSR")
dat = as.data.frame(orthoBlocks$Oki_Osa)
dat = subset(dat, dat$seqnames %in% big_chr)
simple_plot <- ggplot( dat ) +
  aes(x=geneNumber) +
  geom_bar(stat='count') +
  facet_wrap(seqnames~Arm, ncol=2) +
  xlab('Genes per block') +
  geom_histogram(aes(y=..count..*10), binwidth = 1) +
  scale_y_log10(labels=function(y) y/10, name="count") +
  ggtitle("Oki-Osa: All-species HOGs by genomic location")
simple_plot
```

```{r genes_per_block_3, fig.height=4, fig.width=6, dev=c("svg", "png")}
big_chr = c("chr1","chr2","PAR","XSR","YSR")
dat = subset(as.data.frame(orthoBlocks$Oki_Bar), as.data.frame(orthoBlocks$Oki_Bar)$seqnames %in% big_chr)
simple_plot <- ggplot( dat ) +
  aes(x=geneNumber) +
  geom_bar(stat='count') +
  facet_wrap(seqnames~Arm, ncol=2) +
  xlab('Genes per block') +
  geom_histogram(aes(y=..count..*10), binwidth = 1) +
  scale_y_log10(labels=function(y) y/10, name="count") +
  ggtitle("Oki-Bar: All-species HOGs by genomic location")
simple_plot
```

```{r genes_per_block_4, fig.height=4, fig.width=6, dev=c("svg", "png")}
big_chr = c("Chr1","Chr2","PAR","XSR","YSR")
dat = subset(as.data.frame(orthoBlocks$Osa_Bar), as.data.frame(orthoBlocks$Osa_Bar)$seqnames %in% big_chr)
simple_plot <- ggplot( dat ) +
  aes(x=geneNumber) +
  geom_bar(stat='count') +
  facet_wrap(seqnames~Arm, ncol=2) +
  xlab('Genes per block') +
  geom_histogram(aes(y=..count..*10), binwidth = 1) +
  scale_y_log10(labels=function(y) y/10, name="count") +
  ggtitle("Osa-Bar: All-species HOGs by genomic location")
simple_plot
```

Genomic locations of HOGs found in all species
----------------------------------------------
Genes that are found in all species are found where in the genome?

```{r basic_flags_1, fig.height=4, fig.width=6, dev=c("svg", "png")}
big_chr = c("chr1","chr2","PAR","XSR","YSR")
dat = subset(as.data.frame(orthoPairs$Oki_Osa), as.data.frame(orthoPairs$Oki_Osa)$seqnames %in% big_chr)
simple_plot <- ggplot( dat ) +
  aes(x=unlist(lapply(orthoFlagDF, function(x) x$present_in_all_spp))) +
  geom_bar(stat='count') +
  facet_wrap(~Arm) +
  xlab('All-species HOG') +
  ggtitle("Oki-Osa: All-species HOGs by genomic location")

simple_plot

complex_plot <- ggplot( dat ) +
  aes(x=unlist(lapply(orthoFlagDF, function(x) x$present_in_all_spp))) +
  geom_bar(stat='count') +
  geom_text(aes(label=paste(..count.., ' (', scales::percent((..count..)/sum(..count..), accuracy = 0.1), ')', sep=''), y=..count..), stat='count', vjust=-0.5, size=2.5) +
  scale_y_continuous(expand=expansion(mult=c(0, 0.35))) +
  facet_wrap(seqnames~Arm, ncol=2) +
  xlab('All-species HOG') +
  ggtitle("Oki-Osa: All-species HOGs by genomic location")

complex_plot
```

```{r basic_flags_2, fig.height=4, fig.width=6, dev=c("svg", "png")}
big_chr = c("chr1","chr2","PAR","XSR","YSR")
dat = subset(as.data.frame(orthoPairs$Oki_Bar), as.data.frame(orthoPairs$Oki_Bar)$seqnames %in% big_chr)
simple_plot <- ggplot( dat ) +
  aes(x=unlist(lapply(orthoFlagDF, function(x) x$present_in_all_spp))) +
  geom_bar(stat='count') +
  facet_wrap(~Arm) +
  xlab('All-species HOG') +
  ggtitle("Oki-Bar: All-species HOGs by genomic location")

simple_plot

complex_plot <- ggplot( dat ) +
  aes(x=unlist(lapply(orthoFlagDF, function(x) x$present_in_all_spp))) +
  geom_bar(stat='count') +
  geom_text(aes(label=paste(..count.., ' (', scales::percent((..count..)/sum(..count..), accuracy = 0.1), ')', sep=''), y=..count..), stat='count', vjust=-0.5, size=2.5) +
  scale_y_continuous(expand=expansion(mult=c(0, 0.35))) +
  facet_wrap(seqnames~Arm, ncol=2) +
  xlab('All-species HOG') +
  ggtitle("Oki-Bar: All-species HOGs by genomic location")

complex_plot
```

```{r basic_flags_3, fig.height=4, fig.width=6, dev=c("svg", "png")}
big_chr = c("Chr1","Chr2","PAR","XSR","YSR")
dat = subset(as.data.frame(orthoPairs$Osa_Bar), as.data.frame(orthoPairs$Osa_Bar)$seqnames %in% big_chr)
simple_plot <- ggplot( dat ) +
  aes(x=unlist(lapply(orthoFlagDF, function(x) x$present_in_all_spp))) +
  geom_bar(stat='count') +
  facet_wrap(~Arm) +
  xlab('All-species HOG') +
  ggtitle("Osa-Bar: All-species HOGs by genomic location")

simple_plot

complex_plot <- ggplot( dat ) +
  aes(x=unlist(lapply(orthoFlagDF, function(x) x$present_in_all_spp))) +
  geom_bar(stat='count') +
  geom_text(aes(label=paste(..count.., ' (', scales::percent((..count..)/sum(..count..), accuracy = 0.1), ')', sep=''), y=..count..), stat='count', vjust=-0.5, size=2.5) +
  scale_y_continuous(expand=expansion(mult=c(0, 0.35))) +
  facet_wrap(seqnames~Arm, ncol=2) +
  xlab('All-species HOG') +
  ggtitle("Osa-Bar: All-species HOGs by genomic location")

complex_plot
```

Taken together: in general, a greater fraction of genes on long arms can be found in all species. Let us continue this logic further.

Genomic locations of orthogroups with different properties
==========================================================

A HOG is either one-to-one (exactly one HOG constituent from every species) or not. Not-one-one-one gene means either one or more species has >1 gene in the same HOG without being resolved as a clade-specific HOG, or else the gene is missing in one or more species. Both can be true at once (e.g., counts of 6, 1, 1, 1, 3, 0)

Where are one-to-one orthologues located in the genome?

```{r basic_flags_4, fig.height=4, fig.width=6, dev=c("svg", "png")}
big_chr = c("chr1","chr2","PAR","XSR","YSR")
dat = subset(as.data.frame(orthoPairs$Oki_Osa), as.data.frame(orthoPairs$Oki_Osa)$seqnames %in% big_chr)
simple_plot <- ggplot( dat ) +
  aes(x=unlist(lapply(orthoFlagDF, function(x) x$one_to_one))) +
  geom_bar(stat='count') +
  facet_wrap(~Arm) +
  xlab('One-to-one HOG') +
  ggtitle("Oki-Osa: One-to-one HOGs by genomic location")

simple_plot

complex_plot <- ggplot( dat ) +
  aes(x=unlist(lapply(orthoFlagDF, function(x) x$present_in_all_spp))) +
  geom_bar(stat='count') +
  geom_text(aes(label=paste(..count.., ' (', scales::percent((..count..)/sum(..count..), accuracy = 0.1), ')', sep=''), y=..count..), stat='count', vjust=-0.5, size=2.5) +
  scale_y_continuous(expand=expansion(mult=c(0, 0.35))) +
  facet_wrap(seqnames~Arm, ncol=2) +
  xlab('One-to-one HOG') +
  ggtitle("Oki-Osa: One-to-one HOGs by genomic location")

complex_plot
```

```{r basic_flags_5, fig.height=4, fig.width=6, dev=c("svg", "png")}
big_chr = c("chr1","chr2","PAR","XSR","YSR")
dat = subset(as.data.frame(orthoPairs$Oki_Bar), as.data.frame(orthoPairs$Oki_Bar)$seqnames %in% big_chr)
simple_plot <- ggplot( dat ) +
  aes(x=unlist(lapply(orthoFlagDF, function(x) x$one_to_one))) +
  geom_bar(stat='count') +
  facet_wrap(~Arm) +
  xlab('One-to-one HOG') +
  ggtitle("Oki-Bar: One-to-one HOGs by genomic location")

simple_plot

complex_plot <- ggplot( dat ) +
  aes(x=unlist(lapply(orthoFlagDF, function(x) x$present_in_all_spp))) +
  geom_bar(stat='count') +
  geom_text(aes(label=paste(..count.., ' (', scales::percent((..count..)/sum(..count..), accuracy = 0.1), ')', sep=''), y=..count..), stat='count', vjust=-0.5, size=2.5) +
  scale_y_continuous(expand=expansion(mult=c(0, 0.35))) +
  facet_wrap(seqnames~Arm, ncol=2) +
  xlab('One-to-one HOG') +
  ggtitle("Oki-Bar: One-to-one HOGs by genomic location")

complex_plot
```

```{r basic_flags_6, fig.height=4, fig.width=6, dev=c("svg", "png")}
big_chr = c("Chr1","Chr2","PAR","XSR","YSR")
dat = subset(as.data.frame(orthoPairs$Osa_Bar), as.data.frame(orthoPairs$Osa_Bar)$seqnames %in% big_chr)
simple_plot <- ggplot( dat ) +
  aes(x=unlist(lapply(orthoFlagDF, function(x) x$one_to_one))) +
  geom_bar(stat='count') +
  facet_wrap(~Arm) +
  xlab('One-to-one HOG') +
  ggtitle("Osa-Bar: One-to-one HOGs by genomic location")

simple_plot

complex_plot <- ggplot( dat ) +
  aes(x=unlist(lapply(orthoFlagDF, function(x) x$present_in_all_spp))) +
  geom_bar(stat='count') +
  geom_text(aes(label=paste(..count.., ' (', scales::percent((..count..)/sum(..count..), accuracy = 0.1), ')', sep=''), y=..count..), stat='count', vjust=-0.5, size=2.5) +
  scale_y_continuous(expand=expansion(mult=c(0, 0.35))) +
  facet_wrap(seqnames~Arm, ncol=2) +
  xlab('One-to-one HOG') +
  ggtitle("Osa-Bar: One-to-one HOGs by genomic location")

complex_plot
```

Thus, it seems that whether or not a gene participates in a one-to-one HOG also depends on where the gene is encoded. Long chromosome arms are more often host to one-to-ones, and this is also true for the XSR, which always has the highest proportion of one-to-one genes across all species pairs.

Species- and clade-specific HOG expansions
------------------------------------------
In the following section, I attempt to identify species- and clade-specific gene duplications using counts from HOG counts. For a given `query`-`target` combination, the `collect_clade_expansions()` function extracts from a `GBreaks` object 3 different data frames:

1. Clade-specific duplications common to the query and target
2. Species-specific duplications in the query genome (referred to as `sp1` in the code below)
3. Species-specific duplications in the target genome (referred to as `sp2` in the code below)

N.B. Note that this step uses naming conventions that assume the clade name of `sp1` + `sp2` is exactly `sp1_sp1`. These strings are matched to some data from the `orthoFlagsDF` (`expansion_clade_X_Y`). Ensure that clade names line up precisely with species names.

In order to identify these events in the coordinate system of the query (chromosomal) assembly, it is necessary to formulate objects similar to `orthoPairs`. Because these genes can be species-specific, there may not be a region that corresponds to that gene in the other. This is how `collectCladeExpansions()` deals with this:

* Clade-specific genes: These clade-specific genes must be present in both the query and target, so these are present within the `orthoPairs` already.
* Query-specific genes: Generate a new `orthoPairs`-like object starting from the query genome transcript coordinates. All target coordinates and features become NA
* Target-specific genes: It is not possible to put a target-specific gene on the query genome. However, the position of a target-specific gene can be inferred according to this logic: 
+ Ensure the target genes flanking the target-specific gene are encoded on the same target contig.
+ If they are, then the flanking genes might have corresponding genes in the query genome. Ensure both flanking genes can be found in `orthoPairs`.
+ If flanking genes in `orthoPairs`, ensure that both of the corresponding genes in the query genome are encoded on the same query chromosome.
+ If orthologues of the flanking genes are both on the same chromosome, ensure that they are also collinear on that chromosome.
+ If they are, then create a new `orthoPairs`-like entry for the target genome. Its position on the reference genome is assinged as the end of the end and start of the flanking orthologues.

**Importantly**, the method used to co-ordinate the position of a target-specific gene expansion is rudimentary and will only work in limited scenarios. For example, collinearity is higher on long arms, which will bias the position of target-specific genes towards the long arms.

```{r gene_expansions_1}
# Find midpoints of a GRanges.
grMidpoint <- function(gr) {
  starts <- as.data.frame(ranges(gr))$start
  ends <- as.data.frame(ranges(gr))$end
  mids <- (starts+ends)/2
  mids
}

# Given a chromosome-scale assembly (sp1) and a second species of a clade (sp2),
# plot coordinates of clade-specific gene expansions (common to sp1+sp2) and
# species-specific expansions.
collectCladeExpansions <- function(orthopairs, sp1, sp2, bigChr, longShort) {
  result <- SimpleList()
  orthopair <- orthopairs[[paste(sp1, sp2, sep="_")]]
  orthopair$midpoint <- grMidpoint(orthopair)
  orthopair <- as.data.frame(orthopair)
  orthopair <- subset(orthopair, orthopair$seqnames %in% big_chr)

  # Identify clade-specific expansions
  # Get some data we will need later. The Clade-specific data frame is easiest because it just needs to be subset from the pair by flag.
  dat_clade <- orthopair[as.logical(unlist(lapply(orthopair$orthoFlagDF, function(x) x[[paste("expansion_clade_", sp1, "_", sp2, sep="")]] )))==TRUE,] |> as.data.frame()
  result[[paste(sp1, sp2, sep="_")]] <- dat_clade

  # sp1-specific expansion
  # sp1 must be the chromosomal assembly. We transfer the coordinates of its species-specific gene family
  # expansions into a dummy orthoPairs object to facilitate rbind'ing later.
  transcripts_sp1 <- as.data.frame(transcripts[[sp1]])
  transcripts_sp1$midpoint <- grMidpoint(transcripts[[sp1]])
  # Subset transcripts to only the longest per gene. This is needed later because the index
  # of the gene is used to determine when genes are collinear.
  transcripts_sp1$geneid <- unname(sapply(transcripts_sp1$tx_name, function(s) unlist(strsplit(s, "\\.t"))[1] ))
  # Split by geneID, select the largest transcript, then glue back together
  transcripts_sp1 <- split(transcripts_sp1, transcripts_sp1$geneid)
  transcripts_sp1 <- lapply(transcripts_sp1, function(geneid) {
    biggest_gene = geneid[which.max(geneid$width),]
    biggest_gene
  })
  transcripts_sp1 <- do.call(rbind, transcripts_sp1) |> as.data.frame()
  transcripts_sp1 <- transcripts_sp1[order(transcripts_sp1$seqnames, transcripts_sp1$start),] |> as.data.frame()
  df_sp1 <- transcripts_sp1
  df_sp1 <- subset(df_sp1, df_sp1$seqnames %in% big_chr) # Subset to only chromosome-scale scaffolds
  df_sp1 <- df_sp1[which(unlist(lapply(df_sp1$orthoFlagDF, function(x) x$expansion_species_specific ))==sp1),] # Subset to species-specific expansions

  # Add a bunch of empty columns to make the object look like an orthoPair
  df_sp1 <- cbind(df_sp1, query.seqnames=NA, query.start=NA, query.end=NA, query.width=NA, query.strand=NA, query.tx_id=NA, query.tx_name=NA, query.dNdS_GUIDANCE2=NA, query.dNdS_HmmCleaner=NA, query.dNdS_PRANK=NA, query.orthoFlagDF=df_sp1$orthoFlagDF)
  df_sp1 <- flagLongShort(GRanges(df_sp1), longShort) |> as.data.frame() # Add back in long-short arm information
  df_sp1$midpoint <- grMidpoint(GRanges(df_sp1)) # Add in gene midpoints
  dat_sp1 <- df_sp1
  result[[sp1]] <- dat_sp1

  # sp2 is trickier.
  # Its species-specific expansions cannot be part of the orthoPairs, by definition.
  # So what you can do is guess where the sp2 transcript corresponds to on the reference
  # genome based on its transcript coordinates.
  transcripts_sp2 <- as.data.frame(transcripts[[sp2]])
  transcripts_sp2$midpoint <- grMidpoint(transcripts[[sp2]])
  # Subset transcripts to only the longest per gene...
  transcripts_sp2$geneid <- unname(sapply(transcripts_sp2$tx_name, function(s) unlist(strsplit(s, "\\.t"))[1] ))
  # Split by geneID, select the largest transcript, then glue back together
  transcripts_sp2 <- split(transcripts_sp2, transcripts_sp2$geneid)
  transcripts_sp2 <- lapply(transcripts_sp2, function(geneid) {
    biggest_gene = geneid[which.max(geneid$width),]
    biggest_gene
  })
  transcripts_sp2 <- do.call(rbind, transcripts_sp2) |> as.data.frame()
  transcripts_sp2 <- transcripts_sp2[order(transcripts_sp2$seqnames, transcripts_sp2$start),]
  df_sp2 <- subset(transcripts_sp2, transcripts_sp2$seqnames %in% unique(unlist(orthopair$query.seqnames))) # Subset to only contigs that can be found within chr-scale scaffolds
  df_sp2 <- df_sp2[which(unlist(lapply(df_sp2$orthoFlagDF, function(x) x$expansion_species_specific ))==sp2),] # Subset to species-specific expansions

  # Now is where things get, uh, gross.
  # 1. Look for the genes immediately previous and next to every species-specific gene in sp2.
  # 2. If previous and next on same contig, then the position of the species-specific gene can be guesstimated
  #    relative to the reference genome.
  # 3. Look for previous and next gene within orthopairs. If both within orthopairs, then the position of
  #    the species-specific expanded gene is inferred to be between the start/end of the reference genome.
  # This returns a list, one element per gene in the target-specific genes.
  df_sp2_specific <- lapply(1:nrow(df_sp2), function(gene){
    cur_gene <- df_sp2[gene,]
    prev_gene <- transcripts_sp2[which(transcripts_sp2$tx_name == cur_gene$tx_name)-1,]
    next_gene <- transcripts_sp2[which(transcripts_sp2$tx_name == cur_gene$tx_name)+1,]
    if(nrow(prev_gene)!=0 & nrow(next_gene)!=0) {
      target_seqnames <- c(as.character(cur_gene$seqnames), as.character(prev_gene$seqnames),  as.character(next_gene$seqnames))
      # If all genes on same contig in the target genome...
      if(length(unique(target_seqnames)) == 1) { 
        # If previous and next genes in an orthopair...
        if(prev_gene$tx_name %in% orthopair$query.tx_name & next_gene$tx_name %in% orthopair$query.tx_name){
          prev_orthopair <- orthopair[orthopair$query.tx_name == prev_gene$tx_name,]
          next_orthopair <- orthopair[orthopair$query.tx_name == next_gene$tx_name,]
          query_seqnames <- c(as.character(prev_orthopair$seqnames), as.character(next_orthopair$seqnames))
          # If all members of this orthopair are on the same chromosome in the query genome...
          if(length(unique(query_seqnames)) == 1) {
            # Make sure that the query and target's genes are neighbours
            query_prev_g <- strsplit(prev_orthopair$tx_name, '\\.t')[[1]][1]
            query_next_g <- strsplit(next_orthopair$tx_name, '\\.t')[[1]][1]
            # Use the fact that the transcripts are sorted by their location to determine how many genes
            # are between the nearest matching genes.
            gene_distance <- which(transcripts_sp1$geneid == query_next_g) - which(transcripts_sp1$geneid == query_prev_g)
            gene_distance2 = transcripts_sp1[which(transcripts_sp1$geneid == query_next_g),]$start - transcripts_sp1[which(transcripts_sp1$geneid == query_prev_g),]$start
            if(gene_distance2 > 50000) {
              # TODO - this is inexplicably giving bad results! Fix this!
              print("Gahhh!")
              print(gene_distance2)
              print(prev_orthopair)
              print(next_orthopair)
              print(cur_gene)
              stop()
            }
            if(gene_distance == 2) {
              mod_orthopair  <- prev_orthopair
              mod_orthopair$start   <- prev_orthopair$end+1   # Create a fake locus start immediately after the preceding gene 
              mod_orthopair$end     <- next_orthopair$start-1 # Create a fake locus end immediately before the next gene 
              mod_orthopair$width   <- mod_orthopair$end - mod_orthopair$start
              mod_orthopair$tx_id   <- NA # A gene specific to sp2 cannot have a tx_id in the reference.
              mod_orthopair$tx_name <- NA
              mod_orthopair$dNdS_GUIDANCE2  <- NA # A species-specific gene cannot have a dN/dS value, because
              mod_orthopair$dNdS_HmmCleaner <- NA # dN/dS is only computed on one-to-one genes.
              mod_orthopair$dNdS_PRANK      <- NA
              mod_orthopair$orthoFlagDF <- cur_gene$orthoFlagDF
              mod_orthopair$query.start <- cur_gene$start
              mod_orthopair$query.end   <- cur_gene$end
              mod_orthopair$query.width <- cur_gene$end - cur_gene$start
              mod_orthopair$query.tx_id <- cur_gene$tx_id
              mod_orthopair$query.dNdS_GUIDANCE2  <- NA # A species-specific gene cannot have a dN/dS value, because
              mod_orthopair$query.dNdS_HmmCleaner <- NA # dN/dS is only computed on one-to-one genes.
              mod_orthopair$query.dNdS_PRANK      <- NA
              mod_orthopair$orthoFlagDF       <- cur_gene$orthoFlagDF # I make both orthoFlagDFs the same for convenience.
              mod_orthopair$query.orthoFlagDF <- cur_gene$orthoFlagDF
              mod_orthopair$midpoint <- (mod_orthopair$end + mod_orthopair$start)/2 # Have to re-calculate the midpoint manually
              rownames(mod_orthopair) <- NULL
              return(mod_orthopair)
            } else {
              warning_message = paste("sp2-specific gene ", cur_gene$tx_name, " is flanked by query genome orthopairs ", paste(prev_orthopair$tx_name, prev_orthopair$seqnames, prev_orthopair$start, prev_orthopair$end, collapse=','), " and ", paste(next_orthopair$tx_name, next_orthopair$seqnames, next_orthopair$start, next_orthopair$end, collapse=','), ", but they are not collinear. Can't infer position of target species-specific gene unless it can be placed between two collinear orthopairs in the reference genome.", sep="")
              warning(warning_message)
              return(NULL)
            }
          } else {
            warning_message = paste("sp2-specific gene ", cur_gene$tx_name, " is flanked by orthopairs from ", prev_orthopair$seqnames, " and ", next_orthopair$seqnames, " in the query genome. Can't infer position of target species-specific gene unless it can be placed between two collinear orthopairs in the reference genome.", sep="")
            warning(warning_message)
            return(NULL)
          }
        } else {
          warning_message = paste("sp2-specific gene ", cur_gene$tx_name, "'s next gene ", next_gene$tx_name, " and previous gene ", prev_gene$tx_name, " are not in orthopairs. Can't infer position of a species-specific gene unless it can be placed on the reference genome.", sep="")
          warning(warning_message)
          return(NULL)
        }
      } else {
        warning_message = paste("sp2-specific gene ", cur_gene$tx_name, "'s next gene ", next_gene$tx_name, " and previous gene ", prev_gene$tx_name, " are not on the same contig. seqnames: ", paste(target_seqnames, collapse=","), "\n Can't infer position of a species-specific gene unless neighbouring genes are on same contig.",  sep="")
        warning(warning_message)
        return(NULL)
      }
    } else {
      return(NULL)
    }
  })
  dat_sp2 <- do.call(rbind, df_sp2_specific) |> as.data.frame()
  # bind rows back into a data.frame
  result[[sp2]] <- dat_sp2
  
  # sneakily remove geneid from sp1 so that we can rbind all three dataframes later safely
  result[[sp1]] <- result[[sp1]][,-which(colnames(result[[sp1]]) == "geneid")]

  # Fix midpoints to ensure they use the query midpoints and not the target
  result[[sp2]]$midpoint <- (result[[sp2]]$end+result[[sp2]]$start)/2
  #result[[sp2]]$midpoint <- (result[[sp2]]$end+result[[sp2]]$start)/2

  result
}

big_chr <- c("chr1","chr2","PAR","XSR","YSR")
expansions <- SimpleList()
expansions$Oki_Kum <- collectCladeExpansions(orthopairs=orthoPairs, sp1="Oki", sp2="Kum", bigChr=big_chr, longShort=longShort$Oki) |> suppressWarnings()
big_chr <- c("Chr1","Chr2","PAR","XSR","YSR")
expansions$Osa_Aom <- collectCladeExpansions(orthopairs=orthoPairs, sp1="Osa", sp2="Aom", bigChr=big_chr, longShort=longShort$Osa) |> suppressWarnings()
expansions$Bar_Nor <- collectCladeExpansions(orthopairs=orthoPairs, sp1="Bar", sp2="Nor", bigChr=big_chr, longShort=longShort$Bar) |> suppressWarnings()
```

N.B. The function `collectCladeExpansions()` tries to warn you when something funny happens with respect to the target-specific genes. Funny occurrences include:
1. The target's genes immediately up- and down-stream of a target-specific gene are not encoded on the same contig
2. The target's genes immediately up- and down-stream of a target-specific gene are encoded on the same contig, but are not found within an orthoPair 
3. The target's genes immediately up- and down-stream of a target-specific gene are found within an orthoPair, but those orthoPairs are found on different chromosomes in the query genome
4. The target's genes immediately up- and down-stream of a target-specific gene are found within an orthoPair, and those orthoPairs are on the same chromosome, but they are not collinear

As above, you can inspect these flags with `warnings()`, although there will be more than 50 such warnings. You can increase this by using `options(nwarnings=10000)` before running the `collectCladeExpansions()` function (and make sure to remove `suppressWarnings()`). To save you some time, this is the result using the version `0.5.0` of the `BreakPointsData`:

Warning | Oki-Kum | Osa-Aom | Bar-Nor
------- | ------- | ------- | -------
1 (diff. target contigs) | 11 | 1 | 100
2 (neighbours not in orthoPairs) |  919 | 733 | 1842
3 (neighbour orthologues not same chr. in query) | 4 | 2 | 4
4 (neighbour orthologues not collinear in query) | 763 | 510 | 165

Having said all that, let's see some summary statistics.

```{r gene_expansions_2}
# Make sure factor levels are in alphabetical order and exclude chromosomes that were already snipped out.
# It makes the later faceting look ugly if they are not sorted properly.
expansions <- lapply(expansions, function(pair){
  lapply(pair, function(sp){
    sp$seqnames <- droplevels(factor(sp$seqnames, levels=sort(as.character(unique(sp$seqnames)))))
    sp
  })
})

# Inspect the distribution of data.
(lapply(expansions, function(pair) {
  sapply(pair, function(dup_tb) reshape2::acast(dup_tb, seqnames ~ Arm, value.var='tx_name', fun.aggregate = length) )
}))
```

Now, let's see where those duplications occur in the genome.

Gene family expansions in Okinawa+Kume
--------------------------------------
```{r gene_expansions_pos_oki_1, fig.height=4, fig.width=6, dev=c("svg", "png")}
# Plot distribution of clade-specific duplications across the genome.
plotExpansions <- function(pair, plotName, bin_size=100000, facet.by="seqnames~Arm"){
  ggplot(pair) +
    aes(x=start) +
    geom_histogram(binwidth=bin_size) +
    facet_wrap(facet.by, scales = "free_x", ncol=2) +
    ggtitle(plotName)
}

plotExpansions(expansions$Oki_Kum$Oki, 'Oki: Species-specific gene family expansions') # Oki-specific
plotExpansions(expansions$Oki_Kum$Kum, 'Kum: Species-specific gene family expansions') # Kum-specific
plotExpansions(expansions$Oki_Kum$Oki_Kum, 'Oki+Kum: Clade-specific gene family expansions') # Shared by Oki+Kum
```

Maybe there is a pattern there, maybe not. Are any of these comparisons statistically significant?

```{r gene_expansions_pos_oki_2, fig.height=4, fig.width=6, dev=c("svg", "png")}
plotExpansionStats <- function(duplication_pair, pair_name, bin_size=100000) {
  df <- duplication_pair |> mutate(bin=cut_width(midpoint, bin_size)) |> dplyr::group_by(seqnames, Arm, bin) |> dplyr::summarise(count=dplyr::n())
  plot1 <- ggplot(df) + aes(y=count) + geom_boxplot() + facet_wrap(~Arm, ncol=2) + ggtitle(paste(pair_name, ", dup. by arm", sep=""))
  plot2 <- ggplot(df) + aes(y=count) + geom_boxplot() + facet_wrap(seqnames~Arm, ncol=2) + ggtitle(paste(pair_name, ", dup. by chr/arm", sep=""))
  plot_joined = ggarrange(plot1, plot2)
  plot_joined
}

plotExpansionStats(duplications$Oki_Kum$Oki, pair_name = "Oki") # Oki-specific
plotExpansionStats(duplications$Oki_Kum$Kum, pair_name = "Kum") # Kum-specific
plotExpansionStats(duplications$Oki_Kum$Oki_Kum, pair_name = "Oki+Kum") # Shared by Oki+Kum

# Bin the genomes into windows of size X, then count the number of gene duplications for a given type.
calcExpansionStats <- function(duplication_pair, bin_size=100000, conf.level=0.95) {
  df <- duplication_pair |> mutate(bin=cut_width(midpoint, bin_size)) |> dplyr::group_by(seqnames, Arm, bin) |> dplyr::summarise(count=dplyr::n())
  anova = aov(df$count ~ df$seqnames * df$Arm) |> summary() 
  tukey = TukeyHSD(aov(df$count ~ df$seqnames + df$Arm), conf.level=conf.level)
  return(SimpleList(anova=anova, tukey=tukey))
}
(calcExpansionStats(duplications$Oki_Kum$Oki, bin_size=100000, conf.level=0.95)$anova) # Oki-specific
(calcExpansionStats(duplications$Oki_Kum$Kum, bin_size=100000, conf.level=0.95)$anova) # Kum-specific
(calcExpansionStats(duplications$Oki_Kum$Oki_Kum, bin_size=100000, conf.level=0.95)$anova) # Shared by Oki+Kum
```

Thus it seems that gene families that are expanded in or specific to Okinawa+Kume do not particularly associate with any genomic region (there is a weak relationship between chromosome arms). However, this does not give the whole story, since the two appear to have a relatively large number of species-specific genes and gene duplications.

Let's examine the rest of the data, but also try combining together the genes that are either Okinawa-specific OR Kume-specific:

```{r gene_duplications_pos_oki_3, fig.height=4, fig.width=6, dev=c("svg", "png")}
(calcExpansionStats(rbind(duplications$Oki_Kum$Oki, duplications$Oki_Kum$Kum), bin_size=100000, conf.level=0.95)$anova)
(calcExpansionStats(rbind(duplications$Oki_Kum$Oki, duplications$Oki_Kum$Kum), bin_size=100000, conf.level=0.95)$tukey)
```

Therefore, for Okinawa and Kume, it seems that there are on average more HOG expansions (and thus potential gene duplications) within short chromosome arms, although the number of expansions in long arms has a longer tail.

Just for completion, here are the plots above using the Oki OR Kum set.

```{r gene_expansions_pos_oki_4, fig.height=4, fig.width=6, dev=c("svg", "png")}
plotExpansions(rbind(duplications$Oki_Kum$Oki, duplications$Oki_Kum$Kum), plotName = "Oki OR Kum: Species-specific gene family expansions")
plotExpansionStats(rbind(duplications$Oki_Kum$Oki, duplications$Oki_Kum$Kum), pair_name = "Oki OR Kum")
```


Let's inspect the other chromosomal assemblies.

Gene family expansions in Osaka+Aomori
--------------------------------------
```{r gene_duplications_pos_osa_1}
plotExpansions(expansions$Osa_Aom$Osa, 'Osa: Species-specific gene family expansions') # Oki-specific
plotExpansions(expansions$Osa_Aom$Aom, 'Aom: Species-specific gene family expansions') # Kum-specific
plotExpansions(expansions$Osa_Aom$Osa_Aom, 'Osa-Aom: Clade-specific gene family expansions') # Shared by Oki+Kum
plotExpansions(rbind(duplications$Osa_Aom$Osa, duplications$Osa_Aom$Aom), 'Osa-Aom: Clade-specific gene family expansions') # Either Osa-specific or Aom-specific


ggplot(rbind(duplications$Osa_Aom$Osa, duplications$Osa_Aom$Aom)) +
  aes(x=midpoint) +
  geom_histogram(binwidth=100000) +
  facet_wrap(seqnames~Arm, scales = "free_x", ncol=2) +
  ggtitle('Osa-Aom: All species- and clade-specific duplications')

ggplot(rbind(duplications$Osa_Aom$Osa, duplications$Osa_Aom$Aom)) +
  aes(x=midpoint) +
  geom_histogram(binwidth=100000) +
  facet_wrap(~Arm, scales = "free_x", ncol=2) +
  ggtitle('Osa-Aom: All species- and clade-specific duplications')
```

```{r gene_duplications_pos_osa_2, fig.height=4, fig.width=6, dev=c("svg", "png")}
plotExpansionStats(duplications$Osa_Aom, pair_name = "Osa-Aom")

stats <- calcExpansionStats(duplications$Osa_Aom, pair_name = "Osa-Aom")
stats$anova
stats$tukey
```
```{r gene_duplications_pos_osa_3, fig.height=4, fig.width=6, dev=c("svg", "png")}
(calcExpansionStats(duplications$Osa_Aom$Osa, conf.level=0.95)$anova)
(calcExpansionStats(duplications$Osa_Aom$Aom, conf.level=0.95)$anova)
(calcExpansionStats(rbind(duplications$Osa_Aom$Osa, duplications$Osa_Aom$Aom), conf.level=0.95)$anova)
```
Gene family expansions in Barcelona+Norway
------------------------------------------
```{r gene_duplications_pos_bar_1}
ggplot(duplications$Bar_Nor$Bar_Nor) +
  aes(x=midpoint) +
  geom_histogram(binwidth=100000) +
  facet_wrap(seqnames~Arm, scales = "free_x", ncol=2) +
  ggtitle('Gene family expansions: Bar-Nor')

ggplot(duplications$Bar_Nor$Bar) +
  aes(x=midpoint) +
  geom_histogram(binwidth=100000) +
  facet_wrap(seqnames~Arm, scales = "free_x", ncol=2) +
  ggtitle('Species-specific gene family expansions: Bar')

ggplot(duplications$Bar_Nor$Nor) +
  aes(x=midpoint) +
  geom_histogram(binwidth=100000) +
  facet_wrap(seqnames~Arm, scales = "free_x", ncol=2) +
  ggtitle('Species-specific gene family expansions: Nor')

ggplot(do.call(rbind, duplications$Bar_Nor)) +
  aes(x=midpoint) +
  geom_histogram(binwidth=100000) +
  facet_wrap(seqnames~Arm, scales = "free_x", ncol=2) +
  ggtitle('Bar, Nor: All species- and clade-specific duplications')

# As above, but without faceting by sequence, which makes a certain pattern immediately clear...
ggplot(do.call(rbind, duplications$Bar_Nor)) +
  aes(x=midpoint) +
  geom_histogram(binwidth=100000) +
  facet_wrap(~Arm, scales = "free_x", ncol=2) +
  ggtitle('Bar, Nor: All species- and clade-specific duplications')
```

```{r gene_duplications_pos_bar_2, fig.height=4, fig.width=6, dev=c("svg", "png")}
plotExpansionStats(duplications$Bar_Nor, pair_name = "Bar-Nor")

stats <- calcExpansionStats(duplications$Bar_Nor, pair_name = "Bar-Nor")
stats$anova
stats$tukey
```

TODO
Clade-specific deletions
------------------------
In the same vein as the analysis above, let's examine where genes tend to be deleted. Here it is slightly easier, because we can simply look at cases where the `orthoPair` is a species-specific deletion of either the query or the target.


# Session information

```{r session_information}
sessionInfo()
```
